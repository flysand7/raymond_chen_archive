<body style=max-width:80ch;margin:auto>
<h1 class="entry-title" style="margin-bottom:15px;">What's the difference between int and INT, long and LONG, etc?</h1>  <!-- .entry-meta -->

<p>When you go through Windows header files, you’ll see types with names <code>INT</code>, <code>LONG</code>, <code>CHAR</code>, and so on. What’s the difference between these types and the uncapitalized ones?
 Well, there isn’t one any more.
 What follows is an educated guess as to the story behind these types.
 The application binary interface for an operating system needs to be unambiguous. Everybody has to agree on how parameters are passed, which registers are preserved, that sort of thing. A compiler need only enforce the calling convention rules at the boundary between the application and the operating system. When a program calls another function provided by that same program, it can use whatever calling convention it likes. (Not a true statement but the details aren’t important here.) Therefore, a calling convention attribute on the declarations of each operating system function is sufficient to get everybody to agree on the interface.
 However, another thing that everybody needs to agree on is the sizes of the types being passed to those functions or used in structures that cross the application/operating system boundary. The C language makes only very loose guarantees as to the sizes of each of the types, so language types like <code>int</code> and <code>long</code> would be ambiguous. One compiler might decide that a <code>long</code> is a 32-bit integer, and another might decide that it’s a 64-bit integer. To make sure that everybody was on the same page, the Windows header files defined “platform types” like <code>INT</code> and <code>LONG</code> with prescribed semantics that everybody could agree on. Each compiler vendor could tweak the Windows header file to ensure that the type definition for these platform types resulted in the value that Windows expected. One compiler might use <code>typedef long LONG</code> another might use <code>typedef __int32 LONG</code>.
 Okay, but this doesn’t explain <code>VOID</code>. Maybe <code>VOID</code> was added for the benefit of compilers which didn’t yet support the then-new ANSI C standard type <code>void</code>? Those older compilers could <code>typedef int VOID;</code> and functions that were declared as “returning <code>VOID</code>” would be treated as if they returned an integer that was always ignored. Or maybe it was just added to complete the set, who knows.</p>
<p> In the intervening years, most if not all compilers which target Windows have aligned their native types with Windows’ platform types. An <code>int</code> is always a 32-bit signed integer, as is a <code>long</code>. As a result, the distinction between language types and platform types is now pretty much academic, and the two can be used interchangeably. New Windows functions tend to be introduced with language types, leaving platform types behind only for compatibility. </p>


</body>
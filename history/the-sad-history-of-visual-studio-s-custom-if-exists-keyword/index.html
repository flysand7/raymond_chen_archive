<body style=max-width:80ch;margin:auto>
<h1 class="entry-title" style="margin-bottom:15px;">The sad history of Visual Studio’s custom <code>__if_exists</code> keyword</h1>  <!-- .entry-meta -->

<p>The Visual Studio C++ compiler has this weird nonstandard keyword called <code>__if_</code><code>exists</code>. (And its twin <code>__if_</code><code>not_</code><code>exists</code>.) Why does this keyword exist, and how should I use it?</p>
<p>Let’s get this out of the way: <b>Do not use __if_exists under any circumstances whatsoever.</b> This is pretty much a direct quote from <a href="https://twitter.com/StephanTLavavej"> Stephan T. Lavavej</a>, maintainer of the Visual C++ implementation of the C++ standard library and overall “person whose opinion on these sorts of matters you should take under serious consideration.” We’ll come back to this topic later in the article.</p>
<p>Okay, so where were we? Right, “What’s the deal with <code>__if_</code><code>exists</code>?”</p>
<p>Set the time machine to 1996.</p>
<p>The world was a much more innocent place. People left their doors unlocked at night and dialed into the Internet over their 28.8 Kb modems to check their AOL account to see if they got mail, hang out in a chat room, check out Yahoo’s top ten sites of the day, and maybe download some software.</p>
<p>Well, that last bit is still true today: Some people still download software over the Internet.¹</p>
<p>This was also an era in which developers <a href="https://devblogs.microsoft.com/oldnewthing/20190827-00/?p=102809"> counted bytes</a>, so minimizing the size of the download was a big deal. There was this programming language called C++ that hadn’t yet been standardized, but everybody wanted to use it anyway. Compilers of this era didn’t know what vectorization was, they didn’t think to defer code generation to link time, and they didn’t realize that <i>undefined behavior</i> gave them permission to <a href="https://devblogs.microsoft.com/oldnewthing/20140627-00/?p=633"> violate the laws of physics</a>.</p>
<p>This was the world that the Active Template Library (ATL) was born into.</p>
<p>The ATL team was obsessed with minimizing code size. They came up with all sorts of ideas for how the compiler could shrink binary sizes. Some of those features turned out to be really good ideas that stood the test of time, like <code>__declspec(novtable)</code>.</p>
<p>Another of those features was <code>__if_<code></code>exists</code>. It was, in retrospect, not one of those really good ideas.</p>
<p>Remember, this was pre-standard C++. Templates existed in rudimentary form. There was no explicit or partial specialization, no traits types, no template meta-programming, and no SFINAE. Templates in this era were not much more than macros on steroids.</p>
<p>The compiler folks were cajoled into creating a prototype for the <code>__if_<code></code>exists</code> feature, and the ATL team was very pleased with how it turned out. The compiler team wasn’t too excited about shipping this prototype-quality feature, but the ATL team insisted that it was essential to making binaries smaller, so the compiler team reluctantly went along with it.</p>
<p>And that’s how <code>__if_<code></code>exists</code> ended up in the Visual C++ compiler.</p>
<p>Over time, many people got access to high-speed Internet, the C++ language was standardized, template specialization, template partial specialization, and SFINAE were invented, and as a result, template meta-programming became possible. If all of these language features were put into a time machine and sent back to 1996, there would be no need for <code>__if_<code></code>exists</code>.</p>
<p>The functionality of the <code>__if_<code></code>exists</code> feature was permanently frozen to what shipped in that first prototype, which was itself just good enough to satisfy the immediate needs of the ATL team. The MSDN documentation was updated to document the specific scenarios that are known to work well, leaving everything else as undefined.</p>
<p>And if you go look in the ATL code base, it’s not even used very much. The only places you’ll find it are in the code that was written in that initial release back in 1996. If those classes needed to be rewritten today for some reason, the replacement would certainly not use <code>__if_<code></code>exists</code>.</p>
<p>If you have code that uses <code>__if_<code></code>exists</code>, you should consider moving to standards-compliant alternatives. For example, if you’re using <code>__if_<code></code>exists</code> to compile a block of code only if a member function exists (which is what ATL uses it for), you can use SFINAE to do the detection and <code>if constexpr</code> to conditionalize the compilation.</p>
<p>Thanks to my colleague <a href="https://twitter.com/joncaves"> Jonathan Caves</a> for sharing the history behind <code>__if_exists</code> (and probably undoing several years of therapy in the process).</p>
<p><b>Bonus chatter</b>: Jonathan tells me that <code>__if_exists</code> is a gift that keeps on giving. Whenever the Visual C++ team goes in and rewrites their C++ parser to handle new language features, or simply to make it run better, they have to retrofit <code>__if_exists</code> support into it. And that’s when they discover some of the truly insane things people have done with it, like putting code inside an <code>__if_exists</code> block that do not even form a complete C++ construct. The gift has even spread to other compilers: <a href="http://releases.llvm.org/3.0/docs/ClangReleaseNotes.html"> clang 3.0</a> added support for <code>__if_exists</code>. So now multiple compiler vendors have therapy bills to pay.</p>
<p>¹ Okay, and some people still access the Internet over dial-up.</p>
<p> </p>


</body>
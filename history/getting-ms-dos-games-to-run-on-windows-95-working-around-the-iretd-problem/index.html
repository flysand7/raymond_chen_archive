<body style=max-width:80ch;margin:auto>
<h1 class="entry-title" style="margin-bottom:15px;">Getting MS-DOS games to run on Windows 95: Working around the iretd problem</h1>  <!-- .entry-meta -->

<p>Today’s story is the story of <a href="https://archive.org/details/msdos_Speed_Racer_in_The_Challenge_of_Racer_X_1992"><i>Speed Racer in the Challenge of Racer X</i></a>. Here goes. The really scary thing is that <i>I still remember the details</i>. </p>
<p>To this day, I can’t bear to listen to the Speed Racer theme song because I spent over a week debugging why the program froze up right after the title sequence music. The crashes were completely nonsensical and random. </p>
<p>Windows 95 uses the <code>iretd</code> instruction to return from the kernel back to the application. After days of frustrating head-scratching, I eventually discovered that if you use the instruction to return from the kernel back to the application, and the application is running 32-bit protected-mode code on a 16-bit stack, then only the bottom 16 bits of the <code>esp</code> register are updated by the <code>iretd</code> instruction. The upper 16 bits remain unchanged and continue to hold the value they had while you were in kernel mode. This behavior doesn’t appear to be documented anywhere in Intel’s reference books.¹ </p>
<p>The effect of this is that 32-bit protected-mode code running on a 16-bit stack will observe that the upper 16 bits of the <code>esp</code> register are spontaneously corrupted randomly. (<a href="https://technet.microsoft.com/en-us/magazine/jj203546.aspx">Sound familiar</a>?) Unfortunately, <i>Speed Racer</i> was counting on the upper 16 bits of the <code>esp</code> register remaining zero. </p>
<p>To fix this, I had to counter insanity with more insanity. </p>
<p>At the last moment before restoring all the general purpose registers and executing the <code>iretd</code> instruction, Windows 95 does a check to see whether the troublesome scenario is about to occur. If so, the kernel sets up a temporary stack selector whose base linear address matches the high 16 bits of the kernel <code>esp</code> register, then switches to that stack while simultaneously zeroing out the high 16 bits of its own <code>esp</code> register. This double-switch rewrites the <code>ss:esp</code> value such that it points to the same memory, but shuffles the bits around to arrange for the high 16 bits of <code>esp</code> to be zero. In other words, it rewrote <code>SS:ESP = 00000000 + xxxxyyyy</code> as <code>SS:ESP = xxxx0000 + 0000yyyy</code>. (<a href="https://devblogs.microsoft.com/oldnewthing/">Sound familiar</a>?) </p>
<p>At this point, the kernel is set up to restore the general purpose registers and perform the <code>iretd</code>. This returns control back to the application with the high 16 bits of the <code>esp</code> register set to zero, as the application expects. </p>
<p>Now, this may seem like an awful lot of work just to get a single game to work, and it’s not like <i>Speed Racer</i> was a blockbuster game like <i>DOOM</i>. However, this particular problem was not intrinsic to <i>Speed Racer</i>. Rather, it was a problem in the client-side library code that came with the MS-DOS extender they were using, and that MS-DOS extender was one of the major players in the MS-DOS extender market, so fixing this issue actually fixed a lot of programs. It’s just that <i>Speed Racer</i> was the first one discovered to exhibit the problem, so it was the one I ended up debugging. </p>
<p>¹Maybe I’m missing it. <a href="http://tptp.cc/mirrors/siyobik.info/instruction/IRET%252FIRETD.html">You tell me if you see it in there</a>. The pseudocode at the <code>RETURN-TO-OUTER-PRIVILEGE-LEVEL</code> label talks about raising an exception if the stack doesn’t have at least 8 bytes of data in it, but it doesn’t appear to discuss what happens to the <code>esp</code> register. The discussion says “If the return is to another privilege level, the IRET instruction also pops the stack pointer and SS from the stack,” but it doesn’t mention what happens if the destination stack pointer is a different size from the current stack pointer. </p>


</body>
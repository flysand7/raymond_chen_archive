<body style=max-width:80ch;margin:auto>
<h1 class="entry-title" style="margin-bottom:15px;">What can I do with the HINSTANCE returned by the ShellExecute function?</h1>  <!-- .entry-meta -->

<p>As we saw earlier, <a href="http://blogs.msdn.com/oldnewthing/archive/2004/06/14/155107.aspx"> in 16-bit Windows, the <code>HINSTANCE</code> identified a program</a>. The Win32 kernel is a complete redesign from the 16-bit kernel, introducing such concepts as “kernel objects” and “security descriptors”. In particular 16-bit Windows didn’t have “process IDs”; the instance handle served that purpose. That is why the <code>WinExec</code> and <code>ShellExecute</code> functions returned an <code>HINSTANCE</code>. But in the 32-bit world, <code>HINSTANCE</code>s do not uniquely identify a running program since it is merely the base address of the executable. Since each program runs in its own address space, that value is hardly unique across the entire system.
 So what can you do with the <code>HINSTANCE</code> returned by the <code>ShellExecute</code> function? You can check if it greater than 32, indicating that the call was successful. If the value is less than 32, then it is an error code. The precise value of the <code>HINSTANCE</code> in the greater-than-32 case is meaningless.
 Why am I bothering to tell you things that are already covered in MSDN? Because people still have trouble putting two and two together. I keep seeing people who take the <code>HINSTANCE</code> returned by the <code>ShellExecute</code> function and hunt through all the windows in the system looking for a window with a matching <code>GWLP_HINSTANCE</code> (or <code>GWL_HINSTANCE</code> if you’re still living in the unenlightened non-64-bit-compatible world). This doesn’t work for the two reasons I described above. First, the precise value of the <code>HINSTANCE</code> you get back is meaningless, and even if it were meaningful, it wouldn’t do you any good since the <code>HINSTANCE</code> is not unique. (In fact, the <code>HINSTANCE</code> for a process is nearly always 0x00400000, since that is the default address most linkers assign to program executables.)
 The most common reason people want to pull this sort of trick in the first place is that they want to do something with the program that was just launched, typically, wait for it to exit, indicating that the user has closed the document. Unfortunately, this plan comes with its own pitfalls.
 First, as we noted, the <code>HINSTANCE</code> that you get from the <code>ShellExecute</code> function is useless. You have to use the <code>ShellExecuteEx</code> function and set the <code>SEE_MASK_NOCLOSEPROCESS</code> flag in the <code>SHELLEXECUTEINFO</code> structure, at which point a handle to process is returned in the <code>hProcess</code> member. But that still doesn’t work.
 A document can be executed with no new process being created. The most common case (but hardly the only such) in which you will encounter this is if the registered handler for the document type requested a DDE conversation. In that case, an existing instance of the program has accepted responsibility for the document. Waiting for the process to exit is not the same as waiting for the user to close the document, because closing the document doesn’t exit the process.
 Just because the user closes the document doesn’t mean that the process exits. Most programs will let you open a new document from the “File” menu. Once that new document is opened, the user can close the old one. (Single-document programs implicitly close the old document when the new one is opened.) What’s more, closing all open windows associated with the document need not result in the program exiting. Some programs run in the background even after you’ve closed all their windows, either to provide some sort of continuing service, or just because they are just anticipating that the user will run the program again soon so they delay the final exit for a few minutes to see if they will be needed.
 Just because the process exits doesn’t mean that the document is closed. Some programs detect a previous instance and hand off the document to that instance. Other programs are stubs that launch another process to do the real work. In either case, the newly-created process exits quickly, but the document is still open, since the responsibility for the document has been handed off to another process.</p>
<p> There is no uniform way to detect that a document has been closed. Each program handles it differently. If you’re lucky, the program exposes properties that allow you to monitor the status of an open document. <a href="http://blogs.msdn.com/oldnewthing/archive/2005/07/05/435657.aspx">As we saw earlier</a>, Internet Explorer exposes properties of its open windows through the <code>ShellWindows</code> object. I understand that Microsoft Office also exposes a rather elaborate set of automation interfaces for its component programs. </p>


</body>
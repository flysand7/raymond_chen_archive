<body style=max-width:80ch;margin:auto>
<h1 class="entry-title" style="margin-bottom:15px;">Why are there both TMP and TEMP environment variables, and which one is right?</h1>  <!-- .entry-meta -->

<p>If you snoop around your environment variables, you may notice that there are two variables that propose to specify the location of temporary files. There is one called <code>TMP</code> and another called <code>TEMP</code>. Why two? And if they disagree, then who’s right? </p>
<p>Rewind to 1973. The operating system common on microcomputers was CP/M. The CP/M operating system had no environment variables. That sounds like a strange place to start a discussion of environment variables, but it’s actually important. Since it had no environment variables, there was consequently neither a <code>TMP</code> nor a <code>TEMP</code> environment variable. If you wanted to configure a program to specify where to put its temporary files, you needed to do some sort of program-specific configuration, like patching a byte in the executable to indicate the drive letter where temporary files should be stored. </p>
<p>(My recollection is that most CP/M programs were configured via patching. At least that’s how I configured them. I remember my WordStar manual coming with details about which bytes to patch to do what. There was also a few dozen bytes of patch space set aside for you to write your own subroutines, in case you needed to add custom support for your printer. I did this to add an “Is printer ready to accept another character?” function, which allowed for smoother background printing.) </p>
<p>Move forward to 1981. The 8086 processor and the MS-DOS operating system arrived on the scene. The design of <a href="http://blogs.msdn.com/b/oldnewthing/archive/2004/01/05/47685.aspx">both the 8086 processor</a> and <a href="http://blogs.msdn.com/b/oldnewthing/archive/2008/07/07/8699128.aspx">the MS-DOS operating system</a> were strongly inspired by CP/M, so much so that <a href="http://www.patersontech.com/dos/byte%E2%80%93inside-look.aspx">it was the primary design goal that it be possible to take your CP/M program written for the 8080 processor and machine-translate it into an MS-DOS program written for the 8086 processor</a>. Mind you, the translator assumed that you didn’t play any sneaky tricks like self-modifying code, jumping into the middle of an instruction, or using code as data, but if you played honest, the translator would convert your program. </p>
<p>(The goal of allowing machine-translation of code written for the 8080 processor into code written for the 8086 processor helps to explain some of the quirks of the 8086 instruction set. For example, the H and L registers on the 8080 map to the BH and BL registers on the 8086, and on the 8080, the only register that you could use to access a computed address was HL. This is why of the four basic registers AX, BX, CX, and DX on the 8086, the only one that you can use to access memory is BX.) </p>
<p>One of the things that MS-DOS added beyond compatibility with CP/M was environment variables. Since no existing CP/M programs used environment variables, none of the first batch of programs for MS-DOS used them either, since the first programs for MS-DOS were all ported from CP/M. Sure, you could set a <code>TEMP</code> or <code>TMP</code> environment variable, but nobody would pay attention to it. </p>
<p>Over time, programs were written with MS-DOS as their primary target, and they started to realize that they could use environment variables as a way to store configuration data. In the ensuing chaos of the marketplace, two environment variables emerged as the front-runners for specifying where temporary files should go: <code>TEMP</code> and <code>TMP</code>. </p>
<p>MS-DOS 2.0 introduced the ability to pipe the output of one program as the input of another. Since MS-DOS was a single-tasking operating system, this was simulated by redirecting the first program’s output to a temporary file and running it to completion, then running the second program with its input redirected from that temporary file. Now all of a sudden, MS-DOS needed a location to create temporary files! For whatever reason, the authors of MS-DOS chose to use the <code>TEMP</code> variable to control where these temporary files were created. </p>
<p>Mind you, the fact that <code>COMMAND.COM</code> chose to go with <code>TEMP</code> didn’t affect the fact that other programs could use either <code>TEMP</code> or <code>TMP</code>, depending on the mood of their original author. Many programs tried to appease both sides of the conflict by checking for both, and it was up to the mood of the original author which one it checked first. For example, the old <code>DISKCOPY</code> and <code>EDIT</code> programs would look for <code>TEMP</code> before looking for <code>TMP</code>. </p>
<p>Windows went through a similar exercise, but for whatever reason, the original authors of the <code>Get­Temp­File­Name</code> function chose to look for <code>TMP</code> before looking for <code>TEMP</code>. </p>
<p>The result of all this is that the directory used for temporary files by any particular program is at the discretion of that program, Windows programs are likely to use the <code>Get­Temp­File­Name</code> function to create their temporary files, in which case they will prefer to use <code>TMP</code>. </p>
<p>When you go to the Environment Variables configuration dialog, you’ll still see both variables there, <code>TMP</code> and <code>TEMP</code>, still duking it out for your attention. It’s like Adidas versus Puma, geek version. </p>


</body>
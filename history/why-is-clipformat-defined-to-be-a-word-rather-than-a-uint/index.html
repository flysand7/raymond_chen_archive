<body style=max-width:80ch;margin:auto>
<h1 class="entry-title" style="margin-bottom:15px;">Why is CLIPFORMAT defined to be a WORD rather than a UINT?</h1>  <!-- .entry-meta -->

<p>Commenter Ivo wants to know <a href="http://blogs.msdn.com/b/oldnewthing/archive/2008/04/30/8440201.aspx#8443802"> if the <code>Register­Clipboard­Format</code> function returns a <code>UINT</code>, why is the <code>CLIP­FORMAT</code> data type defined to be a <code>WORD</code></a>? Since a <code>WORD</code> is smaller than a <code>UINT</code>, you have to stick in a cast every time you assign the result of <code>Register­Clipboard­Format</code> to a <code>CLIP­FORMAT</code>.
 Rewind to 16-bit Windows. Back in those days, a <code>UINT</code> and a <code>WORD</code> were the same size, namely, 16 bits. As a result, people got lazy about the distinction. Six of one, a half dozen of the other. (People are lazy about this sort of distinction even today, assuming for example that <code>UINT</code> and <code>DWORD</code> are the same size, and in turn <a href="http://blogs.msdn.com/b/oldnewthing/archive/2005/01/31/363790.aspx"> forcing <code>UINT</code> to remain a 32-bit integer type even on 64-bit Windows</a>.) The <code>Register­Clipboard­Format</code> function came first, and when the OLE folks wanted to define a friendly name for the data type to hold a clipboard format, they said, “Well, a clipboard format is a 16-bit integer, so let me use a 16-bit integer.” A <code>WORD</code> is a 16-bit integer, so there you go.
 This mismatch had no effect in 16-bit code, but once Win32 showed up, you had a problem since 32-bit Windows expanded the <code>UINT</code> type to 32 bits. Not only does keeping a <code>CLIP­FORMAT</code> in a <code>WORD</code> create the need for all this casting, it also leaves two bytes of padding in the <code>FORMAT­ETC</code> structure. Strike two.</p>
<p> Yeah, basically, it sucks. </p>


</body>
<body style=max-width:80ch;margin:auto>
<h1 class="entry-title" style="margin-bottom:15px;">Why does ShellExecute return SE_ERR_ACCESSDENIED for nearly everything?</h1>  <!-- .entry-meta -->

<p>We saw a while ago that <a href="http://blogs.msdn.com/b/oldnewthing/archive/2010/11/18/10092914.aspx"> the <code>Shell­Execute</code> function returns <code>SE_ERR_ACCESS­DENIED</code> at the slightest provocation</a>. Why can’t it return something more meaningful?
 The short-term answer is that <a href="http://blogs.msdn.com/b/oldnewthing/archive/2006/05/05/590749.aspx"> the return value from <code>Shell­Execute</code> is both a success code and an error code</a>, and you check whether the value is <a href="http://blogs.msdn.com/b/oldnewthing/archive/2006/11/08/1035971.aspx"> greater than 32</a> to see which half you’re in. In particular, the error code case is if the value you got is less than or equal to 32. This already demonstrates that the error codes are limited to values less than or equal to 32. And all those error codes are already accounted for, so there’s nowhere to stick “an error not on the original list of 32 possible error codes.” Therefore, any error that wasn’t on the original list of error codes gets turned into <code>SE_ERR_ACCESS­DENIED</code>, in the same way that MS-DOS turned <a href="http://blogs.msdn.com/b/oldnewthing/archive/2005/01/17/354399.aspx"> any error that didn’t map to one of its original errors into 5 (access denied)</a>.
 Okay, but why was 32 chosen as the cut-off?
 The <code>Shell­Execute</code> function didn’t come up with that number. That number came from the kernel folks, who decided that <code>Win­Exec</code> function returned the handle to the application that was executed on success, or an error code less than 32 on failure. And back in the old days, <code>Shell­Execute</code> was just a function that called <code>Find­Executable</code> and then passed the result to <code>Win­Exec</code>, so following the <code>Win­Exec</code> pattern made sense.
 (You may have noticed a tiny discrepancy there. The shell folks decided to add a new error code <code>SE_ERR_DLL­NOT­FOUND</code> with a numeric value of 32, thereby making the return value from <code>Shell­Execute</code> behave subtly differently from that of <code>Win­Exec</code>. The people who made this decision probably regretted it once it became clear that lots of applications were checking the return value incorrectly, but it’s too late to fix it now.)
 Okay, so let’s peel back another layer: Why did the <code>Win­Exec</code> function overload the return value? Well, overloaded return values were all the rage back then. A lot of functions to create something return the created object on success, or null on failure. The kernel folks said, “Well, we can do even better than that. Not only can we tell you that we failed to create the application, we can even tell you why! You see, MS-DOS has <a href="http://blogs.msdn.com/b/oldnewthing/archive/2005/01/17/354399.aspx"> a maximum of 31 error codes</a>, so we can just return the error code directly if we can ensure that no values less than 32 are valid segments. And we can make that guarantee because the 8086 processor reserves the first 1024 bytes of memory (the first 64 segments) for its interrupt vector table, so no application could possibly be loaded there. Hooray! We’re such over-achievers!”
 This weird way of reporting errors from <code>Shell­Execute</code> has been preserved for compatibility. New applications would probably better served to switch to the <code>Shell­Execute­Ex</code> function instead, since it reports errors by calling <code>Set­Last­Error</code> with the <i>real</i> error code before returning. (In other words, you can call <code>Get­Last­Error</code> to get the real error code.)
 <b>Bonus chatter</b>: Wait a second, if <code>Get­Last­Error</code> gets you the real error code, how come the original report was that <a href="http://blogs.msdn.com/b/oldnewthing/archive/2010/11/18/10092914.aspx"> the <code>Shell­Execute­Ex</code> function also returns <code>SE_ERR_ACCESS­DENIED</code></a>?
 Because it depends on what you mean by “returns”. Technically speaking, the <code>Shell­Execute­Ex</code> function returns <code>FALSE</code> for all errors, since it is prototyped as returning a <code>BOOL</code>. When somebody says that it returns an error code, you first have to ask where they got that error code from.
 If they got it from <code>Get­Last­Error</code>, then they’ll get a meaningful error code, or at least something more meaningful than <code>SE_ERR_ACCESS­DENIED</code>.</p>
<p> But if instead they look at the <code>hInstApp</code> member of the <code>SHELL­EXECUTE­INFO</code> structure, then they’ll get that useless <code>SE_ERR_ACCESS­DENIED</code> value again. Because the <code>hInstApp</code> is where the legacy return value is recorded. If you look there, you’re going to see the old lame error code. So don’t look there. </p>


</body>
<body style=max-width:80ch;margin:auto>
<h1 class="entry-title" style="margin-bottom:15px;">The evolution of version resources – corrupted 32-bit version resources</h1>  <!-- .entry-meta -->

<p>
<a href="http://blogs.msdn.com/oldnewthing/archive/2006/12/21/1340571.aspx">
Last time we looked at the format of 32-bit version resources</a>,
but I ended with the remark that what you saw purported to be
the resources of <code>shell32.dll</code> but actually weren’t.
What’s going on here?
</p>
<p>
The resources I presented last time were what the resources
of <code>shell32.dll</code> <strong>should have been</strong>,
but in fact they aren’t.
</p>
<p>
A common mistake in generating 32-bit resources is to mistreat
the <code>cbData</code> field of the structure I called a
<code>VERSIONNODE</code> as a count of <strong>characters</strong>
rather than a count of bytes if the type is Unicode text.
Even Microsoft’s own Resource Compiler has fallen into this trap!
For example, consider this <code>VERSIONNODE</code> I presented last time:
</p>
<pre>
0098  4C 00         // cbNode (node ends at 0x0088 + 0x004C = 0x00D40)
009A  2C 00         // cbData
009C  01 00         // wType = 1 (string data)
009E  43 00 6F 00 6D 00 70 00 61 00 6E 00 79 00 4E 00
      61 00 6D 00 65 00 00 00
                    // L"CompanyName" + null terminator
00B6  00 00         // padding to restore alignment
00B8  4D 00 69 00 63 00 72 00 6F 00 73 00 6F 00 66 00
      74 00 20 00 43 00 6F 00 72 00 70 00 6F 00 72 00
      61 00 74 00 69 00 6F 00 6E 00 00 00
                    // L"Microsoft Corporation" + null terminator
00E4                // no padding needed
</pre>
<p>
In real life, the data take the following form:
</p>
<pre>
0098  4C 00         // cbNode (node ends at 0x0088 + 0x004C = 0x00D40)
009A  <font color="blue">16</font> 00         // <font color="blue">cchData (!)</font>
009C  01 00         // wType = 1 (string data)
...
</pre>
<p>
These malformed version resources manage to get away without
crashing too horribly because the standard format of version resources
uses string data only in leaf nodes.
Therefore, the incorrect <code>cbData</code> affects only the
node itself and doesn’t cause the child nodes to be parsed
incorrectly (since there are no child nodes).
</p>
<p>
Until somebody tries to read, say,
<code>\StringFileInfo\040904B0\CompanyName\oops</code>.
After the <code>VerQueryValue</code> function locates
the <code>VERSIONNODE</code> corresponding to <code>CompanyName</code>,
it tries to locate the first child node and, due to the incorrect
<code>cbData</code>, ends up misinterpreting the middle of the
string as if it were the start of a child <code>VERSIONNODE</code>.
Things only go downhill from there.
</p>
<p>
They’re just lucky that nobody actually asks for that.
</p>
<p>
But wait, there’s more.
Somebody who calls
the <code>VerQueryValueA</code> function expects to have the
version string returned as ANSI, so <code>VerQueryValueA</code>
needs to know how many characters to convert from Unicode to ANSI.
If <code>VerQueryValue</code> trusted the erroneous <code>cbData</code>
value, then ANSI callers would get only half the data they were expecting.
</p>
<p>
As a result of this mess, the <code>VerQueryValue</code> function
keeps its eyes open and anticipates that the version resource it
was given to parse may have been generated by one of these buggy
version resource compilers and goes to some extra effort to accommodate
those bugs.</p>


</body>
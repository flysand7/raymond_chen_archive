<body style=max-width:80ch;margin:auto>
<h1 class="entry-title" style="margin-bottom:15px;">A history of GlobalLock, part 3: Transitioning to Win32</h1>  <!-- .entry-meta -->

<p>Now that you know how the 16-bit memory manager handled the global heap, it’s time to see how this got transitioned to the new 32-bit world.</p>
<p> <a href="http://msdn.microsoft.com/library/en-us/memory/base/globalalloc.asp"> The <code>GlobalAlloc</code> function</a> continued to emulate all its previous moveability rules, but the return value of <code>GlobalAlloc</code> was no longer a selector since Win32 used the processor in “flat mode”. </p>
<p> This means that the old trick of caching a selector and reallocating the memory out from under it no longer worked. </p>
<p> Moveability semantics were preserved.  Memory blocks still had a lock count, even though it didn’t really accomplish anything since Win32 never compacted memory.  (Recall that the purpose of the lock count was to prevent memory from moving during a compaction.) </p>
<p> Moveable memory and locking could have been eliminated completely, if it weren’t for <a href="http://msdn.microsoft.com/library/en-us/memory/base/globalflags.asp"> the <code>GlobalFlags</code> function</a>.  This function returns several strange bits of information—now entirely irrelevant—the most troubling of which is the lock count.  Consequently, the charade of locking must be maintained just in case there’s some application that actually snoops at the lock count, or a program that expected <a href="http://msdn.microsoft.com/library/en-us/memory/base/globalrealloc.asp"> the <code>GlobalReAlloc</code> function</a> to fail on a locked block. </p>
<p> Aside from that, moveable memory gets you nothing aside from overhead. </p>
<p> <a href="http://msdn.microsoft.com/library/en-us/memory/base/localalloc.asp"> The <code>LocalAlloc</code> function</a> also carries the moveability overhead, but since local memory was never passed between DLLs in Win16, the local heap functions don’t carry as much 16-bit compatibility overhead as the global heap functions. <code>LocalAlloc</code> is preferred over <code>GlobalAlloc</code> in Win32 for that reason.  (Of course, many functions require a specific type of memory allocation, in which case you don’t have any choice. The clipboard, for example, requires moveable global handles, and COM requires use of the task allocator.) </p>
<p> <a href="http://blogs.msdn.com/oldnewthing/archive/2004/11/09/254441.aspx"> Next time</a>, an insight into how locking is implemented (even though it doesn’t do anything). </p>


</body>
<body style=max-width:80ch;margin:auto>
<h1 class="entry-title" style="margin-bottom:15px;">What is the lpdwHandle parameter in GetFileVersionInfoSize used for?</h1>  <!-- .entry-meta -->

<p>The <code>GetFileVersionInfoSize</code> function returns two pieces of information. The return value is the amount of memory needed to record the version information of a file, and the <code>DWORD</code> pointed to by the <code>lpdwHandle</code> parameter is set to zero. What’s the deal with this strange <code>lpdwHandle</code> parameter?
 That parameter used to do something.
 The documentation for <code>GetFileVersionInfo</code> used to read</p>
<blockquote class="m"><p> <i>dwHandle</i>: The value returned by a preceding call to <code>GetFileVersionInfoSize</code> in the <code>lpdwHandle</code> parameter. </p></blockquote>
<p> The purpose of that parameter is to allow <code>GetFileVersionInfoSize</code> to pass information to <code>GetFileVersionInfo</code> about what it found.
 In 16-bit Windows and Windows 95, 98, and Me, the <code>GetFileVersionInfoSize</code> function opened the target file and went searching for the version information. Once it was located, the size of the version was the return value and the file offset of the version information was stored in <code>lpdwHandle</code>. The <code>GetFileVersionInfo</code> function was very simple: It merely read <code>dwLen</code> bytes from the file starting at file offset <code>dwHandle</code>.
 In the Windows NT series, this mechanism was abandoned. The handle is not used any more. Why not? I don’t know, but I have some guesses.
 First, Windows NT supports files larger than 2GB, so a 32-bit value isn’t big enough to hold a file offset value.
 Second, multitasking introduces a race condition in the <code>GetFileVersionInfoSize</code>/<code>GetFileVersionInfo</code> pattern. Whereas in 16-bit Windows, nobody could modify the file between the two calls due to co-operative multi-tasking, in 32-bit Windows, it’s possible that somebody could sneak in and modify the file between the two calls, resulting in the call to <code>GetFileVersionInfo</code> returning garbage. (Yes, Windows 95 has this race condition.)
 Third, the amount of memory required to load the version resource is not the same as the actual size of the version resource. It’s not enough just to seek to the specified location and read <code>dwLen</code> bytes from it. For example, a program might load the version resources from a 32-bit module, and we’ve seen earlier that 32-bit version resources are Unicode. But that program might then call <code>VerQueryValueA</code> to retrieve the version string in the ANSI code page. The <code>GetFileVersionInfo</code> function needs to return a buffer that can hold not only the actual version resource but also enough memory to hold copies of all the strings in the version resource converted to the ANSI character set so that the <code>VerQueryValueA</code> function could return them.
 Whatever the reason, the Windows NT series of operating systems don’t use the handle value. When you call <code>GetFileVersionInfoSize</code>, the function looks for the version resource and returns the size of the memory block needed to record it. (Which, as we saw above, includes translation space for the ANSI strings.) When you call <code>GetFileVersionInfo</code>, the function starts over from scratch and looks for the version resource and copies it into the buffer.
 The <code>dwHandle</code> parameter is now just a vestigial organ.
 <b>Prediction</b></p>
<p> People will take this as the opportunity to complain about the <code>GetFileVersionInfo</code> family of functions. (Because all I have to do is mention a function name, and that makes it open season on all problems related to that function, as if every function I mention is one that I have total responsibility and authority over.) </p>


</body>
<body style=max-width:80ch;margin:auto>
<h1 class="entry-title" style="margin-bottom:15px;">What does the "l" in lstrcmp stand for?</h1>  <!-- .entry-meta -->

<p>If you ask <a href="http://blogs.msdn.com/michkap/"> Michael Kaplan</a>, he’d probably say that <a href="http://blogs.msdn.com/michkap/archive/2008/03/07/8086758.aspx"> it stands for <i>lame</i></a>.
 In his article, Michael presents a nice chart of the various L-functions and their sort-of counterparts. There are other L-functions not on his list, not because he missed them, but because they don’t have anything to do with characters or encodings. On the other hand, those other functions help shed light on the history of the L-functions. Those other functions are <i>lopen</i>, <i>lcreat</i>, <i>lread</i>, <i>lwrite</i>, <i>lclose</i>, and <i>llseek</i>. There are all L-version sort-of counterparts to <i>open</i>, <i>creat</i>, and <i>read</i>, <i>write</i>, <i>close</i>, and <i>lseek</i>. Note that we’ve already uncovered the answer to the unasked question “Why does llseek have two L’s?” The first L is a prefix (whose meaning we will soon discover) and the second L comes from the function it’s sort-of acting as the counterpart to.
 But what does the L stand for? Once you find those other L-functions, you’ll see next door the H-functions <i>hread</i> and <i>hwrite</i>. As we learned a while back, <a href="http://blogs.msdn.com/oldnewthing/archive/2008/12/12/9199378.aspx"> being lucky is simply observing things you weren’t planning to observe</a>. We weren’t expecting to find the H-functions, but there they were, and they blow the lid off the story.
 The H prefix in <i>hread</i> and <i>hwrite</i> stands for <i>huge</i>. Those two functions operated on so-called <i>huge pointers</i>, which is 16-bit jargon for pointers to memory blocks larger than 64KB. To increment your average 16:16 pointer by one byte, you increment the bottom 16 bits. But when the bottom 16 bits contain the value 0xFFFF, the increment rolls over, and where do you put the carry? If the pointer is a huge pointer, the convention is that the byte that comes after <code>S:0xFFFF</code> is <code>(S+__AHINCR):0x0000</code>, where <code>__AHINCR</code> is a special value exported by the Windows kernel. If you allocate memory larger than 64KB, the <code>GlobalAlloc</code> function breaks your allocation into 64KB chunks and arranges them so that incrementing the selector by <code>__AHINCR</code> takes you from one chunk to the next.
 Working backwards, then, the L prefix therefore stands for <i>long</i>. These functions explicitly accept far pointers, which makes them useful for 16-bit Windows programs since they are independent of the program’s memory model. Unlike the L-functions, the standard library functions like <code>strcpy</code> and <code>read</code> operate on pointers whose size match the data model. If you write your program in the so-called <i>medium memory model</i>, then all data pointers default to <i>near</i> (i.e., they are 16-bit offsets into the default data segment), and all the C runtime functions operate on near pointers. This is a problem if you need to, say, read some data off the disk into a block of memory you allocated with <code>GlobalAlloc</code>: That memory is expressible only as a far pointer, but the <i>read</i> function accepts a near pointer.
 To the rescue comes the <code>lread</code> function, which you can use to read from the disk into your far pointer.
 How did Windows decide which C runtime functions should have corresponding L-functions? <a href="http://blogs.msdn.com/oldnewthing/archive/2007/07/10/3799014.aspx"> They were the functions that Windows itself used internally</a>, and which were exported as a courtesy.
 Okay, now let’s go back to the Lame part. Michael Kaplan notes that the <code>lstrcmp</code> and <code>lstrcmpi</code> functions actually are sort-of counterparts to <code>strcoll</code> and <code>strcolli</code>. So why weren’t these functions called <code>lstrcoll</code> and <code>lstrcolli</code> instead?</p>
<p> Because back when <code>lstrcmp</code> and <code>lstrcmpi</code> were being named, the <code>strcoll</code> and <code>strcolli</code> functions hadn’t been invented yet! It’s like asking, “Why did the parents of General Sir Michael Jackson give him the same name as the pop singer?” or “<a href="http://blogs.msdn.com/b/oldnewthing/archive/2011/01/19/10117410.aspx">Why didn’t they use the Space Shuttle to rescue the Apollo 13 astronauts</a>?” </p>


</body>
<body style=max-width:80ch;margin:auto>
<h1 class="entry-title" style="margin-bottom:15px;">Eventually, nothing is special any more</h1>  <!-- .entry-meta -->

<p>Commenter ulric suggested that <a href="http://blogs.msdn.com/oldnewthing/archive/2007/07/27/4072156.aspx#4112818"> two functions for obtaining the “current” window should exist</a>, one for normal everyday use and one for “special use” when you want to interact with windows outside your process.</p>
<blockquote class="q"><p> I’d be more at ease however if the default behaviour of the API was to return HWND for the current process only, and the apps that really need HWND from other potentially other processes would have to be forced to use another API that is specifically just for that. </p></blockquote>
<p> This is an excellent example of <a href="http://blogs.msdn.com/oldnewthing/archive/2007/04/03/2014992.aspx#2035078"> suggesting something that Windows already does</a>. The special function has become so non-special, you don’t even realize any more that it’s special. </p>
<p> Originally, in 16-bit Windows, the function for getting the “current” window was <code>GetActiveWindow</code>. This obtained the active window across the entire system. One of the major changes in Win32 is the asynchronous input model, wherein windows from different input queues receive separate input. That way, one program that has stopped responding to input doesn’t clog up input for other unrelated windows. Win32 changed the meaning of <code>GetActiveWindow</code> to mean <i>the active window from the current input queue</i>. </p>
<p> In 16-bit Windows, there was only one input queue, the global one. In 32-bit Windows, each thread (or group of input-attached threads) gets its own input queue. </p>
<p> As a result of this finer granularity, when a program was ported from 16-bit Windows to 32-bit Windows, it didn’t “see” windows from other programs when it called functions like <code>GetFocus</code> or <code>GetActiveWindow</code>. <a href="https://channel9.msdn.com/Showpost.aspx?postid=116704"> As every Win32 programmer should know</a>, these states are local to your input queue. </p>
<p> Okay, let’s look at what we’ve got now. <code>GetFocus</code> and <code>GetActiveWindow</code> give you the status of your input queue. In other words, in a single-threaded program (which, if you’re coming from 16-bit Windows, is the only type of program there is), calling <code>GetActiveWindow</code> gives you the active window from your program. It doesn’t return the active window from another program.¹ Things are exactly as ulric suggested! </p>
<p> Now let’s look at the second half of the suggestion. If a program really needs to get a window from potentially other processes, it would have to use some other function that is specifically just for that. And indeed, that’s why the <code>GetForegroundWindow</code> function was added. The <code>GetForegroundWindow</code> function is <i>the special function specifically designed for obtaining windows from other processes</i>. </p>
<p> Therefore, we did exactly what ulric recommended, and it still turned into a mess. Why? </p>
<p> Because once you create something special, it doesn’t remain special for long. </p>
<p> It may take a while, but eventually people find that the regular function “doesn’t work” (for various definitions of “work”), and they ask around for help. “When I call <code>GetActiveWindow</code>, I’m not getting the global active window; I’m just getting the local one. How do I get the global one?” Actually, they probably don’t even formulate the question that clearly. It’s probably more like “I want to get the active window, but <code>GetActiveWindow</code> doesn’t work.” </p>
<p> And then somebody responds with “Yeah, <code>GetActiveWindow</code> doesn’t work. I’ve found that <code>GetForegroundWindow</code> works a lot better.” </p>
<p> The response is then “Wow, that works great! Thanks!” </p>
<p> Eventually, the word on the street is “<code>GetActiveWindow</code> doesn’t work. Use <code>GetForegroundWindow</code> instead.” Soon, people are using it for everything, waxing their car, calming a colicky baby, or improving their sexual attractiveness. </p>
<p> What used to be a function to be used “only in those rare occasions when you really need it” has become “the go-to function that gets the job done.” </p>
<p> In fact, the unfashionableness of the active window has reached the point that people have given up on calling it the active window at all! Instead, they call it <a href="http://blogs.msdn.com/oldnewthing/archive/2008/09/22/8960761.aspx#8961210"> the foreground window from the current process</a>. It’s like calling a land line a “wired cell phone”. </p>
<p> <a href="http://blogs.msdn.com/oldnewthing/archive/2007/07/27/4072156.aspx#4133892"> Requiring a new flag to get the special behavior</a> doesn’t change things at all. It’s the same story, just with different names for the characters. “<code>GetFocalWindow</code>² doesn’t work unless you pass the <code>GFW_CROSSPROCESS</code> flag.” Soon, everybody will be passing the <code>GFW_CROSSPROCESS</code> not because they understand what it does but just because “That’s what I was told to do” and “It doesn’t work if I don’t pass it.” </p>
<p> <b>Footnotes</b> </p>
<p> ¹Assuming you haven’t run around attaching your thread to some other program’s input queue. This is a pretty safe assumption since the <code>AttachThreadInput</code> function didn’t exist in 16-bit Windows either. </p>
<p> ²<code>GetFocalWindow</code> is an imaginary function created for the purpose of the example. </p>
<p> [Raymond is currently away; this message was pre-recorded.] </p>


</body>
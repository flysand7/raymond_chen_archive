<body style=max-width:80ch;margin:auto>
<h1 class="entry-title" style="margin-bottom:15px;">I know that an overlapped file handle requires an lpOverlapped, but why does it (sometimes) work if I omit it?</h1>  <!-- .entry-meta -->

<p>A customer observed that the <a href="http://msdn.microsoft.com/en-us/library/aa365467(VS.85).aspx"> formal requirements for the <code>Read­File</code> function</a> specify that if the handle was opened with <code>FILE_FLAG_OVERLAPPED</code>, then the <code>lpOverlapped</code> parameter is mandatory. But the customer observed that in practice, passing <code>NULL</code> results in strange behavior. Sometimes the call succeeds, and sometimes it even returns (horrors!) valid data. (Actually the more horrifying case is where the call succeeds and returns bogus data!)
 Now sure, you violated one of the requirements for the function, so the behavior is undefined. But why doesn’t <code>Read­File</code> just flat-out fail if you call it incorrectly?
 The answer is that the <code>Read­File</code> function doesn’t know whether you’re calling it correctly.
 The <code>Read­File</code> function doesn’t know whether the handle you passed was opened for overlapped or synchronous access. It just trusts that you’re calling it correctly and builds an asynchronous call to pass into the kernel. If you passed a synchronous handle, well, it just issues the I/O request into the kernel anyway, and you get what you get.
 This quirk traces its history all the way back to the <a href="http://www.americanhistory.si.edu/collections/object.cfm?key=35&amp;objkey=124"> <i>Microsoft Windows NT OS/2 Design Workbook</i></a>. As originally designed, Windows NT had a fully asynchronous kernel. There was no such thing as a blocking read. If you wanted a blocking read, you had to issue an asynchronous read (the only kind available), and then block on it.
 As it turns out, developers vastly prefer synchronous reads. Writing asynchronous code is hard. So the kernel folks relented and said, “Okay, we’ll have a way for you to specify at creation time whether you want a handle to be synchronous or asynchronous. And since lazy people prefer synchronous I/O, we’ll make synchronous I/O the default, so that lazy people can keep being lazy.”
 The <code>Read­File</code> function is a wrapper around the underlying <a href="http://msdn.microsoft.com/en-us/library/ff556706(VS.85).aspx"> <code>Nt­Read­File</code> function</a>. If you pass an <code>lpOverlapped</code>, then it takes the <code>OVERLAPPED</code> structure apart so it can pass the pieces as an <code>Io­Status­Block</code> and a <code>Byte­Offset</code>. (And if you don’t pass an <code>lpOverlapped</code>, then it needs to create temporary buffers on the stack.) All this translation takes place without the <code>Read­File</code> function actually knowing whether the handle you passed is asynchronous or synchronous; that information isn’t available to the <code>Read­File</code> function. It’s relying on you, the caller, to pass the parameters correctly.
 As it happens, the <code>Nt­Read­File</code> function does detect that you are trying to perform synchronous I/O on an asynchronous handle and fails with <code>STATUS_INVALID_PARAMETER</code> (which the <code>Read­File</code> function turns into <code>ERROR_INVALID_PARAMETER</code>), so you know that something went wrong.
 Unless you are a pipe or mailslot.
 For some reason, if you attempt to issue synchronous I/O on an asynchronous handle to a pipe or mailslot, the I/O subsystem says, “Sure, whatever.” I suspect this is somehow related to the <a href="http://blogs.msdn.com/b/oldnewthing/archive/2011/01/14/10115610.aspx"> confusing no-wait model for pipes</a>.</p>
<p> Long before this point, the <a href="http://blogs.msdn.com/b/oldnewthing/archive/2006/03/20/555511.aspx"> basic ground rules for programming</a> kicked in. “Pointers are not <code>NULL</code> unless explicitly permitted otherwise,” and the documentation clearly forbids passing <code>NULL</code> for asynchronous handles. The behavior that results from passing invalid parameters is undefined, so you shouldn’t be surprised that the results are erratic. </p>


</body>
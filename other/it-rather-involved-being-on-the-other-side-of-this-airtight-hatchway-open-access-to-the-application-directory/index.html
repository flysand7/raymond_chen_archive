<body style=max-width:80ch;margin:auto>
<h1 class="entry-title" style="margin-bottom:15px;">It rather involved being on the other side of this airtight hatchway: Open access to the application directory</h1>  <!-- .entry-meta -->

<p>A security vulnerability report arrived claiming that the Program X installer was insecure because it loaded a DLL (let’s call it <code>HAHA.DLL</code>) from the current directory, thereby being susceptible to a <a href="/other/using-delayload-to-detect-functionality-is-a-security-vulnerability" title="Using delayload to detect functionality is a security vulnerability"> current directory attack</a>. (Other terms for this type of attack are <i>DLL planting</i> and <i>DLL side-loading</i>.)</p>
<p>The vendors who were responsible for Program X forwarded the report to Microsoft because their program never loaded <code>HAHA.DLL</code> directly; it was being loaded by a system component.</p>
<p>The first order of business was to verify that it was actually a DLL planting vulnerability. And it wasn’t. It was an application directory attack, not a current directory attack. It turns out that a lot of purported DLL planting vulnerability reports are actually application directory attacks. DLLs in the application directory take priority over system DLLs because <a href="https://devblogs.microsoft.com/oldnewthing/20110620-00/?p=10393" title="In Windows, the directory is the application bundle"> the directory is the Windows equivalent of what on the Mac is called an application bundle</a>.¹ Which only serves to highlight the importance of <a href="https://devblogs.microsoft.com/oldnewthing/20121031-00/?p=6203" title="The TEMP directory is like a public hot tub whose water hasn't been changed in over a year"> securing your application directory</a>.</p>
<p>In the original report, Program X was in a directory called something like <code>\\server\<wbr/>software\<wbr/>install</code>, which was filled with setup programs for various applications. As a result, all of the programs were <a href="http://blogs.msdn.com/b/oldnewthing/archive/2012/10/31/10364271.aspx"> soaking in the same hot-tub</a>.</p>
<p>When this issue was pointed out to the vendors of Program X, they responded, “No, this is still a bug. You need to add <code>HAHA.DLL</code> to the KnownDlls list so that it cannot be overridden by the application directory.”</p>
<p>The KnownDlls list is <a> not a security feature</a>. It is a <i>performance</i> feature. The fact that KnownDlls overrides the application directory is a side-effect of its implementation (namely, to avoid directory searching for popular DLLs), and it is arguably a bug, since it breaks contractual behavior: The application directory no longer takes precedence over the system directory. The Application Compatibility folks spend a lot of time studying the KnownDlls list to make sure that the DLLs in there are ones that no properly-functioning application should be trying to override with a local copy.</p>
<p>Even if <code>HAHA.DLL</code> were added to the KnownDlls list, that does not guarantee that it will always be loaded from the system directory. If somebody can attack your application directory, then they can drop a DLL redirection manifest into the directory or use DotLocal DLL redirection, both of which also override KnownDlls. (Observe that both of these attacks require write access to the application directory.)</p>
<p>The application directory is your safety bubble. If you let anybody into your safety bubble, then it isn’t very safe any more.</p>
<p>In the parlance of airtight hatchways: Granting open write access to your application directory is equivalent to leaving open the door to your airtight hatchway.</p>
<p>¹ I used to say simply “The directory is the application bundle”, but I’m now forced to use the much more awkward formulation because at least one person <a> thought I was talking about Windows Store application bundles</a>.</p>


</body>
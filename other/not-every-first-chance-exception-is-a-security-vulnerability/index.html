<body style=max-width:80ch;margin:auto>
<h1 class="entry-title" style="margin-bottom:15px;">Not every first-chance exception is a security vulnerability</h1>  <!-- .entry-meta -->

<p>In the category of dubious vulnerability, I submit the following (paraphrased) report:</p>
<blockquote class="q"><p> If I call the <code>FormatMessage</code> function, I can cause a buffer overflow exception if I provide an insertion that is more than 2000 characters long. </p></blockquote>
<p> The <code>FormatMessage</code> function in Windows NT, 2000 and XP used the <a href="http://msdn.microsoft.com/library/en-us/memory/base/reserving_and_committing_memory.asp"> dynamically expanding buffer technique</a> to allocate memory for the resulting message. If the resulting string was more than one page in length (4KB on an x86 system), there was an exception thrown when the <code>FormatMessage</code> function tried to write to the 4096th byte of the buffer. This looks like a buffer overflow, and in a sense it is, but it’s a controlled overflow (the bytes beyond the end of the buffer are under the program’s control), the exception is entirely expected, and it is correctly handled.
 Using intentionally invalid pages to trigger just-in-time memory commit is a rare technique, so it’s not surprising that people aren’t familiar with it. In fact, to avoid these sorts of false alarm security vulnerability reports, the kernel folks rewrote the <code>FormatMessage</code> function in Windows Vista so it doesn’t use this technique any more.
 It’s an odd Catch-22. You remove something that is frequently mistaken for a security vulnerability so that people stop mistakenly reporting it, but the fact that you remove it only confirms in the mind of the people who filed the false alarms that they found something for real!</p>
<p> (For further reading, may I recommend <a href="http://blogs.msdn.com/larryosterman/archive/2006/10/16/so-when-is-it-ok-to-use-seh.aspx"> this blog entry from Larry Osterman</a>.) </p>


</body>
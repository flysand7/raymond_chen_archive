<body style=max-width:80ch;margin:auto>
<h1 class="entry-title" style="margin-bottom:15px;">What happens when you get dllimport wrong?</h1>  <!-- .entry-meta -->

<p>Now that we’ve learned what the <code>dllimport</code> declaration specifier does, what if you get it wrong?
 If you forget to declare a function as <code>dllimport</code>, then you’re basically making the compiler act like a naive compiler that doesn’t understand <code>dllimport</code>. When the linker goes to resolve the external reference for the function, it will use the stub from the import library, and everything will work as before. You do miss out on the optimization that <code>dllimport</code> enables, but the code will still run. You’re just running in naive mode.
 (There are still some header files in the Platform SDK that neglect to use the <code>dllimport</code> declaration specifier. As a result, anybody who uses those header files to import functions from the corresponding DLL will be operating in “naive mode”. Hopefully the people responsible for those header files will recognize themselves in this parenthetical and fix the problem for a future release of the Platform SDK.)
 Now, what about the reverse problem? What if you declare a function as <code>dllimport</code> when it really isn’t? The linker detects this since it sees an attempt to import a <code>__imp__FunctionName</code> symbol and can’t find one, though it can find the normal <code>FunctionName</code> symbol. When this happens, the linker raises <a href="http://msdn.microsoft.com/library/en-us/vccore/html/vcerrLinkerToolsWarningLNK4217.asp"> warning LNK4217</a>. It recovers from this error by simply manufacturing a fake <code>__imp__FunctionName</code> variable and initializing it with the address of the <code>FunctionName</code> function. In effect, you’ve imported the function from yourself. Your code now goes through all the gyrations associated with calling an imported function unnecessarily; it could have just called <code>FunctionName</code> directly.
 (There are cases where the linker can be a little smarter. For example, if it sees a <code>call [__imp__FunctionName]</code>, it can change it to <code>call FunctionName + nop</code>. The <code>nop</code> is necessary because the <code>call [__imp__FunctionName]</code> instruction is six bytes long, whereas <code>call FunctionName</code> is only five. The extra <code>nop</code> gets everything back in sync.)
 Thus, in both cases where you mess up the <code>dllimport</code> declaration specifier, the linker manages to recover from your mistake, and your program does run fine, though the patching up did cost you in code size and efficiency.
 (All this discussion is for x86, by the way. Other architectures have different quirks.)</p>
<p> Next time, more on import libraries, and exposing some “little white lies” I’ve been telling. </p>


</body>
<body style=max-width:80ch;margin:auto>
<h1 class="entry-title" style="margin-bottom:15px;">Precision is not the same as accuracy</h1>  <!-- .entry-meta -->

<p>Accuracy is how close you are to the correct answer; precision is how much resolution you have for that answer.</p>
<p> Suppose you ask me, “What time is it?” </p>
<p> I look up at the sun, consider for a moment, and reply, “It is 10:35am and 22.131 seconds.” </p>
<p> I gave you a very precise answer, but not a very accurate one. </p>
<p> Meanwhile, you look at your watch, one of those fashionable watches with notches only at 3, 6, 9 and 12.  You furrow your brow briefly and decide, “It is around 10:05.” Your answer is more accurate than mine, though less precise. </p>
<p> Now let’s apply that distinction to some of the time-related functions in Windows. </p>
<p> <a href="http://msdn.microsoft.com/en-us/library/ms724408.aspx"> The <code>GetTickCount</code> function</a> has a precision of one millisecond, but its accuracy is typically much worse, dependent on your timer tick rate, typically 10ms to <a href="http://blogs.msdn.com/oldnewthing/archive/2004/12/02/273721.aspx"> 55ms</a>. <a href="http://msdn.microsoft.com/en-us/library/ms724397.aspx"> The <code>GetSystemTimeAsFileTime</code> function</a> looks even more impressive with its 100-nanosecond precision, but its accuracy is not necessarily any better than that of <code>GetTickCount</code>. </p>
<p> If you’re looking for high accuracy, then you’d be better off playing around with <a href="http://msdn.microsoft.com/en-us/library/ms644904(VS.85).aspx"> the <code>QueryPerformanceCounter</code> function</a>. You have to make some tradeoffs, however. For one, the precision of the result is variable; you need to call <a href="http://msdn.microsoft.com/en-us/library/ms644905.aspx"> the <code>QueryPerformanceFrequency</code> function</a> to see what the precision is. Another tradeoff is that the higher accuracy of <code>QueryPerformanceCounter</code> can be slower to obtain. </p>
<p> What <code>QueryPerformanceCounter</code> actually does is up to the HAL (with some help from ACPI). The performance folks tell me that, in the worst case, you might get it from the rollover interrupt on the programmable interrupt timer. This in turn may require a PCI transaction, which is not exactly the fastest thing in the world. It’s better than <code>GetTickCount</code>, but it’s not going to win any speed contests. In the best case, the HAL may conclude that the RDTSC counter runs at a constant frequency, so it uses that instead. Things are particularly exciting on multiprocessor machines, where you also have to make sure that the values returned from RDTSC on each processor are consistent with each other! And then, for good measure, throw in a handful of workarounds for known buggy hardware. </p>


</body>
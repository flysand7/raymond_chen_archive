<body style=max-width:80ch;margin:auto>
<h1 class="entry-title" style="margin-bottom:15px;">Using delayload to detect functionality is a security vulnerability</h1>  <!-- .entry-meta -->

<p><a href="http://blogs.msdn.com/b/oldnewthing/archive/2010/11/10/10088566.aspx"> We saw last time</a> that your debugging code can be a security vulnerability when you don’t control the current directory. A corollary to this is that your delayload code can also be a security vulnerability, for the same reason.
 When you use <a href="http://msdn.microsoft.com/en-us/library/151kt790.aspx"> the linker’s delayload functionality</a> to defer loading a DLL until the first time it is called, the linker injects code which calls <code>LoadLibrary</code> on a DLL the first time you call a function in it, and then calls <code>GetProcAddress</code> on the functions you requested. When you call a delay-loaded function and the delayload code did not get a function pointer from <code>GetProcAddress</code> (either because the DLL got loaded but the function does not exist, or because the DLL never got loaded in the first place), it raises a special exception indicating that a delayed load failed.
 Let’s look again at the order in which the <code>LoadLibrary</code> function searches for a library:</p>
<ol>
<li>The directory containing the application EXE. </li>
<li>The system32 directory. </li>
<li>The system directory. </li>
<li>The Windows directory. </li>
<li>The current directory. </li>
<li>The PATH. </li>
</ol>
<p> The code which implements the delayload functionality uses a relative path when it passes the library name to <code>LoadLibrary</code>. (It has no choice since all it has to work with is the library name stored in the IMPLIB.) Consequently, if the DLL you are delay-loading does not exist in any of the first four search locations, the <code>LoadLibrary</code> will look in location 5: the current directory.
 At this point, the current directory attack becomes active, and a bad guy can inject an attack DLL into your process.
 For example, <a href="http://blogs.msdn.com/larryosterman/archive/2009/03/06/delay-load-is-not-a-good-way-to-check-for-functionality.aspx"> this sample code</a> uses delayload to detect whether the functions in <code>dwmapi.dll</code> exist, calling them if so. If the function <code>IsThemeEnabled</code> is not available, then it treats themes as not enabled. If the program runs on a system without <code>dwmapi.dll</code>, then the delayload will throw an exception, and the exception is caught and turned into a failure. Disaster avoided.
 But in fact, the disaster was not avoided; it was <i>introduced</i>. If you run the program on a system without <code>dwmapi.dll</code>, then a bad guy can put a rogue copy of <code>dwmapi.dll</code> into the current directory, and <i>boom</i> your process just loaded an untrusted DLL. Game over.
 Using the delayload feature to probe for a DLL is morally equivalent to using a plain <code>LoadLibrary</code> to probe for the presence of a debugging DLL. In both cases, you are looking for a DLL with the expectation that there’s a good chance it won’t be there. But it is exactly in those <i>sometimes it won’t be there</i> cases where you become vulnerable to attack.
 If you want to probe for the existence of a DLL, then you need to know what directory the DLL <i>should</i> be in, and then load that DLL via that full path in order to avoid the current directory attack.
 On the other hand, if the DLL you want to delayload is known to be installed in a directory ahead of the current directory in the search path (for example, you require versions of the the operating system in which the DLL is part of the mandatory install, and the directory in which it is installed is the System32 directory) then you can use delayload.
 In other words, you can use delayload for delaying the load of a DLL. But if you’re using delayload to probe for a DLL’s existence, then you become vulnerable to a current directory attack.</p>
<p> This is one of those subtle unintended consequences of changing the list of files included with an operating system. If you take what used to be a mandatory component that can’t be uninstalled, and you change it to an optional component that can be uninstalled, then not only do programs which <a href="http://blogs.msdn.com/oldnewthing/archive/2003/09/16/54938.aspx"> linked to the DLL in the traditional manner stop loading</a>, but you’ve also <i>introduced a security vulnerability</i>: Programs which had used delayload under the calculation (correct at the time it was made) that doing so was safe are now vulnerable to the current directory attack. </p>


</body>
<body style=max-width:80ch;margin:auto>
<h1 class="entry-title" style="margin-bottom:15px;">QueryPerformanceCounter counts elapsed time, not CPU cycles</h1>  <!-- .entry-meta -->

<p>An anonymous coward asks <a href="http://blogs.msdn.com/oldnewthing/archive/2005/09/02/459952.aspx#460003"> whether the <code>QueryPerformanceCounter</code> function counts elapsed time or CPU cycles</a>.</p>
<p> It counts elapsed time. It has to, since its value is governed by the <code>QueryPerformanceFrequency</code> function, which returns a number specifying the number of units per second, and the frequency is spec’d as not changing while the system is running. </p>
<p> For CPUs that can run at variable speed, this means that the HAL cannot use an instruction like <code>RDTSC</code>, since that does not correlate with elapsed time. Commenter “A” <a href="http://blogs.msdn.com/oldnewthing/archive/2005/09/02/459952.aspx#461315"> appears to have found a buggy HAL that failed to take this into account</a> and returns values that do not correlate with elapsed time. </p>
<p> What would it take to create a counter that was tied to CPU cycles? Well, first, you’d have to come up with some definition of “CPU cycles” that is architecture-neutral. Maybe you’d say that it’s a 64-bit value that increments at a rate proportional to the amount of work the CPU has done. And then you have to come up with some sort of definition of what should happen on multi-processor machines. What if you have two CPUs, one of which has gone into a <code>HLT</code> state (not running), while the other is busy doing work? Should the “cycle counter” run at half speed, since only half of the CPUs are running at full speed? What about hyperthreaded processors? It’s all so confusing. </p>
<p> As a final remark, commenter Ulric wanted to know <a href="http://blogs.msdn.com/oldnewthing/archive/2005/09/02/459952.aspx#461129"> what I meant when I wrote, “Throw in a handful of workarounds for known buggy hardware.”</a> What I meant was that the people who write HALs are aware of various types of buggy hardware and added code to detect that buggy hardware and work around the problems. </p>


</body>
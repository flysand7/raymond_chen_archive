<body style=max-width:80ch;margin:auto>
<h1 class="entry-title" style="margin-bottom:15px;">The case of the buffer overflow vulnerability that was neither a buffer overflow nor a vulnerability</h1>  <!-- .entry-meta -->

<p>A security vulnerability report claimed to have found a buffer overrun. Their instructions were to perform a specific sequence of operations in Explorer while watching the output in the debugger:</p>

<p>Oh, I forgot to mention that the finder didn’t copy the text out of the debugger. Nor did they attach a screen shot of the debugger. Nope, they attached a digital photo of their CRT monitor, complete with <a href="http://en.wikipedia.org/wiki/Moir%C3%A9_pattern"> Moiré pattern</a>.</p>
<p>I’ll remove the Moiré pattern for you from this and all the other screen shots. I’ll also do the organic OCR¹ and convert it to text. Because I’m a nice guy that wants his writing to be readable. (Unlike the finder, apparently.)</p>

<p>Okay, this is some debug spew that’s logging a <i>File not found</i> error.</p>
<p>The finder, however, didn’t characterize it as debug spew, but rather described it as “an exception”. Their next step was to set a breakpoint on the reported address <code>00007FF813D017E2</code> and repeat the scenario, and then when the breakpoint hits, take a stack trace.</p>
<pre>0:002&gt; k
 # Child-SP
00 0000009c`aa2ffae0 00007ff8`13cb690c explorer!&lt;lambda_bab32d760b0e6e31&gt;::operator()+0x704c2
01 0000009c`aa2ffb90 00007ff8`13cb5eed explorer!Windows::Internal::ComTaskPool::CThread::_ThreadProc+0x228
02 0000009c`aa2ffc80 00007ff8`13cb5e39 explorer!Windows::Internal::ComTaskPool::CThread::s_ExecuteThreadPr
03 0000009c`aa2ffcd0 00007ff8`91adc774 explorer!Windows::Internal::ComTaskPool::CThread::s_ThreadProc+0x9
04 0000009c`aa2ffd00 00007ff8`91defd51 kernel32!BaseThreadInitThunk+0x14
05 0000009c`aa2ffd30 00000000`00000000 ntdll!RtlUserThreadStart+0x21
</pre>
<p>A little disassembling around the first return address reveals</p>
<pre>00007ff8`13cb6906 ff1557351100 call    qword ptr [explorer!_guard_dispatch_icall_ptr (00007ff8`3cbfe08)]
00007ff8`13cb690c 488b4b50     mov     rcx, qword ptr [rbx+50h]
</pre>
<p>The finder explained that “the function is <code>_guard_</code><code>dispatch_</code><code>icall_</code><code>fptr</code>, not the <code>lambda_</code><code>bab32d...</code>. Decompiling the code at <code>_guard_</code><code>dispatch_</code><code>icall_</code><code>fptr</code>, you’ll see the buffer overflow.” Here’s the code in question:</p>
<pre>0:002&gt; u 00007ff8`13cbfe08
explorer!_guard_dispatch_icall_fptr:
00007ff8`13cbfe08 206388     and     byte ptr [rbx-78h],ah
00007ff8`13cb6e0b 9a         <span style="border: solid 1px black;">???</span> ⇐
</pre>
<p>In the screen shot, they highlighted the second line. And that was the end of their report.</p>
<p>It seems that the finder saw a debug message, and then started fumbling around. They saw that the disassembler printed <code>???</code> which they interpreted as a clear sign of a security vulnerability.</p>
<p>But that’s not what they found.</p>
<p>First of all, the messages that appear on the debugger are some error logging trace messages. They aren’t exceptions.</p>
<p>Next, the instruction prior to the return address is an indirect call, but they somehow thought this was a label, because they said that the function was misreported by the debugger as <code>lambda_</code><code>bab32d...</code> when it was actually <code>_guard_</code><code>dispatch_</code><code>icall_</code><code>fptr</code>. Nope, the function really is <code>lambda_</code><code>bab32d...</code>. What it’s doing is <i>calling through</i> the function pointer <code>_guard_</code><code>dispatch_</code><code>icall_</code><code>fptr</code>.</p>
<p>Next, the finder misread the disassembly. In Intel notation, square brackets around an effective address mean “the memory stored at this address”. The <code>call qword ptr [_guard_</code><code>dispatch_</code><code>icall_</code><code>fptr]</code> doesn’t mean “call the function <code>_guard_</code><code>dispatch_</code><code>icall_</code><code>fptr</code>.” It means “read eight bytes from <code>_guard_</code><code>dispatch_</code><code>icall_</code><code>fptr</code>, treat those eight bytes as a 64-bit value, interpret that value as an address, and call to that address.” The bytes you see at <code>_guard_</code><code>dispatch_</code><code>icall_</code><code>fptr</code> are not code; they are data. Disassembling them as code is meaningless.</p>
<p>So +1 on the finder for resourcefulness and curiosity. But −1 for not really understanding what you are doing, −1 for not checking your work with a colleague before sending it in, and −1 for poor presentation.</p>
<p>¹ In other words, I used my eyeballs.</p>


</body>
<body style=max-width:80ch;margin:auto>
<h1 class="entry-title" style="margin-bottom:15px;">Non-capturing C++ lambdas can be converted to a pointer to function, but what about the calling convention?</h1>  <!-- .entry-meta -->

<p>First, let’s look at how lambdas are implemented in C++. </p>
<p>It is similar in flavor to <a href="http://blogs.msdn.com/b/oldnewthing/archive/2006/08/02/686456.aspx">the way lambdas are implemented in C#</a>, but the details are all different. </p>
<p>When the C++ compiler encounters a lambda expression, it generates a new anonymous class. Each captured variable becomes a member of that anonymous class, and the member is initialized from the variable in the outer scope. Finally, the anonymous class is given an <code>operator()</code> implementation whose parameter list is the parameter list of the lambda, whose body is the lambda body, and whose return value is the lambda return value. </p>
<p>I am simplifying here. You can read the C++ language specification for gory details. The purpose of this discussion is just to give a conceptual model for how lambdas work so we can get to answering the question. The language also provides for syntactic sugar to infer the lambda return type and capture variables implicitly. Let’s assume all the sugar has been applied so that everything is explicit. </p>
<p>Here’s a basic example: </p>
<pre>
void ContainingClass::SomeMethod()
{
 int i = 0, j = 1;
 auto f = [this, i, &amp;j](int k) -&gt; int
    { return this-&gt;calc(i + j + k); };
 ...
}
</pre>
<p>The compiler internally converts this to something like this: </p>
<pre>
void ContainingClass::SomeMethod()
{
 int i = 0, j = 1;

 // Autogenerated by the compiler
 <font color="blue">class AnonymousClass$0
 {
 public:
  AnonymousClass$0(ContainingClass* this$, int i$, int&amp; j$) :
   this$0(this$), i$0(i$), j$0(j$) { }
  int operator</font>(int k) <font color="blue">const</font>
     { return this$0-&gt;calc(i$0 + j$0 + k); }
 <font color="blue">private:
  ContainingClass* this$0; // this captured by value
  int i$0;                 // i captured by value
  int&amp; j$0;                // j captured by reference
 };</font>

 auto f = <font color="blue">AnonymousClass$0</font>(this, i, j);
 ...
}
</pre>
<p>We are closer to answering the original question. but we’re not there yet. </p>
<p>As a special bonus: If there are no captured variables, then there is an additional conversion operator that can convert the lambda to a pointer to a nonmember function. This is possible only in the case of no captured variables because captured variables would require an <code>AnonymousClass$0</code> instance parameter, but there is nowhere to pass it. </p>
<p>Here’s a lambda with no captured variables. </p>
<pre>
void ContainingClass::SomeMethod()
{
 auto f = [](int k) -&gt; int { return calc(k + 42); };
 ...
}
</pre>
<p>The above code gets transformed to </p>
<pre>
void ContainingClass::SomeMethod()
{
 class AnonymousClass$0
 {
 public:
  AnonymousClass$0()  { }
  <font color="blue">operator int (*)(int k) { return static_function; }</font>
  int operator(int k) <font color="blue">const</font> { return calc(k + 42); }
 private:
  static int static_function(int k) { return calc(k + 42); }
 };

 auto f = AnonymousClass$0();
 ...
}
</pre>
<p>Okay, now we can get to the actual question: How can I specify <a href="http://blogs.msdn.com/b/oldnewthing/archive/2014/01/27/10492898.aspx#10493271">the calling convention for this implicit conversion to a pointer to nonmember function</a>? </p>
<p>(Note that calling conventions are not part of the C++ standard, so this question is necessarily a platform-specific question.) </p>
<p>The Visual C++ compiler automatically <a href="http://blogs.msdn.com/b/vcblog/archive/2011/09/12/10209291.aspx">provides conversions for every calling convention</a>. So with Visual C++, the transformed code actually looks like this: </p>
<pre>
void ContainingClass::SomeMethod()
{
 class AnonymousClass$0
 {
 public:
  AnonymousClass$0()  { }
  <font color="blue">operator int (__cdecl *)(int k) { return cdecl_static_function; }
  operator int (__stdcall *)(int k) { return stdcall_static_function; }
  operator int (__fastcall *)(int k) { return fastcall_static_function; }</font>
  int operator(int k) { return cdecl_static_function(k); }
 private:
  static int __cdecl cdecl_static_function(int k) { return calc(k + 42); }
  static int __stdcall stdcall_static_function(int k) { return calc(k + 42); }
  static int __fastcall fastcall_static_function(int k) { return calc(k + 42); }
 };

 auto f = AnonymousClass$0();
 ...
}
</pre>
<p>In other words, the compiler creates all the conversions, just in case. (The versions you don’t use will be removed by the linker.) </p>
<p>But only for noncapturing lambdas. </p>


</body>
<body style=max-width:80ch;margin:auto>
<h1 class="entry-title" style="margin-bottom:15px;">The C runtime library cannot be mixed and matched</h1>  <!-- .entry-meta -->

<p>In 2011, a customer had an application written in C++ with Visual Studio 2003 that consumes a static library provided by a third party, let’s call it <code>contoso.lib</code>. Now, <code>contoso.lib</code> is a static library <a href="http://blogs.msdn.com/b/oldnewthing/archive/2010/06/07/10020654.aspx">compiled with Visual C++ 6</a>. The customer is migrating from Visual Studio 2003 to Visual Studio 2008, but they are still using that old <code>contoso.lib</code> library that was compiled with Visual C++ 6. They were afraid that they would encounter some unresolved externals due to name mangling issues, but they were pleasantly surprised when there were no such issues. </p>
<p>Now the questions. </p>
<ol>
<li>Is it correct to link a VC6 static library into a VS2008 project? 
<li>Even if the linking is successful,     do you see any issues or disadvantages with this approach? </li></li></ol>
<p>The customer liaison’s opinion was “Due to missing security features like <a href="http://msdn.microsoft.com/en-us/library/9a89h429.aspx"><code>SAFESEH</code></a>, <a href="http://msdn.microsoft.com/en-us/library/8dbf701c.aspx"><code>GS</code></a>, <a href="http://msdn.microsoft.com/en-us/library/bb384887.aspx"><code>DYNAMICBASE</code></a>, and <a href="http://msdn.microsoft.com/en-us/library/ms235442.aspx"><code>NXCOMPAT</code></a>, there may be a lot of drawbacks to using VC6 libraries in a VS2008 project. What do you think?” </p>
<p>It’s nice that you’re thinking about the security features added in recent versions of Visual Studio, using a generous definition of <i>recent</i> to mean <i>less than nine years old</i>. But the issue is more fundamental than just security. The issue is correctness. </p>
<p>You cannot mix libraries across compiler versions. That you’re trying to mix libraries with compiler versions that are <i>nineteen years apart in age</i> is mind-boggling. The Win32 ABI does not extend into compiler-specific behavior, like its internal lookup tables for exception dispatching, private helper functions for RTTI, <a href="http://randomascii.wordpress.com/2013/12/01/vc-2013-class-layout-change-and-wasted-space/">class member layout</a>, <a href="http://blogs.msdn.com/b/oldnewthing/archive/2003/12/23/45481.aspx">the order of base classes</a>, <a href="http://blogs.msdn.com/b/vcblog/archive/2014/06/06/c-14-stl-features-fixes-and-breaking-changes-in-visual-studio-14-ctp1.aspx">the implementations of STL classes</a>, the <a href="http://blogs.msdn.com/b/oldnewthing/archive/2014/04/11/10516280.aspx">layout of various internal structures</a>, or <a href="http://blogs.msdn.com/b/oldnewthing/archive/2008/08/08/8841951.aspx">what happens if you return <code>FALSE</code> from <code>Dll­Main</code></a>. </p>
<p>Name mangling will not catch any of these issues. If you modify a class, say by adding a new member variable or base class, the mangled name does not change, even though the new class is probably incompatible with the old one. </p>
<p>Assuming you manage to dodge all the link errors, what will happen is that these discrepancies will manifest themselves as random failures or memory corruption <i>at run time</i>. </p>
<p>You will have to go back to Contoso and ask them for a version of the library that is compatible with Visual Studio 2008. </p>
<p>(Then again, since this question was asked in 2011, they may want to go straight to Visual Studio 2010, which was the most recent version of Visual Studio available at the time.) </p>
<p><b>Bonus chatter</b>: Another solution is to create a project in Visual Studio 2003 whose sole job is to wrap the static library in a DLL. The rest of your program can be developed in Visual Studio 2008, using the DLL interface to access the static library. </p>


</body>
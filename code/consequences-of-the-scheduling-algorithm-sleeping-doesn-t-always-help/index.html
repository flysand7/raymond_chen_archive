<body style=max-width:80ch;margin:auto>
<h1 class="entry-title" style="margin-bottom:15px;">Consequences of the scheduling algorithm: Sleeping doesn’t always help</h1>  <!-- .entry-meta -->

<p>More often I see the reverse of the “Low priority threads can run even when higher priority threads are running” problem. Namely, people who <a href="http://groups.google.com/group/comp.os.ms-windows.programmer.win32/browse_frm/thread/006ffcdccd0fdda3/269e9a1dc4e371d7#269e9a1dc4e371d7"> think that <code>Sleep(0)</code> is a clean way to yield CPU</a>. For example, they might have run out of things to do and merely wish to wait for another thread to produce some work.</p>
<p> Recall that the scheduler looks for the highest priority runnable thread, and if there is a tie, all the candidates share CPU roughly equally. A thread can call <code>Sleep(0)</code> to relinquish its quantum, thereby reducing its share of the CPU. Note, however, that this does not guarantee that other threads will run. </p>
<p> If there is a unique runnable thread with the highest priority, it can call <code>Sleep(0)</code> until the cows come home, and it will nevertheless not relinquish CPU. That’s because sleeping for zero milliseconds release the quantum but leaves the thread runnable. And since it is the only runnable thread with the highest priority, it immediately gets the CPU back. Sleeping for zero milliseconds is like going to back of the line. If there’s nobody else in line, you didn’t actually yield to anyone! </p>
<p> Therefore, if you use <code>Sleep(0)</code> as an ineffective yield, you will never allow lower priority threads to run. This means that various background activities (such as indexing) never get anywhere since your program is hogging all the CPU. What’s more, the fact that your program never actually releases the CPU means that the computer will never go into a low-power state. Laptops will drain their batteries faster and run hotter. Terminal Servers will spin their CPU endlessly. </p>
<p> The best thing to do is to wait on a proper synchronization object so that your thread goes to sleep until there is work to do. If you can’t do that for some reason, at least sleep for a nonzero amount of time. That way, for that brief moment, your thread is not runnable and other threads—including lower-priority threads—get a chance to run. (This will also reduce power consumption somewhat, though not as much as waiting on a proper synchronization object.) </p>


</body>
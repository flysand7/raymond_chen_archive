<body style=max-width:80ch;margin:auto>
<h1 class="entry-title" style="margin-bottom:15px;">How does delay-loading use binding information?</h1>  <!-- .entry-meta -->

<p>In the documentation for delay-loading, there’s a remark that says that  <a href="http://msdn.microsoft.com/en-us/library/hdx9xk46.aspx"> the call to <code>GetProcAddress</code> can be avoided if there is binding information</a>. A customer who received the explanation of <a href="http://blogs.msdn.com/oldnewthing/archive/2010/02/01/9956102.aspx"> why you can’t delay-load <code>kernel32</code></a> pointed out that paragraph and asked whether this means that you can delay-load <code>kernel32</code> if you bind to it. (Getting around to answering this question was the point of <a href="http://blogs.msdn.com/oldnewthing/archive/2010/03/17/9980011.aspx"> the past</a> <a href="http://blogs.msdn.com/oldnewthing/archive/2010/03/18/9980802.aspx"> few days</a>.)
 Let’s take another look at what that <code>GetProcAddress</code>-avoidance optimization does. Actually, it’s just another look at what the module loader does when it’s time to resolve imports to a bound DLL: At build time, the actual function pointers are precomputed and cached, along with the timestamp of the DLL those precomputed values came from. At run time, the delay-load stubs check the timestamp of the target DLL and compare it against the timestamp that it had cached. If they are the same, then they skip the call to <code>GetProcAddress</code> and use the cached value.
 In other words, the delay-load stubs use binding information in exactly the same way the module loader does.
 Does this mean that you can now delay-load <code>kernel32</code>?
 No. First of all, if the timestamps don’t match or if the target DLL was not loaded at its preferred address, then the binding information is of no use—you have a cache miss. In that case, the module loader (and the delay-load stubs) must obtain the function pointers the old-fashioned way. You can’t assume that your binding information will always be accurate. (For example, after your module was bound to <code>kernel32</code>, there may have been a security update which modified <code>kernel32</code>, which invalidates your binding information.)</p>
<p> And besides, even if the binding information were used, you still have to call <code>LoadLibrary</code> to get the target DLL loaded in the first place. Even though binding may have optimized away one call to <code>kernel32</code>, you still have that <code>LoadLibrary</code> to deal with. </p>


</body>
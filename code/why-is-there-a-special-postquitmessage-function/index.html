<body style=max-width:80ch;margin:auto>
<h1 class="entry-title" style="margin-bottom:15px;">Why is there a special PostQuitMessage function?</h1>  <!-- .entry-meta -->

<p>Why is there a special PostQuitMessage function? Because it’s not really a posted message.</p>
<p> Commenter A. Skrobov asked, “<a href="http://blogs.msdn.com/oldnewthing/archive/2005/02/22/378018.aspx#378042">What’s the difference</a> between <code> <a href="http://msdn.microsoft.com/library/en-us/winui/winui/windowsuserinterface/windowing/messagesandmessagequeues/messagesandmessagequeuesreference/messagesandmessagequeuesfunctions/postquitmessage.asp"> PostQuitMessage</a></code> and <code> <a href="http://msdn.microsoft.com/library/en-us/winui/winui/windowsuserinterface/windowing/messagesandmessagequeues/messagesandmessagequeuesreference/messagesandmessagequeuesfunctions/postthreadmessage.asp"> PostThreadMessage</a>(GetCurrentThreadId, WM_QUIT)</code>?” </p>
<p> They are not equivalent, though they may look that way at first glance. The differences are subtle but significant. </p>
<p> Like the <code>WM_PAINT</code>, <code>WM_MOUSEMOVE</code>, and <code>WM_TIMER</code> messages, the <code>WM_QUIT</code> message is not a “real” posted message. Rather, it is one of those messages that the system generates <strong>as if</strong> it were posted, even though it wasn’t. And like the other messages, the <code>WM_QUIT</code> message is a “low priority” message, generated only when the message queue is otherwise empty. </p>
<p> When a thread calls <code>PostQuitMessage</code>, a flag in the queue state is set that says, “If somebody asks for a message and there are no posted messages, then manufacture a <code>WM_QUIT</code> message.” This is just like the other “virtually posted” messages. <code>WM_PAINT</code> messages are generated on demand if there are any invalid regions, <a href="http://blogs.msdn.com/oldnewthing/archive/2003/10/01/55108.aspx"> <code>WM_MOUSEMOVE</code> messages are generated on demand if the mouse has moved since the last time you checked</a>, and <code>WM_TIMER</code> messages are generated on demand if there are any due timers. And since the message is “virtually posted”, multiple calls coalesce, in the same way that multiple paint messages, multiple mouse motions, and multiple timer messages also coalesce. </p>
<p> Why is <code>WM_QUIT</code> handled like a low-priority message? </p>
<p> Because the system tries not to inject a <code>WM_QUIT</code> message at a “bad time”; instead it waits for things to “settle down” before generating the <code>WM_QUIT</code> message, thereby reducing the chances that the program might be in the middle of a multi-step procedure triggered by a sequence of posted messages. </p>
<p> If you <code>PeekMessage(..., PM_NOREMOVE)</code> a <code>WM_QUIT</code> message, this returns a <code>WM_QUIT</code> message but does not clear the flag. The <code>WM_QUIT</code> message virtually “stays in the queue”. </p>
<p> As another special behavior, the generated <code>WM_QUIT</code> message bypasses the message filters passed to the <code>GetMessage</code> and <code>PeekMessage</code> functions. If the internal “quit message pending” flag is set, then you will get a <code>WM_QUIT</code> message once the queue goes quiet, regardless of what filter you pass. </p>
<p> By comparison, <code>PostThreadMessage</code> just places the message in the thread queue (for real, not virtually), and therefore it does not get any of the special treatment that a real <code>PostQuitMessage</code> triggers. </p>


</body>
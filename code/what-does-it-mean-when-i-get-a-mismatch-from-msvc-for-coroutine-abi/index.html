<body style=max-width:80ch;margin:auto>
<h1 class="entry-title" style="margin-bottom:15px;">What does it mean when I get a mismatch from MSVC for <code>_COROUTINE_ABI</code>?</h1>  <!-- .entry-meta -->

<p>A customer was compiling some code that uses coroutines. When they linked in the third party Contoso library, they got a linker error:</p>
<pre style="white-space: pre-wrap;">contoso.lib(cpp.obj) : error LNK2038: mismatch detected for '_COROUTINE_ABI': value '1' doesn't match value '2' in main.obj
</pre>
<p>First of all, what does this error message literally mean?</p>
<p>It’s saying that the <code>detect_mismatch</code> pragma was used twice with the same name but different values. In this case, it’s saying that <code>cpp.obj</code> inside <code>contoso.lib</code> did a</p>
<pre>#pragma detect_mismatch("_COROUTINE_ABI", "1")
</pre>
<p>but <code>main.obj</code> (presumably an object file that is part of the customer’s project) did a</p>
<pre>#pragma detect_mismatch("_COROUTINE_ABI", "2")
</pre>
<p>The two values of <code>_COROUTINE_<wbr/>ABI</code> do not match, so the linker reported a mismatch error.</p>
<p>Okay, so now we understand what triggers an error message of this form. Now to figure out what triggers this specific mismatch.</p>
<p>From the name “<code>_COROUTINE_<wbr/>ABI</code>“, it’s apparent that this symbols is tracking which coroutine ABI the compiler is using. Even if you hadn’t inferred that from the name, a search of the language header files will turn up a pair of hits.</p>
<pre>// in &lt;experimental/coroutine&gt;
#ifndef _ALLOW_COROUTINE_ABI_MISMATCH
#pragma detect_mismatch("_COROUTINE_ABI", "1")
#endif // _ALLOW_COROUTINE_ABI_MISMATCH

// in &lt;coroutine&gt;
#ifndef _ALLOW_COROUTINE_ABI_MISMATCH
#pragma detect_mismatch("_COROUTINE_ABI", "2")
#endif // _ALLOW_COROUTINE_ABI_MISMATCH
</pre>
<p>Recall that MSVC <a href="/code/debugging-coroutine-handles-the-microsoft-visual-c-compiler-clang-and-gcc"> supports two coroutine ABIs</a>. The legacy pre-standardization coroutines in <code>&lt;experimental/coroutine&gt;</code> use a single <code>resume</code> method and encode whether the method is being resumed or destroyed by the even/odd-ness of the state index. The standardized coroutines in <code>&lt;coroutine&gt;</code> use a pair of <code>resume</code> and <code>destroy</code> methods, which is ABI-compatible with clang and gcc coroutines, allowing interop among all three implementations.</p>
<p>The two kinds of coroutines (pre-standardization and common-ABI) are not interoperable. If you pass a coroutine of one kind to a function that expects a coroutine of the other kind, it may not operate correctly.</p>
<p>That is the problem that the <code>detect_mismatch</code> is trying to prevent. Your module is mixing code that is using experimental coroutines with code that uses standard coroutines, and if the streams ever cross, bad things will happen.</p>
<p>You can <a href="/code/how-do-i-decode-a-pragma-detect-mismatch-error" title="How do I decode a #pragma detect_mismatch error?"> study the details of the error message to find the two parts that are using mutually incompatible coroutine ABIs</a>.</p>
<p>Okay, so now that we’ve identified the problem, how do we solve it?</p>
<p>Well, it depends on how you use the Contoso library.</p>
<p>If the Contoso library’s use of coroutines is entirely internal to the implementation of the Contoso library, then there is no cross-contamination, and the mismatch will not occur in practice.</p>
<p>Note that if coroutines are used by internal inline functions in public Contoso header files, then that still counts as externally visible, because the code for the inline function will be generated by the <i>client</i> of the library, not locked away inside <code>contoso.lib</code>.</p>
<p>If you can successfully avoid crossing the streams, then you can define the symbol <code>_ALLOW_<wbr/>COROUTINE_<wbr/>ABI_<wbr/>MISMATCH</code> to disable the mismatch detection.</p>
<p>Of course, if you disable the detection, and the streams do cross at some point, then bad things will happen, and it’s all your fault.</p>
<p>If you are unable to avoid crossing the streams, then you have to get the Contoso library and your program to agree on which coroutine ABI it is using. If there is a C++20 version of the Contoso library (or if you can make one by recompiling it), then you can use that version.</p>
<p>Otherwise, you’ll have to downgrade your program to use pre-standardization coroutines. One way is to downgrade the entire program to C++17 with <code>/await</code>. But you may not want to throw away that much baby with the bathwater, since you’ll lose all the C++20 features. You can also use the <code>/await</code> switch in combination with <code>/std:c++20</code> or <code>/std:c++latest</code> to say “I want pre-standardization coroutines” <a href="https://devblogs.microsoft.com/cppblog/c-coroutines-in-visual-studio-2019-version-16-8/"> with as much of the newer language features as possible</a>, provided they don’t create compatibility issues.</p>
<p>This hassle with the coroutine ABI is why compiler toolchain vendors are so concerned about ABI breaking changes. Any time you make an ABI breaking change, you have to deal with pulling everybody over the line at the same time. A compiler upgrade is no longer something you can opt into for only part of a project.</p>


</body>
<body style=max-width:80ch;margin:auto>
<h1 class="entry-title" style="margin-bottom:15px;">Why don’t Windows functions begin with a pointless MOV EDI,EDI instruction on x86-64?</h1>  <!-- .entry-meta -->

<p>Some time ago, we investigated <a href="/other/why-do-windows-functions-all-begin-with-a-pointless-mov-edi-edi-instruction"> why Windows functions all begin with a pointless MOV EDI,EDI instruction</a>. The answer was that the instruction was used as a two-byte <code>NOP</code> which could be hot-patched to a jump instruction, thereby allowing certain types of security fixes to be applied to a running system. (Those which alter data structures or involve cross-process communication would not benefit from this.)</p>
<p>But you may have noticed that on 64-bit Windows, these pointless instructions are gone. Is hot-patching dead?</p>
<p>No, hot-patching is still alive. But on 64-bit Windows, the hot-patch point is implemented differently.</p>
<p>The idea is that we don’t have to insert a pointless two-byte <code>nop</code> instruction into every function. If the first instruction of the function is already a two-byte instruction (or bigger), then that instruction can itself serve as the hot-patch point.</p>
<p>The case where the first instruction of a function is two bytes or larger is by far the dominant one. There are only a few one-byte instructions remaining in x86-64. The ones you’re likely to encounter in user-mode compiler-generated code are</p>
<table border="1" cellpadding="3" cellspacing="0" class="cp3" style="border-collapse: collapse;">
<tbody>
<tr>
<td><code>push r</code></td>
<td><code>leave</code></td>
<td><code>cwde</code></td>
<td><code>int 3</code></td>
</tr>
<tr>
<td><code>pop r</code></td>
<td><code>ret</code></td>
<td><code>cdq</code></td>
<td><code>nop</code></td>
</tr>
</tbody>
</table>
<p>where <code>r</code> is the 64-bit version of one of the eight named (not numbered) registers.</p>
<p>Some of these instructions are not going to appear naturally at the start of a function.</p>
<ul>
<li><code>leave</code> doesn’t make sense because it mutates a callee-preserved register.</li>
<li><code>cwde</code> and <code>cdq</code> don’t make sense because they use <code>rax</code> as an input register, but that register is undefined on entry to a function.</li>
<li><code>nop</code> can just be omitted.</li>
<li>Starting with a <code>pop</code> is disallowed by the Win32 ABI. The return address must stay on the stack.</li>
</ul>
<p>And then some of the instructions can be worked around if they happen to be the start of a function.</p>
<ul>
<li><code>push</code>: If the function pushes any registers <code>r8</code> or higher, those can be pushed first, since the push of a high-numbered register is a two-byte instruction. Or the instruction could be re-encoded with a redundant REX prefix <code>0x48</code>. Alternatively, the compiler could save the register in the home space, which uses a multi-byte <code>mov [rsp+n], r</code> instruction.</li>
<li><code>ret</code>: This happens if the function is empty and returns no value. The compiler can change this to a 3-byte <code>ret 0</code> or a 2-byte <a href="https://repzret.org/p/repzret/"><code>repz ret</code></a>.</li>
</ul>
<p>The last remaining instruction is <code>int 3</code>, which is generated by the <code>__debugbreak</code> intrinsic.</p>
<p>One option is to use the alternate two-byte encoding <code>cd 03</code> (<code>int nn</code>, with <code>nn</code> = 3). However, the code with the <code>__debugbreak</code> may be relying on it being a one-byte instruction, because it intends to patch it with a one-byte <code>nop</code>, or it intends to handle the breakpoint exception by stepping over the opcode by incrementing the instruction pointer.</p>
<p>Instead, the compiler plays it safe and begins the function with a two-byte <code>nop</code>, which is encoded as if it were <code>xchg ax, ax</code>, and in fact the Microsoft debugger disassembles it as such.</p>
<p>The pointless <code>mov edi, edi</code> instruction is gone. And most of the time, the compiler can juggle things so that you don’t even notice that it arranged for the first instruction of a function to be a multi-byte instruction. The only time it fails is if the first thing your function does is <code>__debugbreak</code>, in which case the compiler inserts a pointless <code>xchg ax, ax</code> instruction, also known as the two-byte <code>nop</code>.</p>


</body>
<body style=max-width:80ch;margin:auto>
<h1 class="entry-title" style="margin-bottom:15px;">The thread that gets the DLL_PROCESS_DETACH notification is not necessarily the one that got the DLL_PROCESS_ATTACH notification</h1>  <!-- .entry-meta -->

<p>The thread that gets the <code>DLL_PROCESS_DETACH</code> notification is not necessarily the one that got the <code>DLL_PROCESS_ATTACH</code> notification. This is obvious if you think about it, because the thread that got the <code>DLL_PROCESS_ATTACH</code> notification might not even exist any longer when the DLL is unloaded. How can something that doesn’t exist send a notification?</p>
<p> Even so, many people fail to realize this. You can’t do anything with thread affinity in your <code>DLL_PROCESS_ATTACH</code> or <code>DLL_PROCESS_DETACH</code> handler since you have no guarantee about which thread will be called upon to handle these process notifications. Of course, you’re not supposed to be doing anything particularly interesting in your <code>DLL_PROCESS_ATTACH</code> handler anyway, but things with thread affinity are doubly bad. </p>
<p> The classic example of this, which I’m told the Developer Support team run into with alarming frequency, is a DLL that creates a window in its <code>DLL_PROCESS_ATTACH</code> handler and destroys it in its <code>DLL_PROCESS_DETACH</code> handler. Now, creating a window in <code>DllMain</code> is already a horrifically bad idea since arbitrary code can run during the creation of a window (for example, there may be a global hook), but the lack of a thread guarantee makes it downright insane. The DLL calls <code>DestroyWindow</code> in its <code>DLL_PROCESS_DETACH</code> handler, but since that notification comes in on a thread different from the one that received the <code>DLL_PROCESS_ATTACH</code> notification, the attempt to destroy the window fails since you must call <code>DestroyWindow</code> from the same thread that created it. </p>
<p> Result: The DLL’s attempt to destroy its window fails, a message comes in, and the process crashes since the window procedure no longer exists. </p>


</body>
<body style=max-width:80ch;margin:auto>
<h1 class="entry-title" style="margin-bottom:15px;">If I have a thread waiting on an event, and I call SetEvent immediately followed by ResetEvent, is the waiting thread guaranteed to be released?</h1>  <!-- .entry-meta -->

<p>A customer had developed a producer-consumer scenario and used a manual-reset event to coordinate the threads. “If there are <var>n</var> threads waiting on an event, is it guaranteed that all <var>n</var> threads will be unblocked if the event is signaled? Specifically, is this guaranteed if the event is reset very shortly after it is set? Hypothetically, all the waiting threads may not get scheduled before the signalling thread resets the event, but is it the case that once the event is signaled, all the waiting threads will be unblocked and will eventually start receiving CPU cycles?” </p>
<p>Actually, you have a problem even before you asked the question. How do you know that your waiting threads really are waiting on the event? After all, the fact that your program called <code>Wait­For­Single­Object</code> doesn’t guarantee that the thread is actually waiting. The thread might get pre-empted immediately after the <code>call</code> instruction and before the first line of code in <code>Wait­For­Single­Object</code> executes. As far as your program is concerned, it called <code>Wait­For­Single­Object</code>, but in reality, nothing meaningful has happened yet because <code>Wait­For­Single­Object</code> hasn’t gotten a chance to do anything. In this scenario, the signaling thread can call <code>Set­Event</code> and <code>Reset­Event</code> even before the waiting thread gets a chance to wait. And in that case, obviously, the thread won’t wake up because it never observed a set event. </p>
<p>Even if you somehow manage to guarantee that the threads are definitely waiting, you’re still out of luck. Setting the event and resetting it shortly afterward is basically reinventing <code>Pulse­Event</code>, and we already saw that <a href="https://blogs.msdn.microsoft.com/oldnewthing/20050105-00/?p=36803"><code>Pulse­Event</code> is fundamentally flawed</a>. All the arguments for why <code>Pulse­Event</code> is broken also apply to your homemade <code>Pulse­Event</code> emulator: One of the waiting threads might be temporarily taken out of the wait state to process a kernel APC, and if your <code>Set­Event</code> and <code>Reset­Event</code> occur before the thread returns to the wait state, then the thread will have missed your simulated pulse. </p>
<p>If you have only one waiting thread, you can use an auto-reset event rather than a manual-reset event. That way, the event resets only when the waiting thread definitely observes the wait. But this won’t work if you have multiple waiting threads. </p>
<p>You might consider using a semaphore and releasing <var>n</var> tokens to the semaphore when you want to wake up <var>n</var> threads. There’s still a race condition, though: While preparing to wait, the thread increments <var>n</var> and then waits on the event handle. Suppose that the thread gets pre-empted after the increment and before the wait. The signaling thread releases <var>n</var> tokens. All but one of the tokens are consumed by the other waiting threads, leaving one token for the thread that is about to wait. But wait, what’s that over there? Another thread swooped in, incremented <var>n</var> (from 0 to 1, presumably), and waited on the semaphore. That interloper thread <i>stole your token</i>! </p>
<p>Rather than trying to reimplement <code>Pulse­Event</code> poorly, you probably would be better off using a condition variable. Condition variables are well-suited to these sorts of custom synchronization conditions. </p>


</body>
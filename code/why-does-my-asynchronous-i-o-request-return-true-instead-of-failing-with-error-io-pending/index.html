<body style=max-width:80ch;margin:auto>
<h1 class="entry-title" style="margin-bottom:15px;">Why does my asynchronous I/O request return TRUE instead of failing with ERROR_IO_PENDING?</h1>  <!-- .entry-meta -->

<p>A customer reported that their program was not respecting the <code>FILE_FLAG_OVERLAPPED</code> flag consistently:</p>
<blockquote class="q"><p> My program opens a file handle in <code>FILE_FLAG_OVERLAPPED</code> mode, binds it to an I/O completion callback function with <code>Bind­Io­Completion­Callback</code>, and then issues a <code>Write­File</code> against it. I would expect that the <code>Write­File</code> returns <code>FALSE</code> and <code>Get­Last­Error()</code> returns <code>ERROR_IO_PENDING</code>, indicating that the I/O operation is being performed asynchronously, and that the completion function will be called when the operation completes. However, I find that some percentage of the time, the call to <code>Write­File</code> returns <code>TRUE</code>, indicating that the operation was performed synchronously. What am I doing wrong? I don’t want my thread to block on I/O; that’s why I’m issuing asynchronous I/O. </p></blockquote>
<p> When you specify <code>FILE_FLAG_OVERLAPPED</code>, you’re promising that your program knows how to handle I/O which completes asynchronously, but it does not require the I/O stack to behave asynchronously. A driver can choose to perform your I/O synchronously anyway. For example, if the write operation can be performed by writing to cache without blocking, the driver will just copy the data to the cache and indicate synchronous completion. Don’t worry, be happy: Your I/O completed even faster than you expected!
 Even though the I/O completed synchronously, all the asynchronous completion notification machinery is still active. It’s just that they all accomplished their job <i>before the <code>Write­File</code> call returned</i>. This means that the event handle will still be signaled, the completion routine will still run (once you wait alertably), and if the handle is bound to an I/O completion port, the I/O completion port will receive a completion notification.</p>
<p> You can use the <code>Set­File­Completion­Notification­Modes</code> function to change some aspects of this behavior, giving some control of the behavior of the I/O subsystem when a potentially-asynchronous I/O request completes synchronously. </p>


</body>
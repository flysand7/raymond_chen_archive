<body style=max-width:80ch;margin:auto>
<h1 class="entry-title" style="margin-bottom:15px;">Why can’t you thunk between 32-bit and 64-bit Windows?</h1>  <!-- .entry-meta -->

<p>It was possible to use generic thunks in 16-bit code to allow it to call into 32-bit code. <a href="http://blogs.msdn.com/oldnewthing/archive/2005/07/20/440918.aspx#441290"> Why can’t we do the same thing to  allow 32-bit code to call 64-bit code</a>?</p>
<p> It’s the address space. </p>
<p> Both 16-bit and 32-bit Windows lived in a 32-bit linear address space. The terms 16 and 32 refer to the size of the offset relative to the selector. </p>
<p> Okay, I suspect most people haven’t had to deal with selectors (and that’s probably a good thing). In 16-bit Windows, addresses were specified in the form of a selector (often mistakenly called a “segment”) and an offset. For example, a typical address might be <code>0x0123:0x4567</code>. This means “The byte at offset 0x4567 relative to the selector 0x0123.” Each selector had a corresponding entry in one of the descriptor tables which describes things like what type of selector it is (can it be used to read data? write data? execute code?), but what’s important here is that it also contained a base address and a limit. For example, the entry for selector <code>0x0123</code> might say “0x0123 is a read-only data selector which begins at linear address 0x00524200 and has a limit of 0x7FFF.” This means that the address <code>0x0123:n</code> refers to the byte whose linear address is <code>0x00524200</code> + n, provided that n ≤ <code>0x7FFF</code>. </p>
<p> With the introduction of the 80386, the maximum limit for a selector was raised from <code>0xFFFF</code> to <code>0xFFFFFFFF</code>. (Accessing the bytes past <code>0xFFFF</code> required a 32-bit offset, of course.) Now, if you were clever, you could say “Well, let me create a selector and set its base to <code>0x00000000</code> and its limit to <code>0xFFFFFFFF</code>. With this selector, I can access the entire 32-bit linear address space. There’s no need to chop it up into 64KB chunks like I had to back in the 16-bit days. And then I can just declare that <i>all addresses will be in this form</i> and nobody would have to bother specifying which selector to use since it is implied.” </p>
<p> And if you said this, then you invented the Win32 addressing scheme. It’s not that there are no selectors; it’s just that there is effectively only one selector, so there’s no need to say it all the time. </p>
<p> Now let’s look at the consequences of this for thunking. </p>
<p> First, notice that a full-sized 16-bit pointer and a 32-bit flat pointer are the same size. The value <code>0x0123:0x467</code> requires 32 bits, and wow, so too does a 32-bit pointer. This means that data structures containing pointers do not change size between their 16-bit and 32-bit counterparts. A very handy coincidence. </p>
<p> Next, notice that the 16-bit address space is still fully capable of referring to every byte in the 32-bit address space, since they are both windows into the same underlying linear address space. It’s just that the 16-bit address space can only see the underlying linear address space in windows of 64KB, whereas the 32-bit address space can see it all at once. This means that any memory that 32-bit code can access 16-bit code can also access. It’s just more cumbersome from the 16-bit side since you have to build a temporary address window. </p>
<p> Neither of these two observations holds true for 32-bit to 64-bit thunking. The size of the pointer has changed, which means that converting a 32-bit structure to a 64-bit structure and vice versa changes the size of the structure. And the 64-bit address space is four billion times larger than the 32-bit address space. If there is some memory in the 64-bit address space at offset <code>0x000006fb`01234567</code>, 32-bit code will be unable to access it. It’s not like you can build a temporary address window, because 32-bit flat code doesn’t know about these temporary address windows; they abandoned selectors, remember? </p>
<p> It’s one thing when two people have two different words to describe the same thing. But if one party doesn’t even have the capability of talking about that thing, translating between the two will be quite difficult indeed. </p>
<p> P.S., like most things I state as “fact”, this is just <a href="http://blogs.msdn.com/oldnewthing/archive/2007/08/10/4315707.aspx"> informed speculation</a>. </p>


</body>
<body style=max-width:80ch;margin:auto>
<h1 class="entry-title" style="margin-bottom:15px;">Is it wrong to call SHFileOperation from a service? Revised</h1>  <!-- .entry-meta -->

<p>My initial reaction to this question was to say, “<a href="http://blogs.msdn.com/b/oldnewthing/archive/2013/12/06/10474322.aspx">I don’t know if I’d call it wrong, but I’d call it highly inadvisable</a>.”
 I’d like to revise my guidance.
 It’s flat-out wrong, at least in the case where you call it while impersonating.
 The registry key <code>HKEY_CURRENT_USER</code> is <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms724836(v=vs.85).aspx"> bound to the current user at the time the key is first accessed by a process</a>:</p>
<blockquote class="q"><p> The mapping between <b>HKEY_CURRENT_USER</b> and <b>HKEY_USERS</b> is per process and is established the first time the process references <b>HKEY_CURRENT_USER</b>. The mapping is based on the security context of the first thread to reference <b>HKEY_CURRENT_USER</b>. If this security context does not have a registry hive loaded in <b>HKEY_USERS</b>, the mapping is established with <b>HKEY_USERS\.Default</b>. After this mapping is established it persists, <u>even if the security context of the thread changes</u>. </p></blockquote>
<p> Emphasis mine.
 This means that if you impersonate a user, and then access <code>HKEY_CURRENT_USER</code>, then that binds <code>HKEY_CURRENT_USER</code> to the impersonated user. Even if you stop impersonating, future references to <code>HKEY_CURRENT_USER</code> will still refer to that user.
 This is probably not what you expected.
 The shell takes a lot of settings from the current user. If you impersonate a user and then call into the shell, your service is now using that user’s settings, which is effectively an elevation of privilege: An unprivileged user is now modifying settings for a service. For example, if the user has customized the Print verb for text files, and you use <code>Shell­Execute</code> to invoke the <code>print</code> verb on a text document, you are at the mercy of whatever the user’s <code>print</code> verb is bound to. Maybe it runs Notepad, but maybe it runs pwnz0rd.exe. You don’t know.
 Similarly, the user might have a per-user registered <a href="http://msdn.microsoft.com/library/cc144063"> copy hook</a> or namespace extension, and now you just loaded a user-controlled COM object into your service.
 In both cases, this is known to insiders as <i>hitting the jackpot</i>.
 Okay, so what about if you call <code>Shell­Execute</code> or some other shell function while not impersonating? You might say, “That’s okay, because the current user’s registry is the service user, not the untrusted attacker user.” But look at that sentence I highlighted up there. Once <code>HKEY_CURRENT_USER</code> get bound to a particular user, it remains bound to that user <i>even after impersonation ends</i>. If somebody else inadvisedly called a shell function while impersonating, and that shell function happens to be the first one to access <code>HKEY_CURRENT_USER</code>, then your call to a shell function while not impersonating will still use that impersonated user’s registry. Congratulations, you are now running untrusted code, and you’re not even impersonating any more!</p>
<p> So my recommendation is <i>don’t do it</i>. Don’t call shell functions while impersonating unless the function is explicitly documented as supporting impersonation. (The only ones I’m aware of that fall into this category are functions like <code>SHGet­Folder­Path</code> which accept an explicit token handle.) Otherwise, you may have created (or in the case of copy hooks, definitely created) a code injection security vulnerability in your service. </p>


</body>
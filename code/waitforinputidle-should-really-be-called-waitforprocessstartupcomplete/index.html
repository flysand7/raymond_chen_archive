<body style=max-width:80ch;margin:auto>
<h1 class="entry-title" style="margin-bottom:15px;">WaitForInputIdle should really be called WaitForProcessStartupComplete</h1>  <!-- .entry-meta -->

<p>The <code>WaitForInputIdle</code> function waits for a process to finish its initialization, which is determined when it reaches a state where it is just sitting around waiting for messages.
 The documentation for <code>WaitForInputIdle</code> doesn’t even get around to the initialization part until the <b>Remarks</b> section. If all you read is the one-sentence summary, <i>Waits until the specified process is waiting for user input with no input pending, or until the time-out interval has elapsed</i>, it would not be unreasonable for you to conclude that a process goes into and out of the <i>input idle</i> state each time it processes a message. But no, it’s a one-time transition.
 If you call <code>WaitForInputIdle</code> on a process which had previously gone input idle, but is now busy and not processing pending input messages, the function will still return immediately, because <code>WaitForInputIdle</code> only checks whether the process has gone input idle <i>at all</i> and not whether it is input idle <i>right now</i>.
 As the <b>Remarks</b> section notes, the purpose of the <code>WaitForInputIdle</code> function is for a process to determine whether another process (which is recently launched) has reached a state where it is okay to send that process messages. This is important to know when the form of communication between two processes is a message-based mechanism, and the two processes otherwise have no real way of knowing what the other is doing. (If the two processes had been written by the same author, then you could come up with some more expressive interface for the two to communicate through, one which avoids the need for one process to guess when the other one is ready.) The specific scenario that <code>WaitForInputIdle</code> was created to address is <a href="http://blogs.msdn.com/oldnewthing/archive/2007/02/26/1763683.aspx"> DDE</a>.
 Back in the old 16-bit days, you didn’t need a <code>WaitForInputIdle</code> function, because scheduling was co-operative. You know that the other process was sitting idle, because if it were busy, your code wouldn’t be running in the first place. It’s like waiting for the <a href="http://www.acaciart.com/stories/archive6.html"> talking stick</a> to be handed to you so that you can ask the question, “Are you ready to give up the talking stick?” The <code>WaitForInputIdle</code> function assisted in the porting of these 16-bit applications by allowing a process to wait and simulate the “Wait for the other person to stop talking” operation which had previously been implicit in a co-operative system.
 What would it mean for <code>WaitForInputIdle</code> to wait on a program that has already completed its initialization, when the program has multiple threads? Suppose one thread is sitting around waiting for messages, but another is busy and still has unprocessed input messages. Would a call to this <code>WaitForInputIdleAgain</code> function wait, or should it return immediately? According to the description, it would return immediately, because there is a thread in the process which is “waiting for user input with no input pending.” So even if <code>WaitForInputIdle</code> worked like this imaginary <code>WaitForInputIdleAgain</code> function, it still wouldn’t help you, because it wouldn’t actually wait in cases where you probably wanted it to.</p>
<p> Actually, the above analysis applies to <code>WaitForInputIdle</code> as well; <a href="http://blogs.msdn.com/oldnewthing/archive/2010/03/26/9985422.aspx"> we’ll pick up this discussion next time</a>. </p>


</body>
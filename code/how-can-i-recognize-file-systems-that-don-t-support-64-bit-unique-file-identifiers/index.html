<body style=max-width:80ch;margin:auto>
<h1 class="entry-title" style="margin-bottom:15px;">How can I recognize file systems that don’t support 64-bit unique file identifiers?</h1>  <!-- .entry-meta -->

<p>A customer observed that their attempt to find out whether two handles refer to the same file was not working because some remote file systems report zero for the volume serial number and unique file identifiers, regardless of what file you asked for. This caused them to mistakenly believe that all files were identical! What’s the correct way of identifying whether a file system supports unique file identifiers?</p>
<p>The meaning of the volume serial number is <a href="https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-fscc/bf691378-c34e-4a13-976e-404ea1a87738"> documented as</a></p>
<blockquote class="q"><p><b>VolumeSerialNumber</b> (4 bytes): A 32-bit unsigned integer that contains the serial number of the volume. The serial number is an opaque value generated by the file system at format time, and is not necessarily related to any hardware serial number for the device on which the file system is located. <u>No specific format or content of this field is required for protocol interoperation</u>. This value is not required to be unique.</p></blockquote>
<p>In other words, the volume serial number can mean anything it wants. There is no special meaning for the value of zero.</p>
<p>The <a href="https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-fscc/1e144bff-c056-45aa-bd29-c13d214ee2ba"> documentation for the 64-bit file identifier</a> is a little more helpful:</p>
<blockquote class="q"><p><b>FileId</b> (8 bytes): The 64-bit file ID, as specified in section 2.1.9, for the file. <u>For file systems that do not support a 64-bit file ID, this field MUST be set to 0</u>, and MUST be ignored. For file systems which do not explicitly store directory entries named “..” (synonymous with the parent directory), an implementation MAY set this field to 0 for the entry named “..”, and this value MUST be ignored.¹¹⁰</p></blockquote>
<p>Okay, so a value of zero for the FileId means that the file system doesn’t support 64-bit file IDs, or at least it doesn’t support 64-bit file IDs for the file you asked about. Therefore, if you get zero as the file ID, you should not use it as an indicator of uniqueness.</p>
<p>Chasing through to <a href="https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-fscc/2d3333fe-fc98-4a6f-98a2-4bb805aff407"> section 2.1.9</a> reveals some more information:</p>
<blockquote class="q">
<p>For file systems that do not support a 64-bit file ID, this field MUST be set to 0, and MUST be ignored.</p>
<p><u>For files for which a unique 64-bit file ID cannot be established, this field MUST be set to 0xffffffffffffffff</u>, and MUST be ignored.</p>
</blockquote>
<p>That second paragraph is talking specifically about ReFS, which uses 128-bit file identifiers. This is noted in the <a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/ns-fileapi-by_handle_file_information"> documentation for <code>BY_<wbr/>HANDLE_<wbr/>FILE_<wbr/>INFORMATION</code></a>:</p>
<blockquote class="q"><p>The ReFS file system, introduced with Windows Server 2012, includes 128-bit file identifiers. To retrieve the 128-bit file identifier use the GetFileInformationByHandleEx function with <b>FileIdInfo</b> to retrieve the FILE_ID_INFO structure. The 64-bit identifier in this structure is not guaranteed to be unique on ReFS.</p></blockquote>
<p>What is going on is that if you ask for the 64-bit file identifier from a ReFS system, it will take the 128-bit identifier and see if the upper 64 bits are all zero. If so, then it gives you the lower 64 bits. But if not, then it gives you <code>0xFFFFFFFF`FFFFFFFF</code>, to say “Yeah, um, I have a unique identifier, but I wasn’t able to squish it down into a 64-bit value”.</p>
<p>Therefore, you shouldn’t use <code>0xFFFFFFFF`FFFFFFFF</code> as an indicator of uniqueness either.</p>
<p>Okay, so armed with this background information, let’s see if we can solve the original problem. We’ll do that next time.</p>


</body>
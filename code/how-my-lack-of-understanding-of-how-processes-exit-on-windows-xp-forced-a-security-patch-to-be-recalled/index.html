<body style=max-width:80ch;margin:auto>
<h1 class="entry-title" style="margin-bottom:15px;">How my lack of understanding of how processes exit on Windows XP forced a security patch to be recalled</h1>  <!-- .entry-meta -->

<p>Last year, a Windows security update got a lot of flack for causing some machines to hang, and it was my fault. (This makes <a href="http://blogs.msdn.com/larryosterman/archive/2006/07/31/684327.aspx">messing up a demo at the Financial Analysts Meeting</a> look like small potatoes.)
The security fix addressed a category of attacks wherein people could construct shortcut files or other items which specified a CLSID that was never intended to be used as a shell extension. As we saw earlier, <a href="http://blogs.msdn.com/oldnewthing/archive/2004/03/26/96777.aspx">lots of people mess up <code>IUnknown::QueryInterface</code></a>, and if you pass the CLSID of one of these buggy implementations, Explorer would dutifully create it and try to use it, and then bad things would happen. The object might crash or hang or even corrupt memory and keep running (sort of).
To protect against buggy shell extensions, Explorer was modified to use a helper program called <code>verclsid.exe</code> whose job was to be the “guinea pig” and host the shell extension and do some preliminary sniffing around to make sure the shell extension passed some basic functionality tests before letting it run loose in Explorer. That way, if the shell extension went crazy, the victim would be the <code>verclsid.exe</code> process and not the main Explorer process.
The <code>verclsid.exe</code> program created a watchdog thread: If the preliminary sniffing took too long, the watchdog assumed that the shell extension was hung and the watchdog told Explorer, “Don’t use this shell extension.”
I was one of the people brought in to study this new behavior, poke holes in its design, poke holes in its implementation, review every line of code that changed and make sure that it did exactly what it was supposed to do without introducing any new bugs along the way. We found some issues, testers found some other issues, and all the while, the clock was ticking since this was a security patch and people enjoy mocking Microsoft over how long it takes to put a security patch together.
The patch went out, and reports started coming in that machines were hanging. How could that be? We created a watchdog thread specifically to catch the buggy shell extensions that hung; why isn’t the watchdog thread doing its job?
That was a long set-up for today’s lesson.
After running its sanity tests, the <code>verclsid.exe</code> program releases the shell extension, un-initializes COM, and then calls <code>ExitProcess</code> with a special exit code that means, “All tests passed.” If you read <!--backref: thread termination -->yesterday’s installment, you already know where I messed up.
The DLL that implemented the shell extension created a worker thread, so it did an extra <code>LoadLibrary</code> on itself so that it wouldn’t get unloaded when COM freed it as part of <code>CoUninitialize</code> tear-down. When the DLL got its <code>DLL_PROCESS_DETACH</code>, it shut down its worker thread by the common technique of setting a “clean up now” event that the worker thread listened for, and then waiting for the worker thread to respond with a “Okay, I’m all done” event.
But recall that the first stage in process exit is the termination of all threads other than the one that called <code>ExitProcess</code>. That means that the DLL’s worker thread no longer exists. After setting the event to tell the (nonexistent) thread to clean up, it then waited for the (nonexistent) thread to say that it was done. And since there was nobody around listening for the clean-up event, the “all done” event never got set. The DLL hung in its <code>DLL_PROCESS_DETACH</code>.
Why didn’t our watchdog thread save us? Because <strong>the watchdog thread got killed too</strong>!
Now, the root cause for all this was a buggy shell extension that did bad things in its <code>DLL_PROCESS_DETACH</code>, but blaming the shell extension misses the point. After all, it was the fact that there existed buggy shell extensions that created the need for the <code>verclsid.exe</code> program in the first place.
<b>Welcome Slashdot readers</b>. Since you won’t read the existing comments before posting your own, I’ll float some of the more significant ones here.
The buggy shell extension was included with a printer driver for a printer that is no longer manufactured. Good luck finding one of those in your test suite.</p>
<p>The security update was recalled and reissued in a single action, which most people would call an <i>update</i> or <i>refresh</i>, but the word <i>recall</i> works better in a title. </p>


</body>
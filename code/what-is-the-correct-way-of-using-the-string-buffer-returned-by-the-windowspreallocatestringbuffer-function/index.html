<body style=max-width:80ch;margin:auto>
<h1 class="entry-title" style="margin-bottom:15px;">What is the correct way of using the string buffer returned by the WindowsPreallocateStringBuffer function?</h1>  <!-- .entry-meta -->

<p>The most common way of creating an <code>HSTRING</code> is to <a href="https://blogs.msdn.microsoft.com/oldnewthing/20160615-00/?p=93675">call <code>Windows­Create­String</code></a>, but there is also a two-phase creation pattern: First you call <code>Windows­Preallocate­String­Buffer</code> to create a buffer for a future string. You then fill the buffer with stringy goodness and then call <code>Windows­Promote­String­Buffer</code> to convert it to a real <code>HSTRING</code>. (Or you can call <code>Windows­Delete­String­Buffer</code> to change your mind and pretend it never happened.) </p>
<p>The rule for managing the buffer returned by <code>Windows­Preallocate­String­Buffer</code> is that you are expected to write <i>exactly</i> <code>length</code> code units into the buffer. No more. No less. The system already put a terminating null after the end of the buffer; your job is to fill the buffer with the string contents. </p>
<p>For example, if you want to use two-phase creation to create the string <code>hello</code>, you would call <code>Windows­Preallocate­String­Buffer</code> and pass <code>length = 5</code>. Into the resulting buffer, you write the characters <code>h</code>, <code>e</code>, <code>l</code>, <code>l</code>, and <code>o</code>, and that’s all. The system already stored the terminating null. </p>
<p>This particular formulation of the rules is important in the case that <code>length = 0</code>.¹ Since the representation of an <code>HSTRING</code> of length zero is the null pointer, there is no actual buffer. What happens is that the system uses a single preallocated buffer (consisting of just a null terminator) to represent the buffer for all zero-length strings. If you call <code>Windows­Preallocate­String­Buffer</code>, you get a pointer to that preallocated buffer.² Since you passed a length of zero, you are expected to write zero characters to the buffer; in other words, you are expected to do nothing at all with the buffer. </p>
<p>And of course since <code>HSTRING</code>s are immutable, your permission to modify the buffer ends once you promote the buffer to a string. Once it’s been promoted to a string, the entire buffer becomes read-only. </p>
<p>¹ Another way of interpreting this corner case is to say “Don’t bother calling <code>Windows­Preallocate­String­Buffer</code> with a string of length zero. Otherwise, go ahead and call it, and you can write that null terminator if you like.” </p>
<p>² Arguably, to accommodate the possibiltiy of somebody writing that null terminator, it should return a preallocated <i>writable</i> buffer just large enough to hold that null terminator. It could be the high 16 bits of the <code>length</code> field itself! </p>


</body>
<body style=max-width:80ch;margin:auto>
<h1 class="entry-title" style="margin-bottom:15px;">Restating the obvious about the WM_COMMAND message</h1>  <!-- .entry-meta -->

<p>
I’m satisfied with the MSDN documentation for
<a href="http://msdn.microsoft.com/library/en-us/winui/winui/windowsuserinterface/resources/menus/menureference/menumessages/wm_command.asp">
the <code>WM_COMMAND</code> message</a>,
but for the sake of mind-numbing completeness,
I’m going to state the obvious in the hope that you,
dear readers, can use this technique to
fill in the obvious in other parts of MSDN.
</p>
<p>
The one-line summary of the <code>WM_COMMAND</code> message
says,
“The WM_COMMAND message is sent when the user selects
a command item from a menu,
when a control sends a notification message to its parent window,
or when an accelerator keystroke is translated.”
In a nutshell, there are three scenarios that generate a
<code>WM_COMMAND</code> message, namely the three listed above.
You want to think of the menu and accelerator scenarios of the
<code>WM_COMMAND</code> message as special cases of the control scenario.
</p>
<p>
The high-order word of the <code>wParam</code> parameter
“specifies the notification code if the message is from a control”.
What does “control” mean here?
Remember that you have to take things in context.
The <code>WM_COMMAND</code> message is being presented in the
context of Win32 in general, and in the context of the window manager
in particular.
Windows such as edit boxes, push buttons, and list boxes
are commonly called “controls”, as are all the window classes
in the “common controls library”.
In the world of the window manager, a “control” is a window
whose purpose is to provide some degree of interactivity
(which, in the case of the static control, might be no interactivity at all)
in the service of its parent window.
The fact that the <code>WM_COMMAND</code> is used primarily
in the context of dialog boxes further emphasizes the point
that the term “control” here is just a synonym for “child window”.
</p>
<p>
What does “notification code” mean here?
Control notification codes are arbitrary 16-bit values defined
by the control itself.
By convention, they are named <code>xxN_xxxx</code>, where the “N”
stands for “notification”.
Be careful, however, not to confuse this with notification codes
associated with the <code>WM_NOTIFY</code> message.
Fortunately, every notification code specifies in its documentation
whether it arrives as a <code>WM_COMMAND</code> notification or
a <code>WM_NOTIFY</code> notification.
A modern control designer is more likely to use
<code>WM_NOTIFY</code> notifications since they allow
additional information to be passed with the notification.
The <code>WM_COMMAND</code> message, by comparison, passes
only the notification itself; the other parameters to
the <code>WM_COMMAND</code> message are forced, as we’ll see below.
If <code>WM_NOTIFY</code> is superior to <code>WM_COMMAND</code>,
why do some controls use <code>WM_COMMAND</code>?
Because <code>WM_NOTIFY</code> wasn’t available until
Windows 95.
Controls that were written prior to Windows 95 had to
content themselves with the <code>WM_COMMAND</code> message.
</p>
<p>
“If the message is from an accelerator, this value [the high-order
word of the <code>wParam</code> parameter] is 1.”
Remember, we’re still in the context of the window manager,
and particular in the context of the <code>WM_COMMAND</code>
message.
The accelerator here refers to messages generated by the call to
<code>TranslateAccelerator</code> in the message loop.
</p>
<p>
“If the message is from a menu, this value is zero.”
If the <code>WM_COMMAND</code> mesage was triggered by
the user selecting an item from a menu, then the high-order
word of the <code>wParam</code> is zero.
</p>
<p>
The low-order word of the <code>wParam</code> parameter
“specifies the identifier of the menu item, control, or
accelerator.”
The identifier of a menu item or accelerator
is the command code you associated
with it in your menu or accelerator template or (in the case of a menu item)
when you manually created the menu item with a function like
<code>InsertMenuItem</code>.
(You probably named your menu item identifiers and accelerator
identifiers <code>IDM_something</code>.)
The identifier of a control is determined by the creator of the
control; recall that the
<code>hMenu</code> parameter to the <code>CreateWindow</code>
and <code>CreateWindowEx</code> functions is treated as a child
window identifier if you’re creating a child window.
It is that identifier that the control identifier.
(You can retrieve the identifier for a control by calling the
<code>GetDlgCtrlID</code> function.)
</p>
<p>
Finally, the <code>lParam</code> parameter is the
“handle to the control sending the message if the message is from a control.
Otherwise, this parameter is NULL.”
If the notification is generated by a child window
(with a notification code appropriate for that child window, obviously),
then that child window handle is passed as the <code>lParam</code>.
If the notification is generated by an accelerator or a menu,
then the <code>lParam</code> is zero.
</p>
<p>
Notice that nearly all of the parameters to the
<code>WM_COMMAND</code> message are forced, once you’ve decided
what notification you’re generating.
</p>
<p>
If you are generating a notification from a control,
you must pass the notification code in the high word of the
<code>wParam</code>, the control identifier in the low word
of the <code>wParam</code>, and the control handle as the
<code>lParam</code>.
In other words, once you’ve decided that the
<code>hwndC</code> window wants to send a
<code>CN_READY</code> notification, you have no choice but
to type
</p>
<pre>
SendMessage(GetParent(hwndC), WM_COMMAND,
            MAKEWPARAM(GetDlgCtrlID(hwndC), CN_READY),
            (LPARAM)hwndC);
</pre>
<p>
In other words, all control notifications take the form
</p>
<pre>
SendMessage(GetParent(hwndC), WM_COMMAND,
            MAKEWPARAM(GetDlgCtrlID(hwndC), notificationCode),
            (LPARAM)hwndC);
</pre>
<p>
where <code>hwndC</code> is the control generating the notification
and <code>notificationCode</code> is the notification code.
Of course, you can use <code>PostMessage</code> instead of
<code>SendMessage</code> if you would rather post the notification
rather than sending it.
</p>
<p>
The other two cases (accelerators and menus) are not cases you
would normally code up, since you typically let the
<code>TranslateAccelerator</code> function deal with accelerators
and let the menu system deal with menu identifiers.
But if for some reason, you wanted to pretend that the user
had typed an accelerator or selected a menu item, you can generate
the notification manually by following the rules set out in the
documentation.
</p>
<pre>
// simulate the accelerator IDM_WHATEVER
SendMessage(hwnd, WM_COMMAND,
            MAKEWPARAM(IDM_WHATEVER, 1),
            0);
</pre>
<p>
Here, <code>hwnd</code> is the window that you want to pretend was
the window passed to the <code>TranslateAccelerator</code> function,
and <code>IDM_WHATEVER</code> is the accelerator identifier.
</p>
<p>
Simulating a menu selection is exactly the same, except that
(according to the rules above), you set the high-order word of
the <code>wParam</code> to zero.
</p>
<pre>
// simulate the menu item IDM_WHATEVER
SendMessage(hwnd, WM_COMMAND,
            MAKEWPARAM(IDM_WHATEVER, 0),
            0);
</pre>
<p>
Here, <code>hwnd</code> is the window associated with the menu.
A window can be associated with a menu either by being created
with the menu (having passed the menu handle to the
<code>CreateWindow</code> or <code>CreateWindowEx</code> function
explicitly, or having it done implicitly by including it with the
class registration) or by having been passed explicitly as
the window parameter to a function like
<code>TrackPopupWindow</code>.
</p>
<p>
One significant difference between the accelerator/menu case
and the control notification case is that accelerator and menu
identifiers are defined by the calling application,
whereas control notifications are defined by the control.
</p>
<p>
You may have noticed the opportunity to “pun”
the control notification codes.
If a control defines a notification code as zero, then it will
“look like” a menu item selection, since the high-order word
of the <code>wParam</code> in the case of a menu item selection
is zero.
The button control takes advantage of this pun:
</p>
<pre>
#define BN_CLICKED          0
</pre>
<p>
This means that when the user clicks a button control,
the <code>WM_COMMAND</code> message that is generated
“smells like” a menu selection notification.
You probably take advantage of this in your dialog procedure
without even realizing it.
</p>
<p>
(The static control also takes advantage of this pun:
</p>
<pre>
#define STN_CLICKED         0
</pre>
<p>
but in order for the static control to generate the
<code>STN_CLICKED</code> notification,
you have to set the <code>SS_NOTIFY</code> style.)
</p>
<p>
I stated at the start that the accelerator and menu scenarios
are just special cases of the control scenario.
If you take the pieces of the <code>WM_COMMAND</code> message
apart, you’ll see that they fall into two categories:
</p>
<ul>
<li>What happened? (Notification code.)
<li>Whom did it happen to? (Control handle and ID.)
</li></li></ul>
<p>
In the case of a menu or an accelerator, the “What happened?”
is “The user clicked on the menu (0)” or
“The user typed the accelerator (1)”.
The “Whom did it happen to?” is “This menu ID” or “This accelerator ID”.
Since the notification is not coming from a control, the control
handle is <code>NULL</code>.
</p>
<p>
I apologize to all you Win32 programmers for whom
this is just stating the obvious.
</p>
<p>
Now that you’re an expert on the <code>WM_COMMAND</code> message,
perhaps you can solve
<a href="http://groups.google.com/group/comp.os.ms-windows.programmer.win32/msg/9d4372f762ad5c68">
this person’s problem</a>.</p>


</body>
<body style=max-width:80ch;margin:auto>
<h1 class="entry-title" style="margin-bottom:15px;">Windows Runtime objects are represented by their default interface, so choose your default interface wisely</h1>  <!-- .entry-meta -->

<p>As I noted some time ago, in the Windows Runtime, <a href="/code/accessing-a-member-of-a-windows-runtime-class-raises-an-invalidcastexception-throws-a-hresult-no-interface-what-does-this-mean"> objects are represented at the ABI by a pointer to their default interface</a>. The choice of default interface is usually obvious, but on occasion, the non-obvious choice may be better.</p>
<p>If your runtime object supports only one interface, then you have no choice but to make that interface the default interface. But if your runtime object supports multiple interfaces, then you have a choice. For example:</p>
<pre>runtimeclass AudioTrack : IMediaTrack
{
    event Windows.Foundation.TypedEventHandler&lt;AudioTrack, AudioTrackOpenedEventArgs&gt;
        OpenFailed;

    AudioEncodingProperties GetEncodingProperties();
    MediaPlaybackItem PlaybackItem { get; };
    String Name { get; };
    AudioTrackSupportInfo SupportInfo { get; };
};
</pre>
<p>As written, the MIDL compiler does the following:</p>
<ul>
<li>Autogenerates an interface called <code>IAudioTrack</code> to contain the members declared in the class definition.</li>
<li>Defines the <code>AudioTrack</code> class as implementing the <code>IAudioTrack</code> and <code>IMediaTrack</code> interfaces.</li>
<li>Marks the <code>IAudioTrack</code> class as the default interface.</li>
</ul>
<p>As noted above, the default interface is used to represent the object. Method calls on the default interface will be faster than method calls on non-default interfaces, because <a href="https://devblogs.microsoft.com/oldnewthing/20200324-00/?p=103586"> methods on non-default interfaces require a <code>Query­Interface</code> to obtain the interface</a>. Therefore, you should choose your default interface to be one that holds the methods that you anticipate will be used the most. If that interface is not the autogenerated interface, you can specify a custom default interface by putting the word <code>[default]</code> in front of the interface you want to be the default interface:</p>
<pre>runtimeclass AudioTrack : <span style="color: #08f;">[default]</span> IMediaTrack
{
    event Windows.Foundation.TypedEventHandler&lt;AudioTrack, AudioTrackOpenedEventArgs&gt;
        OpenFailed;

    AudioEncodingProperties GetEncodingProperties();
    MediaPlaybackItem PlaybackItem { get; };
    String Name { get; };
    AudioTrackSupportInfo SupportInfo { get; };
};
</pre>
<p>In this case, the object will be used primarily as a media track, and it is the methods on <code>IMediaTrack</code> that will get the most exercise. Registering for the <code>OpenFailed</code> event will probably happen only once, and the support info might never be used at all. It would be preferable to make the <code>IMediaTrack</code> the default interface, so that the commonly-used methods are readily available.</p>
<p>Another scenario where you may want to override the MIDL compiler’s choice of default interface is if your class implements a collection, possibly with an extra method or two. The object will almost certainly be used as a collection, so you should choose the collection as your default interface:</p>
<pre>runtimeclass PlayerCollection : [default] <a href="https://devblogs.microsoft.com/oldnewthing/20200316-00/?p=103564">IVector</a>&lt;Page&gt;,
{
  void MoveToIndex(Player player, Int32 newIndex);
}
</pre>
<p>This hypothetical <code>Player­Collection</code> class implements <code>IVector</code>, so you can do all the normal vector things with it. But <code>IVector</code> doesn’t support reordering items. That’s why the <code>Play­Collection</code> has a bonus <code>Move­To­Index</code> method that lets you take an item in the collection and move it to another position. The class may offer this so that it can provide a more suitable animation: You could get the same effect by removing the player and then reinserting it at the desired new index. However, that would result in a delete animation followed by an insertion animation, rather than a reordering animation.</p>


</body>
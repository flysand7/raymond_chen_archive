<body style=max-width:80ch;margin:auto>
<h1 class="entry-title" style="margin-bottom:15px;">Taking advantage of the ordering guarantees of the LINQ GroupBy method</h1>  <!-- .entry-meta -->

<p>A customer wanted to group a set of data by one field, and within each group, sort the data by another field, and then sort the groups by that second field. </p>
<p>For example, given the following data set: </p>
<table border="1" cellpadding="3" cellspacing="0" class="cp3" style="border-collapse: collapse">
<tr>
<th>Name</th>
<th>Time</th>
</tr>
<tr>
<td>Charles</td>
<td>11</td>
</tr>
<tr>
<td>Charles</td>
<td>21</td>
</tr>
<tr>
<td>Alice</td>
<td>20</td>
</tr>
<tr>
<td>Charles</td>
<td>23</td>
</tr>
<tr>
<td>Alice</td>
<td>29</td>
</tr>
<tr>
<td>Alice</td>
<td>13</td>
</tr>
<tr>
<td>Charles</td>
<td>17</td>
</tr>
<tr>
<td>Bob</td>
<td>20</td>
</tr>
<tr>
<td>Alice</td>
<td>13</td>
</tr>
<tr>
<td>Bob</td>
<td>12</td>
</tr>
<tr>
<td>Alice</td>
<td>26</td>
</tr>
<tr>
<td>Bob</td>
<td>18</td>
</tr>
<tr>
<td>Charles</td>
<td>18</td>
</tr>
<tr>
<td>Bob</td>
<td>28</td>
</tr>
<tr>
<td>Alice</td>
<td>23</td>
</tr>
<tr>
<td>Bob</td>
<td>13</td>
</tr>
</table>
<p>We group by name: </p>
<table border="1" cellpadding="3" cellspacing="0" class="cp3" style="border-collapse: collapse">
<tr>
<th>Name</th>
<th>Time</th>
</tr>
<tr>
<td>Alice</td>
<td>20</td>
</tr>
<tr>
<td>Alice</td>
<td>29</td>
</tr>
<tr>
<td>Alice</td>
<td>13</td>
</tr>
<tr>
<td>Alice</td>
<td>13</td>
</tr>
<tr>
<td>Alice</td>
<td>26</td>
</tr>
<tr>
<td>Alice</td>
<td>23</td>
</tr>
<tr>
<td>Bob</td>
<td>20</td>
</tr>
<tr>
<td>Bob</td>
<td>12</td>
</tr>
<tr>
<td>Bob</td>
<td>18</td>
</tr>
<tr>
<td>Bob</td>
<td>28</td>
</tr>
<tr>
<td>Bob</td>
<td>13</td>
</tr>
<tr>
<td>Charles</td>
<td>11</td>
</tr>
<tr>
<td>Charles</td>
<td>21</td>
</tr>
<tr>
<td>Charles</td>
<td>23</td>
</tr>
<tr>
<td>Charles</td>
<td>17</td>
</tr>
<tr>
<td>Charles</td>
<td>18</td>
</tr>
</table>
<p>And then we sort each person’s time, shortest first. </p>
<table border="1" cellpadding="3" cellspacing="0" class="cp3" style="border-collapse: collapse">
<tr>
<th>Name</th>
<th>Time</th>
</tr>
<tr>
<td>Alice</td>
<td>13</td>
</tr>
<tr>
<td>Alice</td>
<td>13</td>
</tr>
<tr>
<td>Alice</td>
<td>20</td>
</tr>
<tr>
<td>Alice</td>
<td>23</td>
</tr>
<tr>
<td>Alice</td>
<td>26</td>
</tr>
<tr>
<td>Alice</td>
<td>29</td>
</tr>
<tr>
<td>Bob</td>
<td>12</td>
</tr>
<tr>
<td>Bob</td>
<td>13</td>
</tr>
<tr>
<td>Bob</td>
<td>18</td>
</tr>
<tr>
<td>Bob</td>
<td>20</td>
</tr>
<tr>
<td>Bob</td>
<td>28</td>
</tr>
<tr>
<td>Charles</td>
<td>11</td>
</tr>
<tr>
<td>Charles</td>
<td>17</td>
</tr>
<tr>
<td>Charles</td>
<td>18</td>
</tr>
<tr>
<td>Charles</td>
<td>21</td>
</tr>
<tr>
<td>Charles</td>
<td>23</td>
</tr>
</table>
<p>And then we sort the people by their best time. Charles’s best time is 11 seconds, which is best overall, so his times go first. Bob’s best time is 12 seconds, so his group goes next. Alice’s best time is 13 seconds, so her group is last. </p>
<table border="1" cellpadding="3" cellspacing="0" class="cp3" style="border-collapse: collapse">
<tr>
<th>Name</th>
<th>Time</th>
</tr>
<tr>
<td>Charles</td>
<td>11</td>
</tr>
<tr>
<td>Charles</td>
<td>17</td>
</tr>
<tr>
<td>Charles</td>
<td>18</td>
</tr>
<tr>
<td>Charles</td>
<td>21</td>
</tr>
<tr>
<td>Charles</td>
<td>23</td>
</tr>
<tr>
<td>Bob</td>
<td>12</td>
</tr>
<tr>
<td>Bob</td>
<td>13</td>
</tr>
<tr>
<td>Bob</td>
<td>18</td>
</tr>
<tr>
<td>Bob</td>
<td>20</td>
</tr>
<tr>
<td>Bob</td>
<td>28</td>
</tr>
<tr>
<td>Alice</td>
<td>13</td>
</tr>
<tr>
<td>Alice</td>
<td>13</td>
</tr>
<tr>
<td>Alice</td>
<td>20</td>
</tr>
<tr>
<td>Alice</td>
<td>23</td>
</tr>
<tr>
<td>Alice</td>
<td>26</td>
</tr>
<tr>
<td>Alice</td>
<td>29</td>
</tr>
</table>
<p>So we have a three-step LINQ query, where we group, and then sort each group, and then sort the groups. </p>
<pre>
var results =
    data.GroupBy(x =&gt; x.Name) // group by name
        .Select(g =&gt; g.OrderBy(x =&gt; x.Time)); // sort each group
        .OrderBy(g =&gt; g.First()) // sort the groups by best time
        .SelectMany(g =&gt; g);  // flatten the groups
</pre>
<p>The last step is to use <code>SelectMany</code> to convert the groups back into their individual members. This takes advantage of the fact that <code>IGrouping&lt;TKey, out TElement&gt;</code>, derives from <code>IEnumerable&lt;TElement&gt;</code>, so you can use the group as a collection. </p>
<p>But you can reduce this to a two-step operation: First sort globally by time, and then group them. The <code>Group­By</code> method is documented as reporting the groups in the order of first appearance, so this ensures that the fastest group comes first. </p>
<pre>
var results =
    data.OrderBy(x =&gt; x.Time) // sort globally by time
        .GroupBy(x =&gt; x.Name) // group by name (best time first)
        .SelectMany(g =&gt; g);  // flatten the groups
</pre>
<p>It does slightly more work than the three-step query because it sorts the entire collection, even though it needed only to sort each group. But it looks slicker, and might even be easier to understand. Provided you understand that the grouping is stable. </p>


</body>
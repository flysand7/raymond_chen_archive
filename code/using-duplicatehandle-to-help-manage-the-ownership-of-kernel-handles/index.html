<body style=max-width:80ch;margin:auto>
<h1 class="entry-title" style="margin-bottom:15px;">Using DuplicateHandle to help manage the ownership of kernel handles</h1>  <!-- .entry-meta -->

<p>A customer was using a third party I/O library that also gave you access to the underlying <code>HANDLE</code>, in case you needed it. The customer needed that underlying <code>HANDLE</code> so it could pass it to <a href="https://msdn.microsoft.com/en-us/library/bdts1c9x.aspx"><code>_open_osfhandle()</code></a> and get a C runtime file descriptor, which could then be used by other C runtime functions to operate on the I/O object. </p>
<p>Everything was great until it came time to close the I/O object, because both the I/O library and the C runtime tried to close the handle. and that resulted in assertion failures due to invalid handles. </p>
<p>The problem here is that both the I/O library and the C runtime think that they are responsible for closing the handle. The I/O library wants to close the handle because it created the handle in the first place, and the special method to obtain that underlying <code>HANDLE</code> wasn’t transferring ownership of the handle to you; it merely gave you a handle that you could borrow. On the other hand, the <code>_open_osfhandle()</code> function will close the handle when the file descriptor is closed, because the function assumes that you’re giving it not only the handle, but also the responsibility to close the handle. </p>
<p>Neither library has a way to change the handle semantics. There isn’t a way to tell the I/O library or the C runtime, “Hey, don’t close that handle.” </p>
<p>The solution here is to use the <code>Duplicate­Handle</code> function to create a brand new handle that refers to the same underlying kernel object. You can then pass the duplicate to <code>_open_osfhandle()</code>. Both the I/O library and the C runtime library will close their respective handles. Since each handle is closed exactly once, balance is restored to the universe. </p>
<p><b>Exercise</b> (easy): Suppose you have a C runtime file descriptor, and you want to take the underlying kernel handle and give it to another library, which will close the handle you give it. How do you manage this without running into a double-close bug? </p>
<p><b>Exercise</b> (slightly harder): Suppose your program needs more than 2048 C runtime file descriptors, which is more than <a href="https://msdn.microsoft.com/en-us/library/6e3b887c.aspx"><code>_setmaxstdio</code></a> accepts. Fortunately, your program doesn’t actively use all of the descriptors at the same time, so you’re thinking that you can virtualize the file descriptors by “paging them in” and “paging them out” from underlying kernel handles. How would you do this? </p>


</body>
<body style=max-width:80ch;margin:auto>
<h1 class="entry-title" style="margin-bottom:15px;">An initial look at the mechanics of how COM marshaling is performed</h1>  <!-- .entry-meta -->

<p>Last time, we looked at <a href="/code/what-are-the-various-usage-patterns-for-manually-marshaled-interfaces" title="What are the various usage patterns for manually-marshaled interfaces?"> the usage patterns for manually-marshaled interfaces</a>. Today, we’ll look at the contract from the other side.</p>
<p>A marshaler has to implement a number of methods, which break down nicely into three groups:</p>
<table border="1" cellpadding="3" cellspacing="0" class="cp3" style="border-collapse: collapse;">
<tbody>
<tr>
<th>Method</th>
<th>Operation</th>
<th>Group</th>
</tr>
<tr>
<td><code>Get­Unmarshal­Class</code></td>
<td>Report the object to create when unmarshaling.</td>
<td rowspan="3">Marshaling</td>
</tr>
<tr>
<td><code>Get­Marshal­Size­Max</code></td>
<td>Calculate how much memory is needed.</td>
</tr>
<tr>
<td><code>Marshal­Interface</code></td>
<td>Generate the marshaling data.</td>
</tr>
<tr>
<td><code>Unmarshal­Interface</code></td>
<td>Load object from marshaling data.</td>
<td>Unmarshaling</td>
</tr>
<tr>
<td><code>Release­Marshal­Data</code></td>
<td>Clean up marshaling data.</td>
<td rowspan="2">Cleaning up</td>
</tr>
<tr>
<td><code>Disconnect­Object</code></td>
<td>Shut down the unmarshaled object.</td>
</tr>
</tbody>
</table>
<p>The general sequence of operations goes like this:</p>
<ul>
<li>Marshaling an object (happens in the source context):
<ul>
<li>COM asks <code>Get­Unmarshal­Class</code> for the class ID to create when unmarshaling.</li>
<li>COM asks <code>Get­Marshal­Size­Max</code> how much memory will be needed for the marshaling data.</li>
<li>COM allocates the required amount of data.</li>
<li>COM asks <code>Marshal­Interface</code> to produce that data into a provided stream.</li>
</ul>
</li>
<li>Unmarshaling an object (happens in the destination context):
<ul>
<li>COM creates the unmarshaler object previously specified by <code>Get­Unmarshal­Class</code>.</li>
<li>COM calls <code>Unmarshal­Interface</code> so the unmarshaler object can produce a new object from the marshal data that it had previously generated by its <code>Marshal­Interface</code> method. (In most cases, the unmarshaler uses itself as the produced object.)</li>
</ul>
</li>
<li>Cleaning up:
<ul>
<li>COM calls <code>Release­Marshal­Data</code> on any thread to tell the unmarshaler to clean up any resources associated with the marshaled data. (The documentation says that under rare conditions, COM might ask the marshaler to do the cleanup.)</li>
<li>COM calls <code>Disconnect­Object</code> in the destination context to tell the unmarshaled object that it should break any connection with the original object. In practice, this is called only for proxies created by the standard marshaler, because COM doesn’t know how to hunt down custom proxies.</li>
</ul>
</li>
</ul>
<p>An important note is that, as we noted last time, the <code>Unmarshal­Interface</code> automatically performs an internal equivalent of <code>Release­Marshal­Data</code> if the marshaling was performed as <code>MSHLFLAGS_<wbr/>NORMAL</code>.</p>
<p>Let walk through these steps with an analogy: Suppose the object is an oracle, say <code>COracle</code>. People can talk to the oracle, but the nature of the sense of hearing is that in order for people to do that, they need to be standing nearby, or at least a sound source carrying their voice needs to be nearby.</p>
<p>Now, suppose somebody who lives far away would like to talk to the oracle.</p>
<p>The <code>COracle</code>‘s <code>Get­Unmarshal­Class</code> method would return the class ID for a custom <code>CLSID_<wbr/>Oracle­Proxy</code> class.</p>
<p>The <code>COracle</code>‘s <code>Get­Marshal­Size­Max</code> method would return 10, the maximum number of digits in a Greek telephone number. (<a href="https://en.wikipedia.org/wiki/Pythia">The oracle lives in Delphi</a>.)</p>
<p>The <code>COracle</code>‘s <code>Marshal­Interface</code> method would buy an eSIM card, write the number of the eSIM card on a papyrus scroll, and add the eSIM to the oracle’s mobile phone plan. (The is a modern oracle who knows how to use a mobile phone.) For simplicity, let’s assume that the marshaling was performed as <code>TABLE­STRONG</code>. Associated with each eSIM is a reference count, that is the number of active remote clients plus the number of papyrus scrolls that have the number written on it. At the start, the reference count of the eSIM is 1 because the number is written on a papyrus scroll.</p>
<p>The courier delivers the papyrus scroll to whoever it was that wanted to talk to the oracle. The recipient unrolls the papyrus scroll, transcribes the bytes, and gives them to COM.</p>
<p>COM looks at the bytes of the stream and says “Okay, it says here that I need to create a <code>CLSID_<wbr/>Oracle­Proxy</code> object.” COM therefore creates a <code>COracle­Proxy</code> object, in an uninitialized state.</p>
<p>COM then calls the <code>COracle­Proxy</code>‘s <code>Unmarshal­Interface</code> with the remaining bytes of the stream. That method takes the ten digits of the oracle’s eSIM card and commits them to memory. It calls the number (including the +30 dialing prefix if the proxy is outside Greece), and says, “Hi, this is <code>COracle­Proxy</code>. Just telling you that there’s somebody over here who wants to talk to you.” The oracle increments the reference count on the eSIM number.</p>
<p>Since the marshaling was done as <code>TABLE­STRONG</code>, the courier can deliver the papyrus scroll to another client, and the unmarshal ceremony is repeated.</p>
<p>At some point, the papyrus scroll will be disposed of. But before they perform a ceremonial burning, they must call <code>Co­Release­Unmarshal­Data</code>. That function creates a new instance of the unmarshaler object <code>CLSID_<wbr/>Oracle­Proxy</code> and this time calls the <code>Release­Marshal­Data</code> method. That method retrieves the phone number, calls it, and tells the oracle, “I’m destroying the papyrus scroll now.” The oracle decrements the reference count on the eSIM and since it is not yet zero, she doesn’t cancel the eSIM card yet.</p>
<p>Now, it’s also possible that the courier was unable to deliver the papyrus scroll to the remote client (maybe they moved and left no forwarding address). In that case, the courier is the one who calls <code>Co­Release­Marshal­Data</code> before destroying the papyrus scroll. The courier might do this when they reach the remote client’s home and finds that the house is empty. The courier might do this even before getting to the remote client’s house, because the entire city has been burnt to the ground by an invading army. Or the courier might do this even before leaving the oracle because they realize that the remote client’s address is outside his delivery area. Whatever the reason, the <code>Release­Marshal­Data</code> function extracts the phone number and calls the oracle to say, “I’m destroying the papyrus scroll now”. In this case, the oracle decrements the reference count on the eSIM to zero, so she cancels the eSIM account and removes it from her mobile phone plan.</p>
<p>Anyway, assuming the courier reaches the destination and set up an oracle proxy, we are now in the state where the remote client can now ask questions to the <code>COracle­Proxy</code>, and the oracle proxy will pick up the phone, call the oracle at Delphi, and relay the question and its answer.</p>
<p>Eventually, the remote client decides that they are finished asking questions and <code>Release</code>s the oracle proxy. The oracle proxy makes one last call to the oracle, saying, “The client is finished asking questions. You can cancel the account as soon as I hang up.” Once the call ends, the oracle decrements the reference count on the eSIM, and if it goes to zero, then she cancels the eSIM account and deletes it from her mobile phone plan.</p>
<p>The oracle herself might decide that she wants to retire. In that case, the oracle asks COM to disconnect all remote clients, and then cancels all of her eSIM accounts and dramatically throws her mobile phone into a fire. (There’s a lot of burning in a fire in my imaginary version of ancient Greece.)</p>
<p>COM finds all of the oracle proxies associated with the remote client and calls the <code>Disconnect­Object</code> method. Each oracle proxy makes a mental note that the oracle has retired, and the next time their remote client says, “Hey, please ask the oracle a question for me,” the oracle proxy can say “Sorry, the oracle has retired. She is no longer accepting questions.”</p>
<p>Next time, we’ll use this understanding to start writing our own marshaler.</p>


</body>
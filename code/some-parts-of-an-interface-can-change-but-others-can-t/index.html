<body style=max-width:80ch;margin:auto>
<h1 class="entry-title" style="margin-bottom:15px;">Some parts of an interface can change but others can't</h1>  <!-- .entry-meta -->

<p>
When I wrote about
<a href="http://blogs.msdn.com/b/oldnewthing/archive/2013/02/20/10395379.aspx">
asking the compiler to answer calling convention questions</a>,
some people were concerned about whether this was a reliable mechanism
or whether it was relying on something that can change in the future.
</p>
<p>
This is a special case of the question,
“What parts of an interface can change, and what can’t?”
And it all boils down to compile-time versus run-time.
</p>
<p>
Assuming you are interested in binary compatibility
(as opposed to merely source compatibility),
then
a decision made at compile-time can never be changed
because the decision is already hard-coded into the application.
For example, if you have a function that takes a parameter that is
an enumeration, say,
</p>
<pre>
enum FOO_OPTIONS
{
    FOO_HOP = 0,
    FOO_SKIP = 1,
    FOO_JUMP = 2,
};
</pre>
<p>
then the values of
<code>FOO_HOP</code>,
<code>FOO_SKIP</code>,
and
<code>FOO_JUMP</code>
are hard-coded into any program that uses them.
The compiler will generate code like this:
</p>
<pre>
; foo(FOO_JUMP);
    push 2
    call foo
</pre>
<p>
Suppose you later change the header file to
</p>
<pre>
enum FOO_OPTIONS
{
    FOO_HOP = 2,
    FOO_SKIP = 3,
    FOO_JUMP = 4,
};
</pre>
<p>
Making a change in the new version of a header file
has no effect on any existing programs which were
compiled with the old version of the header file.
There is no way for the <code>foo</code> function to tell
whether the <code>2</code> it received as a parameter is a
<code>FOO_JUMP</code> from the old header file or
a <code>FOO_HOP</code> from the new one.
</p>
<p>
Therefore, you cannot reuse values in any
existing enumerations
or <code>#define</code>‘s because the values are already compiled
into existing programs.
If you had given the value <code>2</code> different meanings in different
versions of the header file,
you would have in principle
no way of knowing which header file the caller used.
Of course, you can invent external cues to let you figure it out;
for example, there may be a separate <code>set_foo_version</code>
function
that callers use in order to specify whether they are using the
old or new header file.
Of course, that also means that if there are multiple components that
disagree on what version of <code>foo</code> they want,
you have another problem.
</p>
<p>
Note that this is not the same as saying that the value of a symbol
cannot change.
We’ve seen this happen in the past
<a href="http://blogs.msdn.com/b/oldnewthing/archive/2009/04/23/9564015.aspx">
with the <code>PSH_WIZARD­97</code> flag</a>,
but these sorts of redirections are rare in practice.
</p>
<p>
Another thing that is hard-coded into an application is the calling
convention.
Once code is generated by the compiler to call a function,
that’s that.
You can’t change the calling convention without breaking existing code.
That’s why you can ask the compiler,
“How would you call this function?”
and trust the answer:
If the compiler generates code to call the function using technique X
(register set-up, what gets pushed on the stack first, <i>etc</i>.),
then
the function had better accept technique X in perpetuity.
Of course, you need to be sure that what you observe is in fact all
there is.
There may be parts of the calling convention that are not obvious to you,
such as
<a href="http://blogs.msdn.com/b/oldnewthing/archive/2004/01/02/47184.aspx">
the presence of a red zone</a>
or
<a href="http://blogs.msdn.com/b/oldnewthing/archive/2004/01/14/58579.aspx">
maintaining a particular stack alignment</a>.
Or it could be that the function is called only from within
the module, and the compiler’s whole-program optimization decided
to use a custom nonstandard calling convention.
</p>
<p>
On the other hand, things determined at run-time can be changed,
provided they are changed in a manner consistent with their original
documentation.
For example, the message numbers returned by
<code>Register­Window­Message</code> can change
because the documentation specifically requires you to call
<code>Register­Window­Message</code> to obtain the
message number for a particular named message.
</p>
<p>
If you want to know how to call a function,
it’s perfectly valid to ask the compiler,
because at the end of the day,
that’s how the function gets called.
It’s all machine code.
Whether that machine code was generated by a compiler
or by an assembler is irrelevant.
</p>
<p>
<b>Caveat</b>: I’m ignoring whole-program optimization
and link-time code generation,
which allow the toolchain to rewrite calling conventions
if all callers can be identified.
We’ll see more about this in a future article.
The technique described in this article works best with
exported/imported functions,
because it is not possible to identify all callers of
such functions,
and the compiler is forced to use the official calling convention.
(You can also use it when inspecting .COD files for
functions defined in a separate translation unit,
for the same reason.
That’s the technique I used in the linked article.)</p>


</body>
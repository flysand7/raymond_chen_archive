<body style=max-width:80ch;margin:auto>
<h1 class="entry-title" style="margin-bottom:15px;">Why does CoCreateInstance work even though my thread never called CoInitialize? The curse of the implicit MTA</h1>  <!-- .entry-meta -->

<p>While developing tests, a developer observed erratic behavior with respect to <code>Co­Create­Instance</code>:</p>
<blockquote class="q"><p>  In my test, I call <code>Co­Create­Instance</code> and it fails with <code>CO_E_NOT­INITIALIZED</code>. Fair enough, because my test forgot to call <code>Co­Initialize</code>. </p>
<p> But then I went and checked the production code: In response to a client request, the production code creates a brand new thread to service the request. The brand new thread does not call <code>Co­Initialize</code>, yet its call to <code>Co­Create­Instance</code> <i>succeeds</i>. How is that possible? I would expect the production code to also get a <code>CO_E_NOT­INITIALIZED</code> error. </p>
</blockquote>
<p> I was able to debug this psychically, but only because I knew about the <i>implicit MTA</i>. </p>
<p> The <i>implicit MTA</i> is not something I can find very much documentation on, except in the documentation for the <a href="http://msdn.microsoft.com/library/dd542638"> <code>APP­TYPE­QUALIFIER</code> enumeration</a>, where it mentions: </p>
<blockquote class="q"><p> [The <b>APT­TYPE­QUALIFIER_IMPLICIT_MTA</b>] qualifier is only valid when the <i>pAptType</i> parameter of the <b>Co­Get­Apartment­Type</b> function specifies APT­TYPE_MTA on return. A thread has an implicit MTA apartment type if it does not initialize the COM apartment itself, and if another thread has already initialized the MTA in the process. This qualifier informs the API caller that the MTA of the thread is implicitly inherited from other threads and is not initialized directly. </p></blockquote>
<p> Did you get that? If any thread in the process calls <code>Co­Initialize­[Ex]</code> with the <code>COINIT_MULTI­THREADED</code> flag, then that not only initializes the current thread as a member of the multi-threaded apartment, but it also says, “Any thread which has never called <code>Co­Initialize­[Ex]</code> is also part of the multi-threaded apartment.” </p>
<p> Further investigation revealed that yes, some other thread in the process called <code>Co­Initialize­Ex(0, COINIT_MULTI­THREADED)</code>, which means that the thread which forgot to call <code>Co­Initialize</code> was implicitly (and probably unwittingly) placed in the MTA. </p>
<p> The danger of this implicit MTA, of course, is that since you didn’t know you were getting it, you also don’t know if you’re going to lose it. If that other thread which called <code>Co­Initialize­Ex(0, COINIT_MULTI­THREADED)</code> finally gets around to calling <code>Co­Un­initialize</code>, then it will tear down the MTA, and your thread will have the MTA rug ripped out from under it. </p>
<p> Moral of the story: If you want the MTA, make sure you ask for it explicitly. And if you forget, you may end up in the implicit MTA, whether you wanted it or not. (Therefore, conversely, if you <i>don’t</i> want the MTA, make sure to deny it explicitly!) </p>
<p> <b>Exercise</b>: Use your psychic debugging skills to diagnose the following problem. “When my code calls <code>Get­Open­File­Name</code>, it behaves erratically. I saw a Knowledge Base article that says that this can happen <a href="http://support.microsoft.com/kb/287087"> if I initialize my thread in the multi-threaded apartment</a>, but my thread does not do that.” </p>


</body>
<body style=max-width:80ch;margin:auto>
<h1 class="entry-title" style="margin-bottom:15px;">Psychic debugging: Why your thread is spending all its time processing meaningless thread timers</h1>  <!-- .entry-meta -->

<p>I was looking at one of those “my program is consuming 100% of the CPU and I don’t know why” bugs, and upon closer investigation, the proximate reason the program was consuming 100% CPU was that one of the threads was being bombarded with <code>WM_TIMER</code> messages where the <code>MSG.hWnd</code> is <code>NULL</code>. The program was dispatching them as fast as it could, but the messages just kept on coming. Curiously, the <code>LPARAM</code> for these messages was zero.</p>
<p> This should be enough information for you to figure out what is going on. </p>
<p> First, you should refresh your memory as to what a null window handle in a <code>WM_TIMER</code> message means: These are thread timers, timers which are associated not with a window but with a thread. You create a thread timer by calling the <code>SetTimer</code> function and passing <code>NULL</code> as the window handle. Thread timer messages arrive in the message queue, and the <code>DispatchMessage</code> function calls the timer procedure specified by the message <code>LPARAM</code>. If the <code>LPARAM</code> of a thread timer message is zero, then dispatching the message consists merely of throwing it away. (If there were a window handle, then the message would be delivered to the window procedure, but there isn’t one, so there’s nothing else that can be done.) </p>
<p> The program was spending all its time retrieving <code>WM_TIMER</code> messages from its queue and throwing them away. The real question is how all these thread timers ended up on the thread when they don’t do anything. Who would create a timer that didn’t do anything? And who would create dozens of them? </p>
<p> One of the more common patterns for creating a window timer is to write <code>SetTimer(hwnd, idTimer, dwTimeout, NULL)</code>. This creates a window timer whose identifier is <code>idTimer</code>. Since the timer procedure is <code>NULL</code>, the <code>WM_TIMER</code> message is dispatched to the window procedure, which in turn will have a <code>case WM_TIMER</code> statement followed by a  <code>switch (wParam)</code> to handle the timer message. </p>
<p> But what if <code>hwnd</code> is <code>NULL</code>, say because you forgot to check the return value of a function like <code>CreateWindow</code>? Well, then you just created a thread timer by mistake. And if you make this mistake several times in a row, you’ve just created several thread timers. Now you might think that the code that created the thread timer by mistake will also destroy the thread timer by mistake when it finally gets around to calling <code>KillTimer(hwnd, idTimer)</code> and passes <code>NULL</code> for the <code>hwnd</code>. But it doesn’t. </p>
<p> One reason is that in many cases, it’s the timer that turns itself off. In other words, the <code>KillTimer</code> happens inside the <code>WM_TIMER</code> message handler. But if the <code>WM_TIMER</code> message  isn’t associated with that window, then that window procedure never gets a chance to turn off the timer. </p>
<p> Another reason is more insidious. Recall that the <code>idTimer</code> parameter to the <code>SetTimer</code> function is ignored when you create a thread timer. Since you can’t predict what other thread timers may exist, you can’t know which timer identifiers are in use and which are free. Instead, the <code>SetTimer</code> function creates a unique thread timer identifier and returns it, and it is that timer identifier you must use when destroying the thread timer. Of course, the code that accidentally created the thread timer thought it was creating a window timer (which uses the timer identifier you specify), so it didn’t bother saving the return value. Result: Thread timer is created and becomes orphaned. </p>
<p> The machine I was asked to look at was running a stress scenario, so it was entirely likely that a low memory condition caused a function like <code>CreateWindow</code> to fail, and the program most likely neglected to check the return value. I never did hear back to find out if that indeed was the source of the problem, but seeing as they didn’t come back for more help, I suspect I put them on the right track. </p>


</body>
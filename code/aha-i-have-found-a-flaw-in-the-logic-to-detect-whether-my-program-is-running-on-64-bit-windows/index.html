<body style=max-width:80ch;margin:auto>
<h1 class="entry-title" style="margin-bottom:15px;">Aha, I have found a flaw in the logic to detect whether my program is running on 64-bit Windows</h1>  <!-- .entry-meta -->

<p>Some time ago, I described <a href="http://blogs.msdn.com/b/oldnewthing/archive/2005/02/01/364563.aspx"> how to detect programmatically whether you are running on 64-bit Windows</a>, and one of the steps of the algorithm was “If you are a 64-bit program, then you are running on 64-bit Windows, because 32-bit Windows cannot run 64-bit programs.”
 Every so often, somebody will claim that they found a flaw in this logic: “This algorithm may work today, but it assumes that the only version of Windows that can run 64-bit applications is 64-bit Windows. What if a future <a href="http://web.archive.org/web/20091010165416/http://blog.eightforums.com/windows_8/windows-8-x128-the-next-pc-revolution-has-is-begun/"> non-64-bit version of version of Windows</a> runs 64-bit applications? Then your algorithm will incorrectly say that it is running on 64-bit Windows!”
 Yeah, but so what?
 Suppose you detect that the program is running on this hypothetical version of Windows that is not natively 64-bit but still runs 64-bit applications. What will your program do differently? How can you reason about the feature set and compatibility requirements of something that hasn’t been invented yet?
 This is another case of <a href="http://blogs.msdn.com/b/oldnewthing/archive/2013/04/17/10411656.aspx"> <i>If you don’t know what you’re going to do with the answer to a question, then there’s not much point in asking it</i></a>.</p>
<p> In this specific case, you should just continue about your normal business and <a href="http://blogs.msdn.com/b/oldnewthing/archive/2008/12/22/9244582.aspx"> let the emulation layer</a> of the hypothetical future version of Windows do its job of giving you a 64-bit sky with 64-bit birds in the 64-bit trees. </p>


</body>
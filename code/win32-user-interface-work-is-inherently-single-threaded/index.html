<body style=max-width:80ch;margin:auto>
<h1 class="entry-title" style="margin-bottom:15px;">Win32 user interface work is inherently single-threaded</h1>  <!-- .entry-meta -->

<p>At the end of the day, there’s a window handle in there.
 As we saw a few years ago, <a href="http://blogs.msdn.com/oldnewthing/archive/2005/10/13/480569.aspx"> windows have thread affinity</a>. You can push work to a background thread all you want, but once you send a message to the window (or do something that results in a message being sent to the window), you’ve given control to the UI thread.
 Since the shell is all about user interfaces, <a href="http://support.microsoft.com/kb/287087"> the shell naturally expects that all threads that use it are single-threaded apartments</a>. Historically, however, you sort of got away with violating this rule <a href="http://blogs.msdn.com/oldnewthing/archive/2004/07/05/173226.aspx"> because older versions of the shell used their own custom fake version of COM</a> rather than using the official one in <code>OLE32.DLL</code>. As a result, programs that broke the rule on apartment threading often managed to get away with it because the shell assumed everybody was doing the right thing. (The Internet Explorer team <a href="http://blogs.msdn.com/tonyschr/archive/2006/12/11/interface-smuggling.aspx"> faced a similar problem with browser plug-ins</a>.) If you tried to use an object on the wrong thread, nobody would step in and try to stop you. Mind you, you might corrupt memory or crash, but that was your own fault. <a href="http://blogs.msdn.com/oldnewthing/archive/2005/10/21/483438.aspx"> Nobody said this was going to be easy</a>.
 As the shell gradually switched to using real COM instead of fake COM, and as new features were added to the shell which relied more and more heavily on callers following the rules for apartment threading, programs that had skirted the rules started running into problems. If you got away with it on earlier versions of Windows and the problem was severe, there was a good chance the shell would have to do some re-architecting to allow your dodgy code to keep working.</p>
<p> A member of the COM team explained that COM assumes fundamentally that multi-threaded apartments are UI-free. No UI means no need to pump messages. If you initialize COM in MTA mode on a thread, you’d better not do any UI or your thread will stop responding to messages whenever COM needs to talk to another thread. </p>


</body>
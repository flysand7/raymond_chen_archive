<body style=max-width:80ch;margin:auto>
<h1 class="entry-title" style="margin-bottom:15px;">Why not just share a single event across all critical section?</h1>  <!-- .entry-meta -->

<p>Neil Rashbrook wonder why <a href="https://devblogs.microsoft.com/oldnewthing/20191101-00/?p=103046#comment-135674"> there isn’t a single event that all critical sections share</a>. When a critical section is exited, and there is a waiting thread, then “signal all threads waiting on critical sections”. One thread will get the critical section, and threads that are waiting for unrelated critical sections will just think that they lost a nonexistent race and go back to sleep.</p>
<p>There are a few problems with this idea.</p>
<p>The first problem is specific to the way Windows kernel events work. How would you “signal all threads waiting on critical sections” with a kernel event? If you use an automatic-reset event, then only one thread will wake. In order to wake all threads, you need a manual-reset event. But how do you know when to reset the event? You want to reset the event once all threads have woken up, but you have no way of knowing when that has happened.</p>
<p>You might think of using <code>Pulse­Event</code> and then realize that you have no easy way of closing the race condition between a thread realizing that it needs to go to sleep and the actual sleep. You would have to use something like <code>Signal­Object­And­Wait</code>, but that means that every critical section acquisition would need to take a kernel mutex so it could prevent the owner from pulsing the event before the waiter could reach the <code>Wait­For­Single­Object</code> on the kernel event. But if you’re going to take a kernel mutex on every acquisition, then you destroyed the purpose of the critical section, which is to be a lightweight alternative to a kernel mutex! You may as well just use a kernel mutex as your critical section.</p>
<p>And all that is on top of the fact that <a href="https://devblogs.microsoft.com/oldnewthing/20050105-00/?p=36803"> <code>Pulse­Event</code> is fundamentally flawed</a>.</p>
<p>Now, maybe you could come up with an alternative to a kernel mutex and a kernel event. Say, a global slim reader-writer lock and a paired condition variable. The condition variable lets you <code>notify_all</code> in a reliable way, and then every thread checks whether their critical section is available. Could we use that for our critical section design?</p>
<p>I guess you could do that, but you wouldn’t want to. Waking every thread that’s waiting for a critical section, even though you know that only one will succeed, is the definition of a <a href="https://en.wikipedia.org/wiki/Thundering_herd_problem"> thundering herd problem</a>. You take a lot of context switches, lose a lot of CPU cache, page in a lot of memory, and waste a lot of CPU time with all the pointless work. You really want to wake just one candidate thread and leave the others sleeping. That’s why our <a href="https://devblogs.microsoft.com/oldnewthing/20160825-00/?p=94165"> critical section built out of <code>Wait­On­Address</code></a> uses <code>Wake­By­Address­Single</code>.</p>
<p>Note that the candidate thread you wake up may not actually succeded at claiming the critical section, because another thread may sneak in and claim the critical section before your candidate can wake up. Although this sounds unfair, unfairness is actually a feature, because it avoids <a href="https://en.wikipedia.org/wiki/Lock_convoy"> lock convoys</a>.</p>
<p> </p>


</body>
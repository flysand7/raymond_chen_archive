<body style=max-width:80ch;margin:auto>
<h1 class="entry-title" style="margin-bottom:15px;">VirtualLock locks your memory into the working set, even if your threads are blocked</h1>  <!-- .entry-meta -->

<p>Today, a correction to <a href="http://blogs.msdn.com/b/oldnewthing/archive/2007/11/06/5924058.aspx"> an earlier article on <code>Virtual­Lock</code></a>.
 When you lock memory with <code>Virtual­Lock</code>, it will remain locked even if all your threads are blocked. As noted in the <i>Follow-up</i> section at the end of the referenced article, the behavior of the operating system never changed. Virtually-locked pages were never unlocked in practice. What changed is that an implementation detail was elevated to contract. The intention when <code>Virtual­Lock</code> was originally designed was that virtually-locked pages were potentially unlockable if the application is not running. However, the memory manager folks never got around to implementing that part. At some point, they decided that they would abandon any future intention to to do and strengthened the contract accordingly.
 Mind you, <code>Virtual­Lock</code> does not guarantee that the same physical frame will always be assigned to the memory. The memory manager may reassign the memory to another physical frame in order to <a href="http://blogs.msdn.com/b/oldnewthing/archive/2011/01/28/10121300.aspx"> defragment memory so that it can allocate physically contiguous pages</a>, primarily for I/O purposes, but occasionally to satisfy a large-page request. All it guarantees is that the memory will always be present.</p>
<p> The memory manager folks tell me that locked memory remains locked even if the application is suspended. But I don’t know whether that’s an implementation detail or contractual, so I wouldn’t run around relying on it. </p>


</body>
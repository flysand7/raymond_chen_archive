<body style=max-width:80ch;margin:auto>
<h1 class="entry-title" style="margin-bottom:15px;">What’s the deal with OLDNAMES.LIB?</h1>  <!-- .entry-meta -->

<p>Set the time machine to 1988. The C language has not yet been standardized. Everybody had their own libraries for doing stuff, and some of them even pretended to be compatible with each other. The Microsoft C compiler, for example, came with a bunch of functions like <code>unlink</code> and <code>stat</code> to provide sort-of compatibility with Unix-sort-of source code.</p>
<p>And then the C standard was ratified in 1989. Now things got interesting, because those functions were not part of the C standard. Standard-conforming C programs were welcome to define functions with those names, and the rules say that this is perfectly legal and are not references to the identically-named Unix-like functions.</p>
<p>Now, there was a lot of code written for the Microsoft C toolchain that used these sort-of-Unix-ish functions, and renaming those functions would cause those programs to break.</p>
<p>So should we rename the Unix-ish functions in the Microsoft C library, in order to conform to the C standard? Or should we leave the functions in the Microsoft C library under their pre-standard names, to keep existing code working?</p>
<p><a href="https://dilbert.com/strip/1996-01-27"> Let’s do both</a>!</p>
<p>The Microsoft C library renamed these Unix-ish function to have a leading underscore. So <code>unlink</code> became <code>_unlink</code>, and so on. A program that didn’t use the Unix-ish library functions could define its own function called <code>unlink</code>, and everything would work just fine. But if the program actually wanted to use the <code>unlink</code> function from the Unix-ish library, this magic library <code>OLDNAMES.LIB</code> would step in.</p>
<p>The <code>OLDNAMES.LIB</code> library doesn’t contain any code of its own. Rather, it contains name redirections that say, “Hey, I have a symbol called <code>unlink</code>, in case you were looking for it. Wait, you want to know what this symbol represents? Um, it represents a symbol named <code>_unlink</code>. Good luck with that.”</p>
<p>If the linker cannot find a symbol named <code>unlink</code>, it turns to <code>OLDNAMES.LIB</code> as a library of last resort, and that library resolves the symbol <code>unlink</code>, but replaces it with an unresolved symbol named <code>_unlink</code>. The linker then goes through the symbol resolution process again, and this time it finds <code>_unlink</code> in the regular C library.</p>
<p>The net result is that your attempt to call the function <code>unlink</code> got redirected to the function <code>_unlink</code>, but only if you didn’t already have a function named <code>unlink</code>.</p>
<p>You can <a href="https://docs.microsoft.com/cpp/c-runtime-library/backward-compatibility?view=vs-2019"> suppress the <code>OLDNAMES.LIB</code> library</a> in various ways, most notably by passing the <code>/NODEFAULTLIB</code> flag, which can be abbreviated to the somewhat enigmatic <code>/NOD</code>.</p>


</body>
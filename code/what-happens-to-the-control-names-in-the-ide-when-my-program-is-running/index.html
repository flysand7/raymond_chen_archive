<body style=max-width:80ch;margin:auto>
<h1 class="entry-title" style="margin-bottom:15px;">What happens to the control names in the IDE when my program is running?</h1>  <!-- .entry-meta -->

<p>nick_journals demonstrates <a href="http://blogs.msdn.com/oldnewthing/pages/407234.aspx#1120782"> some confusion</a> about names in source code and their relationship to runtime behavior.</p>
<blockquote class="q"><p>  A topic I am particularly interested in is the naming of controls, how it works… </p>
<p> Every control gets a name from a developer…via the IDE (e.g btnOK) </p>
<p> When using this function: GetWindowLong(handle,GWL_ID) it doesn’t return the name itself but mostly a number or nothing. </p>
<p> What is GWL_ID, the documentation isn’t very clear on this. </p>
<p> How does this whole system work, what are these numbers and where are the ‘real’ names? </p>
</blockquote>
<p> I’m going to answer the questions most technical first. That way you can stop reading when you understand the topic.
 The <code>GWL_ID</code> window long (or, more precisely, the <code>GWLP_ID</code> window pointer-sized long) returns the value you passed to the <code>CreateWindowEx</code> function as the child window identifier (<a href="http://blogs.msdn.com/oldnewthing/archive/2010/03/15/9978691.aspx">overloaded as the <code>hMenu</code> parameter</a>). The call to <code>CreateWindowEx</code> might have happened explicitly in your code, or it may have been the result of a call to <code>CreateWindowEx</code> made on your behalf by another component, <a href="http://blogs.msdn.com/oldnewthing/archive/2005/03/31/404108.aspx"> such as the dialog manager</a>, which takes the control identifier from the dialog template. (Note that only child windows have child window identifiers. Top-level windows don’t have child window identifiers.) And if you passed zero as the child window identifier, then when you ask for the <code>GWLP_ID</code>, you’ll get zero back.
 The name that appears in your source code is just a name you decided to use to talk about the control. It’s just a convenience for yourself, so instead of saying “Control number 103” all over the place, you can say “Control number <code>IDC_ADD</code>“. And sometimes even that is too much typing, so you shorten it to “control <code>btnAdd</code>.” The window manager doesn’t know what cute shortcut names you’ve created for your child windows; the window manager still calls it control number 103. By analogy, the phone company doesn’t know which numbers you’ve programmed into your speed dial. That’s just something you set up in your phone to make dialing more convenient.
 In other words, the “real name” is really just a fake name you created to make things easier to talk about. The actual “real name” is the child window identifier. When you look in the telephone book for Bob, you’ll see Bob’s phone number, not his speed-dial number on your phone.
 This is the same thing that happens to your variables after the code has been compiled. At runtime, your variable names don’t exist any more. They were just convenient mnemonic names you gave to computational values. The compiler uses those convenient names to determine what you’re talking about when you assign a variable or a fetch a variable’s value, but once that’s done, it has no need for the name any more.
 In other words, the name in your source code is just something you did to make things easier to write. The compiler’s job is to change your line <code>x = y;</code> into <code>mov eax, [ebp-05ch]; mov [00437180h], eax</code>, at which point the names <code>x</code> and <code>y</code> are no longer needed and are discarded. (Actually, it’s saved off in a separate file for the debugger to use, so that when you ask the debugger to show the value of the variable <code>x</code>, it knows to look in <code>00437180h</code>, but that happens outside of the execution environment.)</p>
<p> It’s like asking, “What happens to the phrase <i>1 cup sugar</i> when I eat my cookies?” The phrase <i>1 cup sugar</i> was part of the instructions for making the cookies. Once you finish following the recipe, the instructions aren’t needed any more. Or at least not for the process of enjoying cookies. (You might still want to hang onto them to debug your recipe!) </p>


</body>
<body style=max-width:80ch;margin:auto>
<h1 class="entry-title" style="margin-bottom:15px;">The implementation of anonymous methods in C# and its consequences (part 1)</h1>  <!-- .entry-meta -->

<p>
You may not even have realized that
there are two types of anonymous methods.
I’ll call them the easy kind and the hard kind,
not because they’re actually easy and hard for you the programmer,
but because they are easy and hard for the compiler.
</p>
<p>
The easy kind is the anonymous method that doesn’t use any local variables
from its lexically-enclosing method.
These are anonymous methods that could have been their own separate
member functions; all the anonymization does is save you
the trouble of coming up with names for them:
</p>
<pre>
class MyClass1 {
 int v = 0;
 delegate void MyDelegate(string s);
 MyDelegate MemberFunc()
 {
  int i = 1;
  return delegate(string s) {
          System.Console.WriteLine(s);
         };
  }
}
</pre>
<p>
This particular anonymous method doesn’t access any <code>MyClass1</code>
members, nor does it access the local variables of the
<code>MemberFunc</code> function; therefore, it can be
converted to a static method of the <code>MyClass1</code> class:
</p>
<pre>
class MyClass1_converted {
 int v = 0;
 delegate void MyDelegate(string s);
 <font color="blue">// Autogenerated by the compiler
 static void __AnonymousMethod$0</font>(string s)
 {
  System.Console.WriteLine(s);
 }
 MyDelegate MemberFunc()
 {
  int i = 1;
  return <font color="blue">__AnonymousMethod$0</font>;
  // which is in turn shorthand for
  // return new MyDelegate(MyClass1.__AnonymousMethod$0);
  }
}
</pre>
<p>
All the compiler did was give your anonymous methods a name
and use that name in place of the “<code>delegate (...) { ... }</code>“.
(Note that all compiler-generated names I use here are
purely illustrative.
The actual compiler-generated name will be something different.)
</p>
<p>
On the other hand, if your anonymous method used the <code>this</code>
parameter, then that makes it an instance method instead of a
static method:
</p>
<pre>
class MyClass2 {
 int v = 0;
 delegate void MyDelegate(string s);
 MyDelegate MemberFunc()
 {
  int i = 1;
  return delegate(string s) {
          System.Console.WriteLine("{0} {1}", v, s);
         };
  }
}
</pre>
<p>
The anonymous method in <code>MyClass2</code>
uses the <code>this</code> keyword
implicitly (to access the member variable <code>v</code>).
Therefore, the conversion is to an instance member rather
than to a static member.
</p>
<pre>
class MyClass2_converted {
 int v = 0;
 delegate void MyDelegate(string s);
 <font color="blue">// Autogenerated by the compiler
 void __AnonymousMethod$0</font>(string s)
 {
  System.Console.WriteLine("{0} {1}", v, s);
 }
 MyDelegate MemberFunc()
 {
  int i = 1;
  return <font color="blue">this.__AnonymousMethod$0</font>;
  // which is in turn shorthand for
  // return new MyDelegate(this.__AnonymousMethod$0);
  }
}
</pre>
<p>
So far, we’ve only dealt with the easy cases.
The transformation is local and not particularly complicated.
These are the sorts of transformations you could make yourself
without too much difficulty
in the absence of anonymous methods.
</p>
<p>
The hard case is where things get interesting.
The body of an anonymous method is permitted to access the
local variables of its lexically-enclosing method,
in which case the compiler needs to keep those variables alive
so that the body of your anonymous method can access them.
Here’s a sample anonymous method that accesses local variables
from its lexically-enclosing method:
</p>
<pre>
class MyClass3 {
 int v = 0;
 delegate void MyDelegate(string s);
 MyDelegate MemberFunc()
 {
  int i = 1;
  return delegate(string s) {
          System.Console.WriteLine("{0} {1} {2}", i++, v, s);
         };
  }
}
</pre>
<p>
In this example, the anonymous method prints
“1 v s” the first time it is called,
then “2 v s” the second time it is called,
and so on, with the integer increasing by one.
(And where <code>v s</code> are the current values of <code>v</code>
and <code>s</code>, of course.)
This happens because the <code>i</code> variable that the
anonymous method is accessing is the same one each time,
and it’s the same <code>i</code> that the <code>MemberFunc</code>
method was using, too.
If the function were rewritten as
</p>
<pre>
class MyClass4 {
 int v = 0;
 delegate void MyDelegate(string s);
 MyDelegate MemberFunc()
 {
  int i = 0;
  MyDelegate d = delegate(string s) {
          System.Console.WriteLine("{0} {1} {2}", i++, v, s);
         };
  i = 1;
  return d;
  }
}
</pre>
<p>
the behavior would be the same as in <code>MyClass3</code>.
The creation of the delegate from the anonymous method does
<strong>not</strong> make a copy of the <code>i</code>
variable;
changes to the <code>i</code> variable in the <code>MemberFunc</code>
are visible to the anonymous method because both are accessing
the <strong>same</strong>
variable.
</p>
<p>
When faced with this “hard” type of anonymous method, wherein variables
are shared with the lexically-enclosing method,
the compiler generates a helper class:
</p>
<pre>
class MyClass3_converted {
 int v = 0;
 delegate void MyDelegate(string s);
 <font color="blue">// Autogenerated by the compiler
 class __AnonymousClass$0 {
  MyClass this$0;
  int i;
  public void __AnonymousMethod$0</font>(string s)
  {
    System.Console.WriteLine("{0} {1} {2}", i++, <font color="blue">this$0</font>.v, s);
  }<font color="blue">
 }</font>
 MyDelegate MemberFunc()
 {
  <font color="blue">__AnonymousClass$0 locals$ = new __AnonymousClass$0();
  locals$.this$0 = this;
  locals$.</font>i = 0;
  return <font color="blue">locals$.__AnonymousMethod$0</font>;
  // which is in turn shorthand for
  // return new MyDelegate(locals$.__AnonymousMethod$0);
  }
}
</pre>
<p>
Wow, there was a lot of rewriting this time.
A helper class was created to contain the local variables
that were shared between the <code>MemberFunc</code> function
and the anonymous method (in this case, just the variable <code>i</code>),
as well as the hidden <code>this</code> parameter
(which I have called <code>this$</code>).
In the <code>MemberFunc</code> function,
access to that shared variable is done through
this anonymous class, and the anonymous method that you wrote
is an anonymous method on the anonymous class.
</p>
<p>
Notice that the assignment to <code>i</code> in
<code>MemberFunc</code> modifies the copy inside <code>locals$</code>,
which is the same object that the anonymous method will be using when it runs.
That’s why it prints “1 v s” the first time:
The value had already been changed to 1 by the time the
delegate ran for the first time.
</p>
<p>
Those who have done a good amount of C++ programming
(or C# 1.0 programming) are well familiar with this technique,
since C++ callbacks typically are given only one context variable;
that context variable is usually a pointer to a larger structure
that contains all the complex context you really want to operate on.
C# 1.0 programmers went through a similar exercise.
The “hard” type of anonymous method provides syntactic sugar
that saves you the hassle of having to declare and manage the helper class.
</p>
<p>
If you thought about it some, you’d have realized that
the way it’s done is pretty much the only way it could have been done.
It turns out that most computer programming doesn’t consist of being
clever or making hard decisions.
You just have one kernel of an idea (“hey let’s have anonymous
methods”) and then the rest is just doing what has to be done,
no actual decisions needed.
You just do the obvious thing.
Most programming consists of just doing the obvious thing.
</p>
<p>
Okay, so that’s a quick introduction to the implementation of
anonymous methods in C#.
Mind you, this information isn’t just for your personal edification.
It’s actually important that you understand how these works
(and not just treat it as “magic”),
because lack of said understanding can lead to subtle programming errors.
We’ll look at those types of errors over the next few days.
</p>
<p>
<b>Update</b>: This behavior
<a>
changed in Visual Studio 2015</a>
with
the switch to the Roslyn compiler.
For performance reasons,
anonymous methods are now always instance methods, even if they
capture nothing.</p>


</body>
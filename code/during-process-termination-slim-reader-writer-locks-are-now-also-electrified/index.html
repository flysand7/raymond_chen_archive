<body style=max-width:80ch;margin:auto>
<h1 class="entry-title" style="margin-bottom:15px;">During process termination, slim reader/writer locks are now also electrified</h1>  <!-- .entry-meta -->

<p>Some time ago I mentioned that <a href="http://blogs.msdn.com/b/oldnewthing/archive/2010/01/22/9951750.aspx"> during process termination, the gates are now electrified</a>: If you attempt to enter a critical section that is owned by a thread that was terminated by an earlier phase of process termination, the entire process is forcibly terminated.
 Windows Vista introduced a new lightweight synchronization pseudo-object known as the <a href="http://msdn.microsoft.com/library/aa904937.aspx"> slim reader/writer lock</a>. And if you tried to enter a slim reader/writer lock during process termination and found yourself waiting for the current owner to release it, <a href="http://www.bluebytesoftware.com/blog/2006/11/19/VistaSRWLockAcquiresDuringShutdown.aspx"> you ended up waiting forever</a> since the current owner was terminated by an earlier phase of process termination. The sentence “<a href="http://blogs.msdn.com/b/oldnewthing/archive/2007/05/03/2383346.aspx">As for the home-grown stuff, well, you’re on your own</a>” applies here. Even though the slim reader/writer lock functions are exported from <code>kernel32.dll</code>, they don’t have any special kernel powers with respect to process termination. From the standpoint of process termination, they may as well be some home-grown synchronization primitive.</p>
<p> In Windows 7, the kernel folks decided to bring slim reader/writer locks into the fold of <i>objects which are electrified during process termination</i>. Starting in Windows 7, if you attempt to acquire a slim reader/writer lock during process termination, and the lock cannot be immediately acquired, then the process is forcibly terminated. </p>


</body>
<body style=max-width:80ch;margin:auto>
<h1 class="entry-title" style="margin-bottom:15px;">What does -1.#IND mean?: A survey of how the Visual C runtime library prints special floating point values</h1>  <!-- .entry-meta -->

<p>As <a href="http://www.bing.com/search?q=What+Every+Computer+Scientist+Should+Know+About+Floating+Point+Arithmetic"> every computer scientist knows</a>, the IEEE floating point format reserves a number of representations for infinity and non-numeric values (collectively known as NaN, short for not a number). If you try to print one of these special values with the Visual C runtime library, you will get a corresponding special result:</p>
<table border="1" style="border-collapse: collapse">
<tr>
<th>Output</th>
<th>Meaning</th>
</tr>
<tr>
<td><tt>1#INF<tt></tt></tt></td>
<td>Positive infinity</td>
</tr>
<tr>
<td><tt>-1#INF<tt></tt></tt></td>
<td>Negative infinity</td>
</tr>
<tr>
<td><tt>1#SNAN<tt></tt></tt></td>
<td>Positive signaling NaN</td>
</tr>
<tr>
<td><tt>-1#SNAN<tt></tt></tt></td>
<td>Negative signaling NaN</td>
</tr>
<tr>
<td><tt>1#QNAN<tt></tt></tt></td>
<td>Positive quiet NaN</td>
</tr>
<tr>
<td><tt>-1#QNAN<tt></tt></tt></td>
<td>Negative quiet NaN</td>
</tr>
<tr>
<td><tt>1#IND<tt></tt></tt></td>
<td>Positive indefinite NaN</td>
</tr>
<tr>
<td><tt>-1#IND<tt></tt></tt></td>
<td>Negative indefinite NaN</td>
</tr>
</table>
<p> Positive and negative infinity are generated by arithmetic overflow, or when the mathematical result of an operation is infinite, such as taking the logarithm of positive zero. (Don’t forget that IEEE floating point supports both positive and negative zero.) For math nerds: IEEE arithmetic uses affine infinity, <a href="http://www.math.poly.edu/courses/projective_geometry/chapter_four/node2.html"> not</a> <a href="http://www.cut-the-knot.org/WhatIs/Infinity/Projective.shtml"> projective</a>, so there is no <a href="http://en.wikipedia.org/wiki/Point_at_infinity"> point at infinity</a>. </p>
<p> Signaling and quiet NaNs are not normally generated by computations (with one exception noted below), but you can explicitly create one for a floating-point type by using the <code>std::numeric_limits&lt;T&gt;</code> class, methods <code>signaling_NaN()</code> and <code>quiet_NaN()</code>. </p>
<p> Recall that there is not just one signaling and quiet NaN, but rather a whole collection of them. The C runtime does not distinguish among them when printing, however. All signaling NaNs are reported as <tt>1#SNAN</tt>, regardless of the signal bits. The C runtime does report the sign of the NaN, for what little that is worth. </p>
<p> The weird one is the <i>Indefinite NaN</i>, which is a special type of quiet NaN generated under specific conditions. If you perform an invalid arithmetic operation like add positive infinity and negative infinity, or take the square root of a negative number, then the IEEE standard requires that the result be a quiet NaN, but it doesn’t appear to specify what quiet NaN exactly. Different floating point processor manufacturers chose different paths. The term <i>Indefinite NaN</i> refers to this special quiet NaN, whatever the processor ends up choosing it to be. </p>
<p> Some floating point processors generate a quiet NaN with the signal bits clear but the sign bit set. Setting the sign bit makes the result negative, so on those processors, you will see the indefinite NaN rendered as a negative indefinite NaN. (The x86 is one of these processors.) </p>
<p> Other floating point processors generate a quiet NaN with the signal bits and the sign bit all clear. Clearing the sign bit makes the result positive, so on those processors, you will see the indefinite NaN rendered as a positive indefinite NaN. </p>
<p> In practice, the difference is not important, because either way, you have an indefinite NaN. </p>


</body>
<body style=max-width:80ch;margin:auto>
<h1 class="entry-title" style="margin-bottom:15px;">Can I throw a C++ exception from a structured exception?</h1>  <!-- .entry-meta -->

<p>A customer wanted to know if it was okay to throw a C++ exception from a structured exception. </p>
<p>They explained that they didn’t want to compile their project with <a href="https://msdn.microsoft.com/en-us/library/1deeycx5.aspx">the <code>/EHa</code> switch</a>, which instructs the compiler to use the exception-handling model that catches both asynchronous (structured) exceptions as well as synchronous (C++) exceptions. In other words, the <code>catch</code> statement will catch both explicitly thrown C++ exceptions (raised by the <code>throw</code> statement) as well as exceptions generated by the operating system, either due to notifications from the CPU (such as an access violation or divide-by-zero) or explicit calls to <code>Raise­Exception</code>. </p>
<p>The customer explained that they didn’t want to use <code>/EHa</code> because doing so significantly impairs compiler optimizations and results in larger code size. But on the other hand, they do want to catch the asynchronous (structured) exceptions. </p>
<p>So they had a fiendish plan. </p>
<p>Their fiendish plan is to install an unhandled exception filter which turns around and throws the C++ exception. That way, a structured exception will result in a standard C++ exception, but without the code generation penalties of the <code>/EHa</code> compiler option. </p>
<pre>
// This clever function is an exception filter that converts
// asynchronous exceptions (structured exception handling)
// to synchronous exceptions (C++ exceptions).

LONG WINAPI CleverConversion(
    EXCEPTION_POINTERS* ExceptionInfo)
{
    
    auto record = ExceptionInfo-&gt;ExceptionRecord;

    std::string message;
    ... build a message based on the exception code and
    other parameters ...

    throw std::exception(message.c_str());
}

int sample_function(int* p)
{
    try {
        printf("About to dereference the pointer %p\n", p);
        return *p;
    } catch (std::exception&amp; e) {
        Log(e.what());
    }
    return 0;
}

int __cdecl main(int argc, char **argv)
{
    SetUnhandledExceptionFilter(CleverConversion);

    return sample_function(nullptr);
}
</pre>
<p>Neat trick, huh? All the benefits of <code>/EHa</code> without the overhead! </p>
<p>Well, except that they found that it didn’t always work. </p>
<p>In the example above, the <code>catch</code> did catch the C++ exception, but if they took out the <code>printf</code>, then the exception was not caught. </p>
<pre>
int sample_function(int* p)
{
    try {
        return *p;
    } catch (std::exception&amp; e) {
        Log(e.what());          // exception not caught!
    }
    return 0;
}
</pre>
<p>The customer wanted to know why the second version didn’t work. </p>
<p>Actually the first version isn’t guaranteed to work either. It happens to work because the compiler must consider the possibility that the <code>printf</code> function might throw a C++ exception. The <code>printf</code> function is not marked as <code>noexcept</code>, so the possibility is in play. (Not that you’d expect it to be marked as such, seeing as it’s a C function, and C doesn’t have exceptions.) When the access violation is raised as a structured exception, the <code>Clever­Conversion</code> function turns it into a C++ exception and throws it, at which point the <code>try</code> block catches it. But the <code>try</code> block is not there for the <code>Clever­Conversion</code> exception. It’s there to catch any exceptions coming out of <code>printf</code>, and you just happened to be lucky that it caught your exception too. </p>
<p>In the second example, there is no call to <code>printf</code>, so the compiler says, “Well, nothing inside this <code>try</code> block can throw a C++ exception, so I can optimize out the <code>try/catch</code>.” You would also have observed this behavior if there were function calls inside the <code>try</code> block, if the function calls were all to functions that were marked <code>noexcept</code> or if the compiler could prove that they didn’t throw any C++ exceptions (say, because the function is inlined). </p>
<p>This answers the question, but let’s try to look at the whole story. </p>
<ol>
<li>We want to use <code>/EHa</code>.</li>
<li>But the documentation says that <code>/EHa</code>     results in less efficient code.     We want more efficient code, not less.</li>
<li>Aha, we found this trick that lets us convert     asynchronous exceptions to synchronous ones.     Now we get all the benefits of <code>/EHa</code>     without any of the costs!</li>
</ol>
<p>It looks like you found some free money on the ground, but is it really free money? </p>
<p>The customer seems to think that the <code>/EHa</code> option results in less efficient code simply because the compiler team is a bunch of jerks and secretly hates you. </p>
<p>No, that’s not why the <code>/EHa</code> option results in less efficient code. The possibility that any memory access or arithmetic operation could trigger an exception significantly impairs optimization opportunities. It means that all variables must be stable at the point memory accesses occur. </p>
<p>Consider the following code fragment: </p>
<pre>
class Reminder
{
public:
    Reminder(char* message) : m_message(message) { }
    ~Reminder() { std::cout &lt;&lt; "don't forget to "
                            &lt;&lt; m_message &lt;&lt; std::endl; }

    void UpdateMessage(char* message) { m_message = message; }

private:
    char* m_message;
};

void NonThrowingFunction() noexcept;
void DoSomethingElse(); // might throw

void sample_function()
{
    try {
        Reminder reminder("turn off the lights");
        if (NonThrowingFunction()) {
            reminder.UpdateMessage("feed the cat");
        }
        DoSomethingElse();
    } catch (std::exception&amp; e) {
        Log(e.what());
    }
}
</pre>
<p>If compiling without <code>/EHa</code>, the compiler knows that the <code>Non­Throwing­Function</code> function cannot throw a C++ exception, so it can delay the store of <code>reminder.</code><code>m_message</code> to just before the call to <code>Do­Something­Else</code>. In fact, it is like to do so because it avoids a redundant store. </p>
<p>The pseudo-code for this function might look like this: </p>
<pre>
    allocate 4 bytes in local frame for reminder

l1:
    call NonThrowingFunction
    if result is zero
        load r1 = "turn off the lights"
    else
        load r1 = "feed the cat"
    endif
    store r1 to reminder.m_message
    call DoSomethingElse
l2:
    std::cout &lt;&lt; "don't forget to "
              &lt;&lt; r1 &lt;&lt; std::endl;
l3:

    clean up local frame
    return

if exception occurs between l1 and l2
    std::cout &lt;&lt; "don't forget to "
              &lt;&lt; reminder.m_message &lt;&lt; std::endl;
    fall through

if exception occurs between l2 and l3
    if exception is std::exception
        Log(e.what())
        goto l3
    else
        continue exception search
    endif
</pre>
<p>Notice that we optimized out a redundant store by delaying the initialization of <code>reminder</code>, and we enregistered <code>reminder.</code><code>m_message</code> in the common code path. Delaying the initialization of <code>reminder</code> is not an optimization available to <code>/EHa</code> because of the possibility that <code>Non­Throwing­Function</code> might raise an asynchronous exception that gets converted to a synchronous one: </p>
<pre>
    allocate 4 bytes in local frame for reminder

<font color="blue">l0:
    // cannot delay initialization of reminder
    load r1 = "turn off the lights"
    store r1 to reminder.m_message</font>

l1:
    call NonThrowingFunction
    <font color="blue">if result is nonzero
        load r1 = "feed the cat"
        store r1 to reminder.m_message
    endif</font>
    call DoSomethingElse
l2:
    std::cout &lt;&lt; "don't forget to "
              &lt;&lt; r1 &lt;&lt; std::endl;
l3:

    clean up local frame
    return

if exception occurs between l1 and l2
    std::cout &lt;&lt; "don't forget to "
              &lt;&lt; reminder.m_message &lt;&lt; std::endl;
    fall through

<font color="blue">// and there is a new exception region</font>
if exception occurs between <font color="blue">l0 and l1</font>, or between l2 and l3
    if exception is std::exception
        Log(e.what())
        goto l3
    else
        continue exception search
    endif
</pre>
<p>The extra code is necessary in order to ensure that the <code>reminder</code> variable is in a stable state before calling <code>Non­Throwing­Function</code>. In general, if you turn on <code>/EHa</code>, the compiler must ensure that every object which is accessed outside the <code>try</code> block (either explicitly in code or implicitly via an unwind destructor) is stable in memory before performing any operation that could result in an asynchronous exception, such as accessing memory. </p>
<p>This requirement that variables be stable in memory comes at a high cost, because it not only forces redundant stores to memory, but it also prohibits various types of optimizations based on out-of-order operations. </p>
<p>The <code>Clever­Conversion</code> is basically a manual replication of what <code>/EHa</code> does, but lying to the compiler and saying, “Um, yeah, don’t worry about asynchronous exceptions.” </p>
<p>Observe what happens if an asynchronous exception occurs inside <code>Non­Throwing­Function</code> even though you compiled without the <code>/EHa</code> flag: </p>
<p>We destruct the <code>reminder</code> object, which means printing the <code>m_message</code> to <code>std::</code><code>cout</code>. But the non-<code>/EHa</code> version did not ensure that <code>reminder.</code><code>m_message</code> was stable. Indeed, if an exception occurs inside <code>Non­Throwing­Function</code>, we will try to print <code>reminder.</code><code>m_message</code> anyway, even though it is an uninitialized variable. </p>
<p>Printing an uninitialized variable is probably not what the program intended. </p>
<p>So a more complete answer to the scenario is “Yes, it is technically possible to throw a C++ exception from a structured exception handler, but doing so requires that the program be compiled with <code>/EHa</code> in order to avoid undefined behavior.” </p>
<p>And given that avoiding the <code>/EHa</code> flag was the whole purpose of the exercise, the answer to the specific scenario is, “No, this doesn’t work. Your program will behave in undefined ways.” </p>


</body>
<body style=max-width:80ch;margin:auto>
<h1 class="entry-title" style="margin-bottom:15px;">Running some UI code on a timer at a higher priority than your usual timer messages, or without coalescing</h1>  <!-- .entry-meta -->

<p>A customer wanted something similar to a Windows <code>WM_TIMER</code> timer, but they didn’t want the timer to be a low-priority message <a href="/code/can-i-force-a-wm-timer-message-to-be-generated-when-the-timer-comes-due-even-if-the-message-queue-is-not-idle"> generated on demand</a>, and they didn’t want the messages to be coalesced. Is this possible?</p>
<p>You can do this by using some other kind of timer, but using window messages to synchronize with the UI thread. In other words, treat this as a work queue where the work is generated by a non-UI timer.</p>
<p>A naïve solution would be to post a custom message each time the timer elapses:</p>
<pre>HWND g_hwnd;
PTP_TIMER g_timer = nullptr;

void CALLBACK TimerCallback(PTP_CALLBACK_INSTANCE instance,
    void* context, PTP_TIMER timer)
{
    PostMessage(g_hwnd, WM_DOSOMETHING, 0, 0);
}

// Must be called from UI thread
void StartTimer(
    FILETIME dueTime, DWORD period, DWORD window)
{
    g_timer = CreateThreadpoolTimer(TimerCallback,
        nullptr, nullptr);
    SetThreadpoolTimer(
        g_timer, &amp;dueTime, period, window);
}

// Must be called from UI thread
void StopTimer()
{
    CloseThreadpoolTimer(g_timer);
}

LRESULT CALLBACK WndProc(HWND hwnd, UINT message,
    WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
    ...
    case WM_DOSOMETHING:
        DoSomething();
        break;
    ...
    }
    return DefWindowProc(hwnd, message, wParam, lParam);
}
</pre>
<p>It’s very simple: Each time the timer fires, we post a “do something” message to the window.</p>
<p>The problem with this is that it can flood the message queue if the UI thread gets blocked for a long time for some reason. The timer keeps running, and new <code>WM_<wbr/>DO­SOMETHING</code> messages are posted into the queue, but the UI thread has stopped processing messages, so the queued messages just accumulate, and you risk overflowing the message queue.</p>
<p>Better is to use an edge-triggered message, using a technique <a href="/code/lock-free-many-producer-single-consumer-patterns-a-work-queue-of-identical-non-coalescable-events"> we saw some time ago</a>.</p>
<pre>HWND g_hwnd;
PTP_TIMER g_timer = nullptr;

// alternate: LONG g_count;
std::atomic&lt;int&gt; g_count;

void CALLBACK TimerCallback(PTP_CALLBACK_INSTANCE instance,
    void* context, PTP_TIMER timer)
{
    // alternate: InterlockedIncrement(&amp;g_count)
    if (g_count.fetch_add(1,
            std::memory_order_relaxed) == 1) {
        PostMessage(g_hwnd, WM_DOSOMETHING, 0, 0);
    }
}

LRESULT CALLBACK WndProc(HWND hwnd, UINT message,
    WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
    ...

    case WM_DOSOMETHING:
        {
            // alternate: InterlockedExchange(&amp;g_count, 0)
            int count = g_count.exchange(0,
                std::memory_order_relaxed);
            for (int i = 0; i &lt; count; i++) DoSomething();
        }
        break;
    ...
    }
    return DefWindowProc(hwnd, message, wParam, lParam);
}
</pre>
<p>This time, when the timer expires, we just increment the number of outstanding operations. If the number incremented from zero to one, then we post a message to get the UI thread to drain the work.</p>
<p>When the UI thread receives the message, it exchanges the counter back to zero and then operates on each of the operations that were outstanding. In this simple example, we just do the “something” that many times. In a real program, you would probably write a special version <code>DoSomethingN(count)</code> which is more efficient than doing <code>DoSomething()</code> <var>N</var> times.</p>
<p>Note that I’ve been glossing over the problem of what to do if <code>StopTimer()</code> is called while there are still pending operations. As-written, what happens is that the pending operations will still be performed later. If you want them to be flushed or recalled, you have a little more work to do. I’ll leave you work out the details of threadpool timers, but the idea is</p>
<ul>
<li>Stop the timer and wait for callbacks to complete.</li>
<li>Exchange the <code>g_count</code> back to zero.</li>
<li>If flushing: Perform <code>DoSomething()</code> that many times immediately.</li>
</ul>


</body>
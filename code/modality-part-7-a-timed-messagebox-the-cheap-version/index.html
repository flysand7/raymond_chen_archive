<body style=max-width:80ch;margin:auto>
<h1 class="entry-title" style="margin-bottom:15px;">Modality, part 7: A timed MessageBox, the cheap version</h1>  <!-- .entry-meta -->

<p>
<a href="http://blogs.msdn.com/oldnewthing/archive/2005/02/22/378018.aspx">
As we noted at the end of part 3</a>,
now that you know the conventions surrounding
<a href="http://msdn.microsoft.com/library/en-us/winui/WinUI/WindowsUserInterface/Windowing/Windows/WindowReference/WindowMessages/WM_QUIT.asp">
the <code>WM_QUIT</code> message</a>
 you can put them to your advantage.
</p>
<p>
The more robust you want the <code>TimedMessageBox</code> function
to be, the more work you need to do.
Here’s the cheap version,
based on the
<a href="http://support.microsoft.com/?scid=181934">
sample in the Knowledge Base</a>,
but with some additional bug fixes.
</p>
<pre>
static BOOL s_fTimedOut;
static HWND s_hwndMBOwnerEnable;
void CALLBACK
CheapMsgBoxTooLateProc(HWND hWnd, UINT uiMsg, UINT_PTR idEvent, DWORD dwTime)
{
    s_fTimedOut = TRUE;
    if (s_hwndMBOwnerEnable) EnableWindow(s_hwndMBOwnerEnable, TRUE);
    PostQuitMessage(42); // value not important
}
// Warning! Not thread-safe! See discussion.
int CheapTimedMessageBox(HWND hwndOwner, LPCTSTR ptszText,
    LPCTSTR ptszCaption, UINT uType, DWORD dwTimeout)
{
    s_fTimedOut = FALSE;
    s_hwndMBOwnerEnable = NULL;
    if (hwndOwner &amp;&amp; IsWindowEnabled(hwndOwner)) {
      s_hwndMBOwnerEnable = hwndOwner;
    }
    UINT idTimer = SetTimer(NULL, 0, dwTimeout, CheapMsgBoxTooLateProc);
    int iResult = MessageBox(hwndOwner, ptszText, ptszCaption, uType);
    if (idTimer) KillTimer(NULL, idTimer);
    if (s_fTimedOut) {			// We timed out
	MSG msg;
	// Eat the fake WM_QUIT message we generated
	PeekMessage(&amp;msg, NULL, WM_QUIT, WM_QUIT, PM_REMOVE);
	iResult = -1;
    }
    return iResult;
}
</pre>
<p>
This <code>CheapTimedMessageBox</code> function acts just like
<a href="http://msdn.microsoft.com/library/en-us/winui/winui/windowsuserinterface/windowing/dialogboxes/dialogboxreference/dialogboxfunctions/messagebox.asp">
the <code>MessageBox</code> function</a>,
except that if the user doesn’t respond
within <code>dwTimeout</code> milliseconds, we return -1.
The limitation is that only one timed message box can be active at a time.
If your program is single-threaded, this is not a serious limitation,
but if your program is multi-threaded, this will be a problem.
</p>
<p>
Do you see how it works?
</p>
<p>
The global static variable <code>s_fTimedOut</code>
tells us whether we generated
a fake <code>WM_QUIT</code> message as a result of a timeout.
When the <code>MessageBox</code> function returns, and we indeed timed out,
we use
<a href="http://msdn.microsoft.com/library/en-us/winui/WinUI/WindowsUserInterface/Windowing/MessagesandMessageQueues/MessagesandMessageQueuesReference/MessagesandMessageQueuesFunctions/PeekMessage.asp">
the <code>PeekMessage</code> function</a>
to remove the fake <code>WM_QUIT</code> message from the
queue before returning.
</p>
<p>
Note that we remove the <code>WM_QUIT</code> message only if we were the ones
who generated it.
In this way, <code>WM_QUIT</code> messages generated by other
parts of the program remain in the queue for processing by the
main message loop.
</p>
<p>
Note also that when we decide that the timeout has occurred,
we re-enable the original owner window before we cause
the message box to bail out of its message loop by posting a quit message.
Those are the rules for
<a href="http://blogs.msdn.com/oldnewthing/archive/2004/02/27/81155.aspx">
the correct order for disabling and enabling windows</a>.
</p>
<p>
Note also that we used a thread timer rather than a window timer.
That’s because we don’t own the window being passed in and therefore
don’t know what timer IDs are safe to use.  Any timer ID we pick
might happen to collide with a timer ID being used by that window,
resulting in erratic behavior.
</p>
<p>
Recall that when you pass <code>NULL</code> as the
<code>hwnd</code> parameter to
<a href="http://msdn.microsoft.com/library/en-us/winui/winui/windowsuserinterface/windowing/timers/timerreference/timerfunctions/settimer.asp">
the <code>SetTimer</code> function</a>
and also pass zero as the
<code>nIDEvent</code> parameter,
then the <code>SetTimer</code> function
creates a brand new timer, assigns it a unique ID, and returns the ID.
Most people, when they read that part of the specification for
<code>SetTimer</code>,
scratch their heads and ask themselves, “Why would
anybody want to use this?”
</p>
<p>
Well, this is one scenario where this is exactly what you want.
</p>
<p>
Next comes the job of making the function a tad more robust.
But before we do that, we’ll need two quick sidebars.</p>


</body>
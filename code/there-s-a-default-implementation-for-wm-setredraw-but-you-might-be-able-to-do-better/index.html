<body style=max-width:80ch;margin:auto>
<h1 class="entry-title" style="margin-bottom:15px;">There's a default implementation for WM_SETREDRAW, but you might be able to do better</h1>  <!-- .entry-meta -->

<p>If your window doesn’t have a handler for the <code>WM_SET­REDRAW</code> message, then <code>Def­Window­Proc</code> will give you a default implementation which suppresses <code>WM_PAINT</code> messages for your window when redraw is disabled, and re-enables <code>WM_PAINT</code> (and triggers a full repaint) when redraw is re-enabled. (This is internally accomplished by <a href="http://blogs.msdn.com/oldnewthing/archive/2007/02/22/1742084.aspx#1745732"> making the window pseudo-invisible</a>, but that’s an implementation detail you shouldn’t be concerned with.)
 Although the default implementation works fine for simple controls, more complex controls can do better, and in fact they <i>should</i> do better, because that’s sort of the point of <code>WM_SET­REDRAW</code>.
 The intended use for disabling redraw on a window is in preparation for making large numbers of changes to the window, where you don’t want to waste time updating the screen after each tiny little change. For example, if you’re going to add a hundred items to a list box, you probably want to disable redraw while adding the items so you don’t have to suffer through 100 screen refreshes when only one is enough. You’ve probably seen the programs that forget to suppress redraw when filling a large list box: The application freezes up except for a list box whose scroll bar starts out with a big thumb that slowly shrinks as the number of items increases.
 I say that this is sort of the point of <code>WM_SET­REDRAW</code> for a complex control, because if you have a simple control (like a button), there isn’t much in the way of “bulk updates” you can perform on it, so there isn’t much reason for anybody to want to disable redraw on it anyway. The types of windows for which people want to disable redraw are the types of windows that would benefit most from a custom handler.
 For example, the list view control has a custom handler for <code>WM_SET­REDRAW</code> which sets an internal <i>redraw has been disabled</i> flag. Other parts of the list view control check this flag and bypass complex screen calculations if is set. For example, when you add an item to a list view while redraw is disabled, the list view control doesn’t bother recalculating the new scroll bar position; it just sets an internal flag that says, “When redraw is re-enabled, don’t forget to recalculate the scroll bars.” If the list view is in auto-arrange, it doesn’t bother rearranging the items after each insertion or deletion; it just sets an internal flag to remember to do it when redraw is re-enabled. If you have a regional list view, it doesn’t bother recalculating the region; it just sets a flag. And when you finally re-enable drawing, it sees all the little Post-It note reminders that it left lying around and says, “Okay, let’s deal with all this stuff that I had been putting off.” That way, if you add 100 items, it doesn’t perform 99 useless scroll bar calculations, 99 useless auto-arrange repositionings, and create, compute, and then destroy 99 regions. Since some of these calculations are <i>O</i>(<i>n</i>), deferring them when redraw is disabled improves the performance of inserting <i>n</i> items from <i>O</i>(<i>n²</i>) to <i>O</i>(<i>n</i>).
 Moral of the story: If you have a control that manages a large number of sub-items, you should have a custom <code>WM_SET­REDRAW</code> handler to make bulk updates more efficient.</p>
<p> <b>Bonus chatter</b>: Note that using <a href="http://blogs.msdn.com/b/oldnewthing/archive/2007/02/21/1735472.aspx"> <code>Lock­Window­Update</code></a> as a fake version of <code>WM_SET­REDRAW</code> does not trigger these internal optimizations. Abusing <code>Lock­Window­Update</code> gets you the benefit of not repainting, but you still have to suffer through the various <i>O</i>(<i>n²</i>) calculations. </p>


</body>
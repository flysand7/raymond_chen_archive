<body style=max-width:80ch;margin:auto>
<h1 class="entry-title" style="margin-bottom:15px;">Why can't I PostMessage the WM_COPYDATA message, but I can SendMessageTimeout it with a tiny timeout?</h1>  <!-- .entry-meta -->

<p>After receiving the explanation of <a href="http://blogs.msdn.com/b/oldnewthing/archive/2011/09/15/10208975.aspx"> what happens to a sent message when <code>Send­Message­Timeout</code> reaches its timeout</a>, a customer found that the explanation raised another question: If the window manager waits until the receiving thread finishes processing the message, then why can’t you post a <code>WM_COPY­DATA</code> message? “After all, <code>Send­Message­Timeout</code> with a very short timeout isn’t all that different from <code>Post­Message</code>.”
 Actually,  <code>Send­Message­Timeout</code> with a very short timeout is completely different from <code>Post­Message</code>.
 Let’s set aside the one crucial difference that, unlike messages posted by <code>Post­Message</code>, which cannot be recalled, the <code>Send­Message­Timeout</code> function will cancel the message entirely if the receiving thread does not process messages quickly enough.
 Recall that messages posted to a queue via <code>Post­Message</code> are retrieved by the <code>Get­Message</code> function and placed in a <code>MSG</code> structure. Once that’s done, the window manager disavows any knowledge of the message. It did its job: It placed the message in the message queue and produced it when the thread requested the next message in the queue. What the program does with the message is completely up in the air. There’s no metaphysical requirement that the message be dispatched to its intended recipient. (In fact, you already know of a common case where messages are “stolen” from their intended recipients: Dialog boxes.)
 In principle, the message pump could do anything it wants to the message. Dispatch it immediately, steal the message, <a href="http://blogs.msdn.com/oldnewthing/archive/2005/04/26/412116.aspx"> throw the message away</a>, <a href="http://blogs.msdn.com/oldnewthing/archive/2008/05/23/8535427.aspx"> eat the message and post a different message</a>, even save the message in its pocket for a rainy day.
 By contrast, there’s nothing you can do to redirect inbound non-queued messages. They always go directly to the window procedure.
 The important difference from the standpoint of messages like <code>WM_COPY­DATA</code> is that with sent messages, the window manager knows when message processing is complete: When the window procedure returns. At that time, it can free the temporary buffers used to marshal the message from the sender to the recipient. If the message were posted, the window manager would never be sure.
 Suppose the message is placed in a <code>MSG</code> structure as the result of a call to <code>GetMessage</code>. Now the window manager knows that the receiving thread has the potential for taking action on the message and the buffers need to be valid. But how would it know when the buffers can be freed? “Well you can wait until the exact same parameters get passed in a <code>MSG</code> structure to the <code>Dispatch­Message</code> function.” But what if the message loop discards the message? Or what if it decides to dispatch it twice? Or what if it decides to <a href="http://msdn.microsoft.com/bb774593.aspx"> smuggle it inside another message</a>?</p>
<p> Posted messages have no guarantee of delivery nor do they provide any information as to when the message has been definitely processed, or even if it has been processed at all. If the window manager let you post a <code>WM_COPY­DATA</code> message, it would have to use its psychic powers to know when the memory can be freed. </p>


</body>
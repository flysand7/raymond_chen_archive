<body style=max-width:80ch;margin:auto>
<h1 class="entry-title" style="margin-bottom:15px;">What happens if you simply return from the thread callback passed to _beginthread and _beginthreadex?</h1>  <!-- .entry-meta -->

<p>Medinoc asks, “<a href="https://blogs.msdn.microsoft.com/oldnewthing/20170929-00/?p=97115#comment-1310746">What happens when one simply returns from the thread callback</a>? I’d suspect the code gluing between _beginthread() and its callback calls _endthread() upon return, while the code between _beginthreadex() and its callback calls _endthreadex() instead?” </p>
<p>Yup, that’s exactly it. If your thread callback function returns, then <code>_begin­thread</code> calls <code>_end­thread</code> on your behalf, and then <code>_begin­thread­ex</code> calls <code>_end­thread­ex</code> on your behalf. The value passed to <code>_end­thread­ex</code> is the return value of your thread callback function. </p>
<p>In response to the remark “beginthread() initializes the CRT,” Cesar asked, “<a href="https://blogs.msdn.microsoft.com/oldnewthing/20170929-00/?p=97115#comment-1310785">Which CRT</a>? A process can have more than one CRT, and the thread function can even call functions from several different C runtimes.” </p>
<p>The <code>_begin­thread</code> function initializes the CRT it belongs to. What other choice does it have? It’s not like <code>msvcr80!</code><code>_beginthread</code> knows how to initialize the data used by <code>msvcr90.dll</code>. If you call <code>msvcr80!</code><code>_beginthread</code>, then the new thread is initialized for the <code>msvcr80</code> runtime, since that’s the only one it knows about. </p>
<p>If the thread function calls into multiple C runtimes, then that’s its decision. If it calls into a C runtime that hasn’t been initialized for that thread, then what happens next depends on the behavior of that C runtime. For quite some time now, Microsoft’s C runtimes <a href="https://blogs.msdn.microsoft.com/oldnewthing/20170929-00/?p=97115#comment-1310795">are self-initializing</a>, meaning that the first time you call into them on a thread, they will initialize themselves on the spot. And they will also auto-uninitialize themselves when the thread exits. </p>
<p>Wait, if the C runtime initializes itself on demand and auto-uninitializes, then why bother with <code>_beginthread</code> at all? </p>
<p>Well, the functions are still around because they predated the initialize-on-demand and auto-uninitialize behavior. And they do guarantee that the C runtime will be initialized for the new thread. (If not, then the functions return failure.) If you go for the initialize-on-demand case, and the C runtime cannot initialize itself, then something interesting happens. </p>
<ul>
<li>    Some functions will handle the case where the C runtime failed     to initialize in some way.     for example,     <code>_tempnam</code> and <code>strerror</code>     will return <code>NULL</code> to report a failure.     (Sometimes this failure mode is documented; sometimes it isn’t.)     Other functions will fall back to a static buffer     instead of a per-thread buffer. </li>
<li>    Other functions will exit the process with the error message     “<tt>R6016 - not enough space for thread data</tt>.” </li>
</ul>
<p>But as Harry Johnston noted, “In practice very few applications will survive running out of memory anyway.” </p>
<p>Joshua Shaeffer asks, “<a href="https://blogs.msdn.microsoft.com/oldnewthing/20170929-00/?p=97115#comment-1310825">Instead of automatically closing the handle, how about automatically never opening the handle</a>?” </p>
<p>Not sure what Joshua is trying to say here, because the C runtime didn’t open the handle. The handle was created by the operating system and returned by the <code>Create­Thread</code> function. So the C runtime really doesn’t have a choice. The handle gets opened as part of the thread-creation process. All it can do is decide what to do with the handle once it is given one. </p>


</body>
<body style=max-width:80ch;margin:auto>
<h1 class="entry-title" style="margin-bottom:15px;">Why don't I use any class libraries in my sample code?</h1>  <!-- .entry-meta -->

<p>As a general rule, I avoid using any class libraries in my sample code. This isn’t because I’m opposed to class libraries, but rather because I don’t want to narrow my audience to “people who use MFC” (to choose one popular class library). If I were to start using MFC for all of my samples, I’d probably lose all the people who don’t use MFC.
 “Oh, but those people can just translate the MFC code into whatever class library they use.”
 Well, sure, they could do that, but first they would have to learn MFC. I wouldn’t be talking about <code>HWND</code>s and <code>HDC</code>s any more but rather <code>CWnd</code>s and <code>CDC</code>s. I would write “Add this to your <code>OnDropEx</code> handler”, and all the non-MFC people would say, “What are you talking about? I’m not using MFC. What is the Win32 equivalent to <code>OnDropEx</code>?” (Suppose my article on <a href="http://blogs.msdn.com/oldnewthing/archive/2004/04/23/118893.aspx"> using accessibility to read the text under the mouse cursor</a> were titled “How to use MFC to retrieve text under the mouse cursor.” Would you have read it?)
 “Well, fine, don’t use MFC, but still it wouldn’t kill you to use a smart pointer library.”
 But which one? There’s MFC’s <code>CIP</code>, ATL’s <code>CComPtr</code>, STL^H^H^Hthe C++ standard library’s <code>auto_ptr</code>, the Microsoft compiler’s built-in <code>_com_ptr_t</code> (which you get automatically if you use the nonstandard <code>#import</code> directive), and boost’s grab bag of smart pointer classes <code>scoped_ptr</code>, <code>shared_ptr</code>, <code>weak_ptr</code>, <code>intrusive_ptr</code>… And they all behave differently. Sometimes subtly incompatibly. For example, MFC’s <code>CIP::CreateObject</code> method uses <code>CLSCTX_INPROC_SERVER</code>, whereas ATL’s <code>CComPtr::CreateInstance</code> method uses <code>CLSCTX_ALL</code>. When you’re chasing down a nasty COM marshalling problem, these tiny details matter, and if you’re an ATL programmer looking at MFC code, these tiny details are also something you’re going to miss simply due to lack of familiarity. (And woe unto you if your preferred language is VB or C# or some other popular non-C++ language. Now you have double the translation work ahead of you.)
 Instead of hiding the subtleties behind a class library, I put them right out on the table. Those of you who have a favorite class library can convert the boring error-prone plain C++ code into your beautiful class library.
 In fact, I almost expect you to do it.</p>
<p> (On a related note, some people are horrified at the rather dense code presentation I use here. I don’t write code like that in real life; I’d be just as horrified as you if I saw that code in a real program. I just use that style here because of the nature of the medium. A great way to lose people’s interest is to make them plow through 100 lines of boring code before they reach the good stuff.) </p>


</body>
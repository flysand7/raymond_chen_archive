<body style=max-width:80ch;margin:auto>
<h1 class="entry-title" style="margin-bottom:15px;">How can I recognize whether two handles refer to the same underlying file?</h1>  <!-- .entry-meta -->

<p>Last time, we learned <a href="/code/how-can-i-recognize-file-systems-that-don-t-support-64-bit-unique-file-identifiers" title="How can I recognize file systems that don't support 64-bit unique file identifiers?"> how to recognize file systems that don’t support 64-bit unique file identifiers</a>. But what do you do want to detect whether two handles refer to the same underlying file, and the file system won’t give you 64-bit unique file identifiers?</p>
<p>The first step is to compare the volume serial numbers. If they are different, then stop. The files belong to different volumes.</p>
<p>If the volume serial numbers match, then use the <code>Get­File­Information­By­Handle­Ex</code> function and ask for the <code>File­Id­Info</code>. This will give you the 128-bit file identifier. If you can get the 128-bit file identifier, then compare them. (NTFS uses 64-bit file identifiers, but it will return them as a 128-bit value if you ask for one.)</p>
<p>If the volume doesn’t support 128-bit file identifiers, then maybe it’s an older file system that doesn’t understand the “Please give me the 128-bit file identifier” function, so try again with the <code>Get­File­Information­By­Handle</code> and compare the 64-bit file identifiers, provided they aren’t zero or <code>0xFFFFFFFF`FFFFFFFF</code>.</p>
<p>If the volume doesn’t support 64-bit identifiers either, then the situation is getting kind of desperate. My colleague Malcolm Smith suggests calling <code>Get­Final­Path­Name­By­Handle</code> with <code>FILE_<wbr/>NAME_<wbr/>NORMALIZED</code> to try to get the file names into some sort of sane state, and then comparing the names.</p>
<p>This last step isn’t foolproof, because it will be faked out by hard links, but it’s probably the best you can do under the circumstances. Let’s hope that the remote file systems which don’t support unique identifiers don’t support hard links either.</p>
<p><b>Bonus chatter</b>: The SMB protocol (also known as CIFS) can get into a situation where a single share maps to multiple file systems, which means that the unique identifier is itself just an approximation. If two underlying file systems both use the same unique identifier for different files, then the unique identifier sent over the network via SMB will not actually be unique. But it’s trying the best it can under the circumstances.¹</p>
<p>¹ This also explains why you might not see the <code>FILE_<wbr/>SUPPORTS_<wbr/>OPEN_<wbr/>BY_<wbr/>FILE_<wbr/>ID</code> flag on remote volumes. If the underlying volume is multiplexing multiple underlying file systems, then it won’t be able to redeem those file IDs for files, since it doesn’t know which file system each ID came from. (I guess it could just try them all, but that would defeat the purpose of striping the storage.)</p>


</body>
<body style=max-width:80ch;margin:auto>
<h1 class="entry-title" style="margin-bottom:15px;">After importing a TLB, how do I convert from one type of <code>_com_ptr_t</code> to another?</h1>  <!-- .entry-meta -->

<p>The Microsoft C++ compiler has <a href="https://docs.microsoft.com/en-us/cpp/preprocessor/hash-import-directive-cpp?view=msvc-160"> this weird feature called <code>#import</code></a>. You give it a type library (TLB) file, and it converts the type library into a C++ header file that exposes the types in the type library in a form of bunch of smart pointer types.</p>
<p>The documentation on how to uses these autogenerated smart pointers is <a href="https://docs.microsoft.com/en-us/cpp/cpp/compiler-com-support?view=msvc-160"> kind of sparse</a>. One thing it neglects to mention is how to convert one kind of <code>_com_ptr_t</code> to another. Suppose you have an <code>IWidgetPtr</code> (representing an <code>IWidget</code>) and you want to get the <code>IToggleSwitchPtr</code> interface from it.</p>
<p>Well, we see that <a href="https://docs.microsoft.com/en-us/cpp/cpp/com-ptr-t-queryinterface?view=msvc-160"> there is a <code>QueryInterface</code> method</a>, but it appears to produce raw pointers, not fancy <code>_com_ptr_t</code> pointers.</p>
<p>Aha, but we can ask for the raw pointer version of a <code>_com_ptr_t</code>: <a href="https://docs.microsoft.com/en-us/cpp/cpp/com-ptr-t-extractors?view=msvc-160"> Use the <code>&amp;</code> operator</a>.</p>
<pre>void FlipToggleSwitch(IWidgetPtr widget)
{
    IToggleSwitchPtr switch;
    HRESULT hr = widget.QueryInterface(__uuidof(switch), &amp;switch);
    if (FAILED(hr)) _com_raise_error(hr);
    switch.Flip();
}
</pre>
<p>The parameters to the <code>QueryInterface</code> can be simplified (and made less error-prone) with the help of the <code>IID_PPV_ARGS</code> macro:</p>
<pre>HRESULT hr = widget.QueryInterface(IID_PPV_ARGS(&amp;switch));
</pre>
<p>There’s another way, which is even easier, but also even more invisible: Use <a href="https://docs.microsoft.com/en-us/cpp/cpp/com-ptr-t-com-ptr-t?view=msvc-160"> the conversion constructor</a>.</p>
<pre>void FlipToggleSwitch(IWidgetPtr widget)
{
    IToggleSwitchPtr switch = widget; // conversion constructor!
    if (!switch) _com_raise_error(E_NOINTERFACE);
    switch.Flip();
}
</pre>
<p>The conversion constructor for <code>_com_ptr_t</code> lets you construct any type of <code>_com_ptr_t</code> from any other type of <code>_com_ptr_t</code>. It does so by using <code>QueryInterface</code> to get from one interface to the other. If the source is empty (wraps a <code>nullptr</code>) or if the query fails with <code>E_<wbr/>NO­INTERFACE</code>, then the constructed object is empty. If the query fails with any other error, then a <code>_com_error</code> exception is thrown.¹</p>
<p>This conversion operator is not marked <code>explicit</code>, so it can be implicitly invoked. This makes it super-convenient, but also super-eager to stick its nose in places it might not belong.</p>
<pre>void SetInvertedPolarity(IWidgetPtr widget);

void PrepareGadget(IGadgetPtr gadget)
{
    SetInvertedPolarity(gadget); // compiles!
}
</pre>
<p>We are passing the wrong kind of smart pointer to <code>Set­Inverted­Polarity</code>, but it compiles anyway! The compiler automatically converts the <code>IGadgetPtr</code> to an <code>IWidgetPtr</code> in order to pass it to <code>Set­Inverted­Polarity</code>. This is great if gadgets are deluxe versions of widgets, and you expect the conversion to succeed. This is not so great if you didn’t mean to treat the gadget as a widget, and the attempt to call <code>Set­Inverted­Polarity</code> was really a mistake. Depending on how the <code>Set­Inverted­Polarity</code> function works, it may throw an exception or even crash on a null pointer if you give it a null widget. The super-eager conversion constructor led you into a trap.</p>
<p>The inner workings of the <code>_com_ptr_t</code> can be found in the header file <code>comip.h</code>.</p>
<p>¹ If you set a custom COM error handler, then the custom error handler is called.</p>


</body>
<body style=max-width:80ch;margin:auto>
<h1 class="entry-title" style="margin-bottom:15px;">Parsing ETL traces yourself, part 2: The EventLogReader</h1>  <!-- .entry-meta -->

<p>The CLR <code>System.<wbr/>Diagnostics.<wbr/>Eventing.<wbr/>Reader</code> namespace contains classes for parsing classic ETL events. You create an <code>Event­Log­Reader</code> object, giving it the path to the ETL file, and then call <code>Read­Event</code> to extract the next event from the event log.</p>
<p>Here’s a simple program that parses an event log looking for start and stop events from a specific provider and event ID, and calculating the net time:</p>
<pre>using System;
using System.Diagnostics.Eventing.Reader;

class Program
{
  static readonly Guid MyProviderId = new Guid("...");
  const int beginId = 3141;
  const int endId = 3142;

  static public void Main(string[] args)
  {
    var filename = args[0];
    using (var log = new EventLogReader(filename, PathType.FilePath)) {
      string currentScenario = string.Empty;
      DateTime beginTime = DateTime.MinValue;
      TimeSpan totalDuration = TimeSpan.Zero;

      EventLogRecord data;
      while ((data = (EventLogRecord)log.ReadEvent()) != null) {
        if (data.ProviderId == MyProviderId) {
          if (data.Id == beginId) {
            if (beginTime != DateTime.MinValue) {
              throw new Exception("Overlapping events not supported");
            }
            currentScenario = (string)data.Properties[0].Value;
            beginTime = data.TimeCreated.Value;
          }
          else if (data.Id == endId) {
            if (beginTime != DateTime.MinValue) {
              if (currentScenario != (string)data.Properties[0].Value) {
                throw new Exception("Unsupported event sequence");
              }
              var duration = data.TimeCreated.Value - beginTime;
              System.Console.WriteLine($"{currentScenario},{duration}");
              totalDuration += duration;
              beginTime = DateTime.MinValue;
            }
          }
        }
      }
      System.Console.WriteLine($"Total,{totalDuration}");
    }
  }
}
</pre>
<p>We start by opening an <code>Event­Log­Reader</code> on our event log file. The <code>Event­Log­Reader</code> can connect to an active event log, but we’re using it here for offline analysis.</p>
<p>The <code>currentScenario</code> variable remembers the name of the current scenario being tracked.</p>
<p>The <code>beginTime</code> variable remembers when the current begin/end pair began. It is <code>MinValue</code> if nothing is being tracked.</p>
<p>The <code>totalDuration</code> variable accumulates the total time consumed by our begin/end pairs so far.</p>
<p>We pull events from the event log by calling <code>Read­Event</code>. We check if the event was generated by our provider. We could have checked the <code>ProviderName</code> property, but I’m going for <code>ProviderId</code> because it avoid case-sensitivity questions, ensures uniqueness in the face of somebody else coincidentally choosing the same name, and appeals to me because I like to think comparing two <code>Guid</code> objects is faster than comparing two strings.</p>
<p>Once we verify that the event belongs to our provider, we check the event IDs. If it’s our <i>begin</i> event, then we remember the event timestamp and the scenario name, which is a string provided as the first (and only) event payload.</p>
<p>There are methods and properties on the <code>Event­Log­Record</code> that let you learn about the type of payload attached to the event, but I’m just hard-coding specific knowledge of the way my provider generates the events. This is common when doing event processing. After all, you generated the event. You should know what’s in it.</p>
<p>I add a little defensive check that there are not two <i>begin</i> events in a row. This is a hole in my processing: If there are two <i>begin</i> events in a row, then they should both be tracked, and the corresponding <i>end</i> events should be matched up against the <i>begin</i> events. This is a quick-and-dirty program, so I just complain if overlapping events are discovered, so I know that I need to go back and add support for that.¹</p>
<p>If we get an <i>end</i> event, we check if there is active sequence, and if so, verify that the <i>end</i> event matches the <i>begin</i>.¹ Assuming everything passes, we print the elapsed time for that sequence, and accumulate it for final reporting.</p>
<p>Note that we do not complain if we see an <i>end</i> event without a <i>begin</i>. This can happen if the trace began while a sequence was already in progress.</p>
<p>When all the events are done, we print the cumulative time.</p>
<p>The <code>Event­Log­Reader</code> is a wrapper around the native functions in the <code>winevt.h</code> header file, like <code>Evt­Open­Session</code> and <code>Evt­Next</code>. It’s handy, but only if you are interested in class for reading classic manifested events. It doesn’t understand the ad-hoc events generated by <a href="https://docs.microsoft.com/windows/win32/tracelogging/trace-logging-portal"> TraceLogging</a>. The native header file for decoding TraceLogging events is <code>tdh.h</code>, but the <code>Event­Log­Reader</code> doesn’t use it.</p>
<p>Oh no, what are we going to do?</p>
<p>Relief arrives next time.</p>
<p>¹ It’s important to check for these cases, even if you don’t support them, because you may encounter a trace that includes overlapping events, and if you didn’t check for that case, the program would generate incorrect results and cause you to draw the wrong conclusions. Bad data is worse than no data.</p>


</body>
<body style=max-width:80ch;margin:auto>
<h1 class="entry-title" style="margin-bottom:15px;">A closer look at the complexity analysis of finding the k’th smallest element in two sorted arrays</h1>  <!-- .entry-meta -->

<p>Given two sorted arrays of the same length, with unique elements, find the <var>k</var>th smallest element in the combined collection. One solution involves the <a href="http://typeocaml.com/2017/10/19/pearl-no-4-double-binary-search/">double binary search</a>. I’ll let you go read the article to see how it works. I’m here to dissect the complexity analysis. </p>
<blockquote class="q"><p>Since every time we remove ¼ elements, the complexity is <span title="order of 2 times log N"><var>O</var>(2*log(<var>N</var>))</span>, <i>i.e.</i>, <span title="order of log N"><var>O</var>(log(<var>N</var>))</span>. </p></blockquote>
<p>Okay, that was pretty glib. How did we get there? </p>
<p>If an algorithm reduces the problem to a smaller problem that is half the size, then the number of reduction steps needed to reduce the problem to size 1 is <span title="ceiling of binary logarithm of N">⌈lg <var>N</var>⌉</span>. More generally, if you have an algorithm where the ratio of the size of the next iteration to the size of the current iteration is <var>r</var>, then the number of reduction steps is <span title="ceiling of log base 1 over r, of N">⌈log<sub><var>1/r</var></sub> N⌉</span>. </p>
<p>In the above example, the ratio is <var>r</var> = ¾, so the number of reduction steps is <span title="ceiling of log base four thirds of N">⌈log<sub>4/3</sub> <var>N</var>⌉</span>. We can <a href="https://en.wikipedia.org/wiki/Logarithm#Change_of_base">change the logarithm to base 2</a> to arrive at <span title="ceiling of binary logarithm of N, divided by binary logarithm of four thirds">⌈(lg <var>N</var>)÷(lg (4/3))⌉</span> ≈ <span title="ceiling of two point four times binary logarithm of N">⌈2.4 × lg <var>N</var>⌉</span>. </p>
<p>This is not the same as <span title="two times binary logarithm of N">2 × lg <var>N</var></span> given in the original article. My guess is that the original article calculated the conversion factor incorrectly as <span title="binary logarithm of 4">lg 4</span> = 2. </p>
<p>But since this is all for order of magnitude calculations, an error in the constant factor is forgiven because order of magnitude ignores constant factors. </p>
<p>But wait, does the formula even apply in the first place? </p>
<p>The formula applies if the reduced problem is the same as the original problem, but with a smaller size. In the case under consideration, the starting point was two equal-sized arrays, but when we’re done, we have two unequal-sized arrays: One of the arrays shrunk in half, but the other stayed the same size. </p>
<p>We used the wrong formula! </p>
<p>Consider the second iteration, where we have one small array and one large array. And suppose the second iteration of the algorithm decides to throw away half of the smaller array. We did not throw away a quarter of the elements. We threw away half of the smaller array, which is one third of the total number of elements, which means that we threw away only a sixth! </p>
<p>It gets worse at the third iteration: If we are unlucky and the algorithm decides to throw away half of the tiny array, we discarded only one tenth of the elements. </p>
<p>So in the worst case, we get into a case of diminishing returns, where were throw away less and less from the small array and never make a dent in the big array. Does this algorithm even guarantee termination? </p>
<p>In mathematics, sometimes the way to solve a problem is to convert it to a harder problem, and then solve the harder problem. In this case, the harder problem is “Given two sorted arrays of <i>possibly-unequal length</i>, with unique elements, find the <var>k</var>th smallest element in the combined collection.” </p>
<p>Let <span title="f of n comma m"><var>f</var>(<var>n</var>, <var>m</var>)</span> represent the number of reduction steps needed to solve the problem, where <var>n</var> and <var>m</var> are the lengths of the two arrays. If you decide to throw away half of the first array, then the number of remaining steps is <span title="f of n over 2 comma m"><var>f</var>(½<var>n</var>, <var>m</var>)</span>. Similarly, if you decide to throw away half of the second array, then the number of remaining steps is <span title="f of n comma m over 2"><var>f</var>(<var>n</var>, ½<var>m</var>)</span>. You now have the recursion <span title="f of n comma m equals 1 plus the max of the value of f of n over 2 comma m or the value of f of n comma m over 2"><var>f</var>(<var>n</var>, <var>m</var>) = 1 + max(<var>f</var>(½<var>n</var>, <var>m</var>),         <var>f</var>(<var>n</var>, ½<var>m</var>))</span>. </p>
<p>The solution to this recursion is <span title="f of n comma m equals the ceiling of the binary logarithm of n plus the ceiling of the binary logarithm of m"><var>f</var>(<var>n</var>, <var>m</var>) = ⌈lg <var>n</var>⌉ +  ⌈lg <var>m</var>⌉</span>. </p>
<p>You can think of the problem this way: You have two arrays, and based on the algorithm, you cut one in half or you cut the other in half, until both arrays are cut down to just one element. It takes <span title="the ceiling of the binary logarithm of n">⌈lg <var>n</var>⌉</span> cuts to reduce the first array and <span title="the ceiling of the binary logarithm of m">⌈lg <var>m</var>⌉</span> cuts to reduce the second array. The algorithm tells you which piece to cut next, but regardless of what order the algorithm gives, the total number of cuts is the same. </p>
<p>In the original problem, <span title="n equals m equals half of capital N"><var>n</var> = <var>m</var> = ½<var>N</var></span>. Therefore, the number of reduction steps is <span title="the ceiling of the binary logarithm of half of capital N plus the ceiling of the binary logarithm of half of capital N which equals two less than twice the ceiling of the binary logarithm of capital N">⌈lg ½<var>N</var>⌉ +  ⌈lg ½<var>N</var>⌉ = 2⌈lg ½<var>N</var>⌉ = 2⌈lg <var>N</var>⌉ – 2</span>, which is <span title="order of log capital N"><var>O</var>(lg <var>N</var>)</span>. </p>
<p>So the answer given in the article was off by two. This doesn’t make any difference when calculating order of magnitude, but it was interesting that the incorrect calculation was so close to the correct one. </p>


</body>
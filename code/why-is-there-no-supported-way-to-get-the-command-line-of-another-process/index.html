<body style=max-width:80ch;margin:auto>
<h1 class="entry-title" style="margin-bottom:15px;">Why is there no supported way to get the command line of another process?</h1>  <!-- .entry-meta -->

<p>Commenter Francisco Moraes wonders <a href="http://blogs.msdn.com/oldnewthing/pages/407234.aspx#540069"> whether there is a supported way of getting the command line of another process</a>. Although there are certainly <a href="http://blogs.msdn.com/mithuns/archive/2006/02/18/534893.aspx"> unsupported ways of doing it</a> or <a href="http://blogs.msdn.com/danielvl/archive/2007/04/30/how-to-find-a-process-command-line-using-kernel-debugger.aspx"> ways that work with the assistance of a debugger</a>, there’s nothing that is supported for programmatic access to another process’s command line, at least nothing provided by the kernel. (The WMI folks have come up with <a href="http://msdn2.microsoft.com/en-us/library/aa394372.aspx"> Win32_Process.CommandLine</a>. I have no idea how they get that. You’ll have to ask them yourself.)</p>
<p> That there isn’t is a consequence of the principle of <a href="http://blogs.msdn.com/oldnewthing/archive/2009/02/16/9425124.aspx"> not keeping track of information which you don’t need</a>. The kernel has no need to obtain the command line of another process. It takes <a href="http://blogs.msdn.com/oldnewthing/archive/2003/12/10/56028.aspx"> the command line passed to the <code>CreateProcess</code> function</a> and copies it into the address space of the process being launched, in a location where the <code>GetCommandLine</code> function can retrieve it. Once the process can access its own command line, the kernel’s responsibilities are done. </p>
<p> Since the command line is copied into the process’s address space, the process might even write to the memory that holds the command line and modify it. If that happens, then the original command line is lost forever; the only known copy got overwritten. </p>


</body>
<body style=max-width:80ch;margin:auto>
<h1 class="entry-title" style="margin-bottom:15px;">The subtleties of <code>Create­Stream­On­HGlobal</code>, part 3: Suppressing the deletion of a shared <code>HGLOBAL</code></h1>  <!-- .entry-meta -->

<p>Last time, <a href="/code/the-subtleties-of-createstreamonhglobal-part-2-suppressing-the-deletion-of-an-unknown-hglobal" title="The subtleties of Create­Stream­On­HGlobal, part 2: Suppressing the deletion of an unknown HGLOBAL"> we looked at what happens if you suppress the deletion of a <code>HGLOBAL</code> that the stream created on your behalf</a>. This time, we’ll look at what happens if you provide an explicit initial <code>HGLOBAL</code>.</p>
<p>If you provide an explicit initial <code>HGLOBAL</code> and also pass <code>fDelete­On­Release = FALSE</code>, you create a sort of shared ownership of the <code>HGLOBAL</code>. The ownership is shared in the sense that the stream won’t delete it when it’s done. But really, it’s not shared ownership. The stream will manage the <code>HGLOBAL</code> as if it owned it. It just skips the part where it frees the memory at destruction. All of the other memory management operations <i>are still in effect</i>.</p>
<p>In particular, the stream assumes that it is the only one who will lock and unlock the memory block.</p>
<p>And it’s not really sharing. It’s more like a loan: When you loan somebody a book, you don’t get to read it over their shoulder. You just have to wait until they return it, and then the book is yours again.</p>
<p>Now, if all of the operations performed on the stream are non-mutating operations, like <code>Seek</code> and <code>Read</code>, then things are pretty manageable, because the stream object won’t make any changes to the <code>HGLOBAL</code>. But things get weirder if there’s a <code>Write</code> or a <code>SetSize</code>.</p>
<p>The <code>Write</code> will update the bytes in the <code>HGLOBAL</code>, which might or might not be surprising, depending on whether you expected the memory to be read-write or read-only.</p>
<p>Far more surprising is if a <code>Write</code> extends past the end of the stream, or if a <code>SetSize</code> operation is performed. These will change the size of the stream, which means that the stream object will reallocate the <code>HGLOBAL</code> memory block. If you had performed a <code>Global­Lock</code> of your own in order to access the memory, and a reallocation is performed on the stream from another thread, then that reallocation may fail.</p>
<p>Let’s walk through the consequences.</p>
<p>One usage pattern for suppressing automatic cleanup is if you have a <code>HGLOBAL</code> representing a block of memory, and you want to create multiple streams from it, so that all the streams represent the same underlying data. You wait for all of those streams to be destroyed, and then you can free the underlying <code>HGLOBAL</code>.</p>
<p>This pattern works provided you can guarantee three things:</p>
<ol>
<li>Nobody extends the stream via <code>IStream::Write</code>.¹</li>
<li>Nobody resizes the stream via <code>IStream::SetSize</code>.</li>
<li>You know when all of the streams have been destroyed for sure.</li>
</ol>
<p>For the first two points: Each stream internally keeps track of the amount of valid data in its associated <code>HGLOBAL</code>. The amount of valid data can be less than the size of the <code>HGLOBAL</code>, thanks to allocation granularity. If one stream changes the size of the memory block, the others won’t know about it. This could mean that data written to one stream ends up not readable by another stream constructed from the same <code>HGLOBAL</code>, because the data got put beyond what the other stream believed to be the end of the data.</p>
<p>Even worse, if one stream shrinks the memory block, none of the other streams will know about this, and you will get buffer overflows.</p>
<p>Another problem is that locking the memory block can collide with a reallocation. If one of the modifications to the stream triggers a reallocation of the <code>HGLOBAL</code>, this requires that the memory block be unlocked. If any other stream object happens to be reading from the memory block at the same time, then that other stream object will possess a lock on the <code>HGLOBAL</code> and prevent the reallocation.</p>
<p>This is a race condition that causes <code>Write</code> and <code>Set­Size</code> operations to fail randomly. You’re going to have a hard time reproducing this bug, but it’ll leave you scratching your head for a long time.</p>
<p>The root cause is that the stream objects cannot coordinate their efforts because they were created independently from each other. None of them know that the <code>HGLOBAL</code> they were given is two-timing with another stream behind their back.</p>
<p>To solve this problem, don’t call <code>Create­Stream­On­HGlobal</code> multiple times with the same <code>HGLOBAL</code> memory block. Instead, call it once to create the stream, and then call <code>IStream::Clone</code> to create clones of the stream from the first stream. <code>HGLOBAL</code>-based streams that are clones of each other share the same underlying data, but they also are aware of each other, in that weird sci-fi way that clones are psychically connected to each other.</p>
<p>Okay, so you switched to using clones rather than independent streams all based on the same <code>HGLOBAL</code>.</p>
<p>The third issue is that you need to know when all of the streams have been destroyed, because that’s when you can finally clean up the <code>HGLOBAL</code>. Identifying when this has occurred may be tricky because the lifetime of any COM object can, in principle, be extended by calling <code>AddRef</code>, and you have to wait for all of those references to be <code>Release</code>d before you can clean up. Knowing when this has occurred relies on knowing the behavior of each of the components you give the streams to, and in turn, the behavior of each of the components <i>they</i> give the streams to, and so on. And woe unto you if any of those components hand the stream to a garbage-collected language, because the stream won’t be released until the next GC!²</p>
<p>If you’re not scared enough yet, next time we’ll look at the even crazier things that happen if the <code>HGLOBAL</code> you provide is fixed rather than movable. Yes, the documentation says that you need to pass a movable block, but that never stopped people from passing fixed blocks anyway.</p>
<p>¹ As noted earlier, a non-extending write modifies the underlying data for all of the streams that share the <code>HGLOBAL</code>. That may cause the other stream consumers to get confused: “I just read a byte, and then I went back to read that same byte, and it’s <i>different</i>!” This may be something the clients are not expecting.</p>
<p>² Now, even though the stream is stuck waiting for GC, it’s technically okay to steal the <code>HGLOBAL</code> out from under it, provided you are absolutely sure that the only thing that will happen to the stream is its <code>Release</code>. If any other operation occurs, it will operate on a freed <code>HGLOBAL</code>, and you have a use-after-free bug on your hands, which will manifest itself as a denial of service, information disclosure, or possibly even remote code execution. At any rate, you’re going to be scrambling a security fix. That’s not fun.</p>


</body>
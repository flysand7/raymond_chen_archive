<body style=max-width:80ch;margin:auto>
<h1 class="entry-title" style="margin-bottom:15px;">How did the invalid floating point operand exception get raised when I disabled it?</h1>  <!-- .entry-meta -->

<p>Last time, we learned about <a href="http://blogs.msdn.com/oldnewthing/archive/2008/07/02/8679191.aspx"> the dangers of uninitialized floating point variables</a> but left with a puzzle: Why wasn’t this caught during internal testing?</p>
<p> I dropped a hint when I described how <code>SNaN</code>s work: You have to ask the processor to raise an exception when it encounters a signaling NaN, and the program disabled that exception. Why was an exception being raised when it had been disabled? </p>
<p> The clue to the cause was that the customer that was encountering the crash reported that it tended to happen after they printed a report. It turns out that <a href="http://blogs.msdn.com/oldnewthing/archive/2008/07/02/8679191.aspx#8681705"> the customer’s printer driver</a> was re-enabling the <i>invalid operand</i> exception in its <code>DLL_PROCESS_ATTACH</code> handler. Since the exception was enabled, the <code>SNaN</code> exception, which was previously masked, was now live, and it crashed the program. </p>
<p> I’ve also seen DLLs change the floating point rounding state in their <code>DLL_PROCESS_ATTACH</code> handler. This behavior can be traced back to <a href="http://blogs.msdn.com/oldnewthing/archive/2008/07/02/8679191.aspx#8681805"> old versions of the C runtime library</a> which reset the floating point state as part of their <code>DLL_PROCESS_ATTACH</code>; this behavior was corrected as long ago as 2002 (possibly even earlier; I don’t know for sure). Obviously that printer driver was even older. Good luck convincing the vendor to fix a bug in a driver for a printer they most likely don’t even manufacture any more. If anything, they’ll probably just treat it <a href="http://blogs.msdn.com/oldnewthing/archive/2003/12/19/44644.aspx"> as incentive for you to buy a new printer</a>. </p>
<p> When you load external code into your process, you implicitly trust that the code won’t screw you up. This is just another example of how a DLL can inadvertently screw you up. </p>
<p> <b>Sidebar</b> </p>
<p> One might argue that the <code>LoadLibrary</code> function should save the floating point state before loading a library and restore it afterwards. This is an easy suggestion to make in retrospect. Writing software would be so much easier if people would just extend the courtesy of coming up with a comprehensive list of “bugs applications will have that you should protect against” <i>before</i> you design the platform. That way, when a new class of application bugs is found, and they say “You should’ve protected against this!”, you can point to the list and say, “Nuh, uh, you didn’t put it on the list. You had your chance.” </p>
<p> As a mental exercise for yourself: Come up with a list of “all the bugs that the <code>LoadLibrary</code> function should protect against” and <a href="http://blogs.msdn.com/oldnewthing/archive/2008/01/24/7213752.aspx"> how the <code>LoadLibrary</code> function would go about doing it</a>. </p>


</body>
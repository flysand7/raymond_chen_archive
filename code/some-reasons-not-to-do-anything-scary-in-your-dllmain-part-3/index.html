<body style=max-width:80ch;margin:auto>
<h1 class="entry-title" style="margin-bottom:15px;">Some reasons not to do anything scary in your DllMain, part 3</h1>  <!-- .entry-meta -->

<p>In the same week, the shell team was asked to investigate two failures.
 The first one was a deadlock in Explorer. The participating threads look like this:</p>
<ul>
<li>Thread 1 called <code>Free­Library</code> on a shell extension     as part of normal     <code>Co­Free­Unused­Libraries</code> processing.     That DLL called <code>Ole­Uninitialize</code>     from its <code>Dll­Main</code> function.     This thread blocked because the COM lock was held by thread 2. </li>
<li>Thread 2 called <code>Co­Create­Instance</code>,     and COM tried to load the DLL which handles the object,     but the thread blocked because the loader lock was held     by thread 1. </li>
</ul>
<p> The shell extension caused this problem because it ignored the rule against calling shell and COM functions from the <code>Dll­Main</code> entry point, as specifically called out in the <code>Dll­Main</code> documentation as examples of functions that should not be called.
 The authors of this shell extension may never have caught this problem in their internal testing (or if they did they didn’t understand what it meant) because hitting this deadlock requires that a race window be hit: The shell extension DLL needs to be unloaded on one thread at the exact same moment another thread is inside the COM global lock trying to load another DLL.
 Meanwhile, another failure was traced back to a DLL calling <code>Co­Initialize</code> from their <code>Dll­Main</code>. This extra COM initialization count means that when the thread called <code>Co­Uninitialize</code> thinking that it was uninitializing COM, it actually merely decremented the count to 1. The code then proceeded to do things that are not allowed in a single-threaded apartment, believing that it had already torn down the apartment. But the secret <code>Co­Initialize</code> performed by the shell extension violated that assumption. Result: A thread that stopped responding to messages.
 The authors of both of these shell extensions seemed be calling <code>Co­Uninitialize</code>/<code>Ole­Uninitialize</code> in order to cancel out a <code>Co­Initialize</code>/<code>Ole­Initialize</code> which they performed in their <code>DLL_PROCESS_ATTACH</code>. This is fundamentally unsound not only because of the general rule of not calling COM functions inside <code>Dll­Main</code> but also because OLE initialization is a per-thread state, whereas <a href="http://blogs.msdn.com/b/oldnewthing/archive/2009/06/26/9804500.aspx"> the thread that gets the <code>DLL_PROCESS_DETACH</code> notification is not necessarily the one that receives the <code>DLL_PROCESS_ATTACH</code> notification</a>. 
 It so happens that in the second case, the DLL in question was a shell copy hook, and the hang was occuring not in Explorer but in an application which was using <code>SH­File­Operation</code> to delete some files. We could at least advise the application authors to pass the <code>FOFX_NO­COPY­HOOKS</code> flag to <code>IFile­Operation::Set­Operation­Flags</code> to prevent copy hooks from being loaded.</p>
<p> <b>Previous articles in this series</b>: <a href="http://blogs.msdn.com/b/oldnewthing/archive/2004/01/27/63401.aspx"> Part 1</a>, <a href="http://blogs.msdn.com/b/oldnewthing/archive/2004/01/28/63880.aspx"> Part 2</a>. </p>


</body>
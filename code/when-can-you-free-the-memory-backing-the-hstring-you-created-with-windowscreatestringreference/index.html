<body style=max-width:80ch;margin:auto>
<h1 class="entry-title" style="margin-bottom:15px;">When can you free the memory backing the HSTRING you created with WindowsCreateStringReference?</h1>  <!-- .entry-meta -->

<p>A little while back, I posted <a href="https://blogs.msdn.microsoft.com/oldnewthing/20160615-00/?p=93675">my complete guide to HSTRING semantics</a> (a rip-off of <a href="https://blogs.msdn.microsoft.com/ericlippert/2003/09/12/erics-complete-guide-to-bstr-semantics/">Eric’s complete guide to BSTR semantics</a>). A discussion of security descriptor lifetime somehow triggered the question “<a href="https://devblogs.microsoft.com/oldnewthing/#comment-1249765">When can you free the memory backing the <code>HSTRING</code> you created with <code>Windows­Create­String­Reference</code></a>?” </p>
<p>You can free the memory backing the <code>HSTRING</code> after you destroy the <code>HSTRING</code>, and since this is a fast-pass string, you destroy the <code>HSTRING</code> by simply abandoning it. Therefore, you can free the memory when you know that nobody should have a copy of the fast-pass <code>HSTRING</code> handle any more. </p>
<p>(For the purpose of terminology, I’m going to say that you have a “copy” of an <code>HSTRING</code> handle if you merely copied the <code>HSTRING</code> handle. E.g., <code>HSTRING copy = hstr;</code> On the other hand, I’m going to say that you have a “duplicate” of an <code>HSTRING</code> if you passed it to <code>Windows­Duplicate­String</code>.) </p>
<p>Okay, so how do you know that nobody has a copy of the fast-pass <code>HSTRING</code> handle any more? </p>
<p>Recall the rules for <code>HSTRING</code>s: If a function is passed an <code>HSTRING</code> and it wants to save the <code>HSTRING</code> for future use, it must use <code>Windows­Duplicate­String</code> to increment the reference count on the string (and possibly convert it from fast-pass to standard). Therefore, if you pass the <code>HSTRING</code> to another function, you know that there are no copies of that <code>HSTRING</code> handle when the function returns, because creating a copy is not allowed. The only place where a literal copy of the <code>HSTRING</code> handle is allowed is in the function that created it, and therefore you know when there are no more copies of the <code>HSTRING</code> handle because all of the copies belong to you. </p>
<p>The question sort of acknowledges this rule, but notes, “All it takes is one bug somewhere in all of WinRT where someone forgets to duplicate a input string if they need said string later after the function has returned.” </p>
<p>That’s true. But it’s true of C-style string pointers, too! If you pass a C-style string to another function, and that other function wants to retain the string, it’s going to need to call <code>strdup</code> or some other string duplication function so it can have its own private copy of the string. The value received as a function parameter is not valid once the function returns; if you need to use it after the function returns, you need to duplicate the string. </p>
<p>Similarly, if you receive a COM interface pointer, and you want to continue using it after the function returns, you need to call <code>IUnknown::AddRef</code> to increase the reference count on the interface, corresponding to the copy of the pointer you retained. When you’re done with the pointer, you call <code>IUnknown::Release</code>. </p>
<p>In both of these cases, you are relying on people writing code to respect these rules. All it takes is one bug somewhere in all of C where someone forgets to duplicate a input string if they need said string later after the function has returned. </p>
<p>Somehow, we’ve managed to survive working with C-style strings and with COM interface pointers with these rules. Maybe it’s with the help of things like smart pointers, or maybe it’s just through good discipline. Whatever the reason, keep up the good work. </p>
<p><b>Bonus chatter</b>: One of the rules for fast-pass strings is that you cannot change the contents of the string as long as the <code>HSTRING</code> is still in use. One commenter interpreted this to mean that string references aren’t thread-safe. Not true. Rather, the statement is a direct reflection of the fact that an <code>HSTRING</code> is immutable. If you changed the contents of the buffer that backs the <code>HSTRING</code>, then you break the immutability rule. Thread safety is not at issue here. You can use a fast-pass string from any thread you like, as long as you stop using it before your function returns. (This means that your function cannot return until the other thread has definitely finished with the fast-pass string. In practice, this is not commonly done; instead, the function uses <code>Windows­Duplicate­String</code> to create a standard <code>HSTRING</code> and passes that <code>HSTRING</code> to the other thread, which can then <code>Windows­Delete­String</code> the <code>HSTRING</code> when it is done.) </p>


</body>
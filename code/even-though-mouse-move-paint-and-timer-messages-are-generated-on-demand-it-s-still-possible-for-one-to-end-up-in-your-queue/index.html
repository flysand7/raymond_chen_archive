<body style=max-width:80ch;margin:auto>
<h1 class="entry-title" style="margin-bottom:15px;">Even though mouse-move, paint, and timer messages are generated on demand, it’s still possible for one to end up in your queue</h1>  <!-- .entry-meta -->

<p>We all know that the generated-on-demand messages like <code>WM_MOUSE­MOVE</code>, <code>WM_PAINT</code>, and <code>WM_TIMER</code> messages are not posted into the queue when the corresponding event occurs, but rather are generated by <code>Get­Message</code> or <code>Peek­Message</code> when they detect that they are about to conclude that there is no message to return and <a href="http://blogs.msdn.com/b/oldnewthing/archive/2011/12/19/10249000.aspx"> the generated-on-demand message can be returned</a>. When this happens, the window manager creates the message on the fly, posts it into the queue, and <i>hey, how about that</i>, the  <code>Get­Message</code> or <code>Peek­Message</code> function now has a message to return!</p>
<p> Note that this auto-generate can happen even though the queue is not empty, because the message filters control what messages in the queue can be returned. For example, suppose the message queue contains the following messages: </p>
<ul>
<li><code>{ hwnd1, WM_CLIP­BOARD­UPDATE }</code> </li>
<li><code>{ hwnd2, WM_LBUTTON­DOWN }</code> </li>
</ul>
<p> (Note that the above diagram is not strictly correct, because the <code>WM_LBUTTON­DOWN</code> message goes into the input queue, not the message queue, but the distinction is not important here.) </p>
<p> Suppose you now call <code>Get­Message(&amp;msg, hwnd1, WM_MOUSE­FIRST, WM_MOUSE­LAST)</code>. None of the messages in the queue satisfy the message filter: The first message meets the window filter, but the message is not in range. The second message meets the message range filter, but does not meet the window filter. The <code>Get­Message</code> function is about to give up and say “I guess I need to wait for a message,” but before it finally concedes defeat, it says, “Hang on there. I see a note that tells me that I should auto-generate a <code>WM_MOUSE­MOVE</code> message  for window <code>hwnd1</code>. And that message satisfies the message filter. I’ll generate it now!” </p>
<p> The <code>Get­Message</code> function posts the <code>{ hwnd1, WM_MOUSE­MOVE }</code> message into the queue (assigning it the current time as the timestamp), and then it says, “Hey, lookie here! A message that satisfies the filter!” It then removes the message from the queue and returns it. </p>
<p> (Note that this algorithm is conceptual. It doesn’t actually work this way internally. In particular, the window manager does not literally talk to itself, at least not out loud.) </p>
<p> Okay, so in the <code>Get­Message</code> case, even if the message conceptually goes into the queue, it comes right back out immediately, so you never actually observe it there. </p>
<p> Now repeat the exercise with the <code>Peek­Message</code> function. As before, the <code>WM_MOUSE­MOVE</code> message is posted into the queue with the current time as the timestamp. If the <code>PM_REMOVE</code> flag is passed, then the message is removed from the queue and returned, just like <code>Get­Message</code>. If the <code>PM_NO­REMOVE</code> flag is passed, then things get interesting: The message is returned but not removed from the queue. </p>
<p> You now have a <code>WM_MOUSE­MOVE</code> message <i>physically residing in the queue</i>! </p>
<p> This is the answer to the puzzle: If auto-generated messages are generated on demand, how is it possible for them to end up sitting in your message queue? </p>
<p> I recall a bug investigation from nearly two decades ago which basically boiled down to this issue: Somebody <code>PM_NO­REMOVE</code>‘d an auto-generated message and not only left it in the queue, but kept generating new ones without processing the old ones. Eventually, the message queue filled up. </p>
<p> (Note that this is also the answer to the puzzle: If <code>WM_MOUSE­MOVE</code> is generated on demand, how can it be possible to retrieve a <code>WM_MOUSE­MOVE</code> message with a timestamp different from the current time?) </p>


</body>
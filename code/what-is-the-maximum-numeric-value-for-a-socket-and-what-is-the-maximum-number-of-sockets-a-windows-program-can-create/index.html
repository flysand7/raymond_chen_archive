<body style=max-width:80ch;margin:auto>
<h1 class="entry-title" style="margin-bottom:15px;">What is the maximum numeric value for a socket, and what is the maximum number of sockets a Windows program can create?</h1>  <!-- .entry-meta -->

<p>A customer had a problem with their application that used network sockets, and they wanted to know what the maximum numeric value for a socket is. “The program uses a signed integer to hold the socket descriptor, and we found in our testing that the numeric value of <code>INVALID_SOCKET</code> is <code>0xFFFFFFFF</code>. What is the maximum value?” </p>
<p>In addition to being a vague question, it’s also a strange question, so we asked for more information about the problem they are having, in the hopes that we could both understand how the problem led them to asking the strange question, and so we could try to solve the problem. </p>
<p>The customer explained that they have a multithreaded application that uses thousands of network sockets. After running for several days, the customer observed that socket operations are failing with <code>INVALID_SOCKET</code>, and <code>WSA­Get­Last­Error</code> returns error 10038: <code>WSA­E­NOT­SOCK</code>. Since the error is intermittent, the customer is under the impression that the application may have created so many sockets that their socket numbers have exceeded the maximum legal numeric value for a socket, resulting in the <code>INVALID_SOCKET</code> error. </p>
<p>The customer added, “According to <a href="https://msdn.microsoft.com/en-us/library/ms739169(v=vs.85).aspx">this link</a>, the  maximum number of sockets that a program can use is determined at compile time by the manifest constant <code>FD_SET­SIZE</code>. However, we cannot find where this constant is defined.” </p>
<p>Okay, it’s not clear where the customer is getting the impression  that a single program cannot use more than <code>FD_SET­SIZE</code> sockets. Indeed, the documentation they referenced says quite the opposite: </p>
<blockquote class="q"><p>The maximum number of sockets that a Windows Sockets application can use is <strong>not</strong> affected by the manifest constant  FD_SETSIZE. </p></blockquote>
<p>(Emphasis mine.) </p>
<p>The documentation continues: </p>
<blockquote class="q"><p>This value defined in the Winsock2.h header file is used in constructing the <a href="https://msdn.microsoft.com/en-us/library/ms737873(v=vs.85).aspx"><b>FD_SET</b></a> structures used with <b>select</b> function. The default value in Winsock2.h is 64. </p></blockquote>
<p>Which conveniently answers the customer’s third question. </p>
<p>What the <code>FD_SET­SIZE</code> constant determines is the maximum number of sockets that can be passed in a single call to the <code>select</code> function. The total number of sockets available to a program is not limited by <code>FD_SET­SIZE</code>. </p>
<p>And as the documentation notes, you can make <code>FD_SET­SIZE</code> bigger if you need to. The point is that the <code>fd_set</code> structure is a variable-sized structure, but for compatibility with Unix programs, it is formally defined as a fixed-size structure so that programs can pass them around. </p>
<p>Okay, now back to the original question: Is it possible that the <code>socket</code> function is returning socket numbers that are not legal, and that’s why the program gets <code>INVALID_SOCKET</code> when it tries to perform socket operations on those sockets? </p>
<p>This is another case of starting with the assumption that you found an operating system bug instead of starting with the assumption that you have a bug in your program. </p>
<p>While it’s possible that there is a bug in the operating system code that does socket management that causes it to hand out invalid socket handles, a much more likely reason that your program is being told that it is using invalid socket handles is, um, because it is using invalid socket handles. </p>
<p>Verify that the handle being passed really is a valid socket. Maybe it was closed prematurely elsewhere. Maybe there is a bug in some other part of the code that is double-closing a handle (and the second time it closes, it accidentally closed your socket handle). Or maybe there is a bug in some other part of the code that is closing an uninitialized handle variable, so it’s basically rolling the dice, and most of the time it gets <code>ERROR_INVALID_HANDLE</code>, but once in a while, the uninitialized handle variable happens to contain a value that numerically matches one of your socket handles, and it ended up accidentally closing your socket. </p>
<p>If you really believe that the <code>socket</code> function is returning invalid sockets, I guess you can add debugging code that takes the return value of every call to <code>socket</code> and (if it is not <code>INVALID_SOCKET</code> indicating that the system could not create a socket) call <code>getsockopt</code> to read an arbitrary-selected socket option, and see whether it fails with  <code>WSA­E­NOT­SOCK</code>. </p>
<p>I bet it won’t. The socket handle was probably good at the point the system gave it to you. You probably did something to make it go bad. Application Verifier can help you find out what. </p>


</body>
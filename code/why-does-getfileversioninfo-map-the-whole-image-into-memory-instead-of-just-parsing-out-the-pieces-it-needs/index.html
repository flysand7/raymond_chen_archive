<body style=max-width:80ch;margin:auto>
<h1 class="entry-title" style="margin-bottom:15px;">Why does GetFileVersionInfo map the whole image into memory instead of just parsing out the pieces it needs?</h1>  <!-- .entry-meta -->

<p>Commenter acq responds (with expletive deleted), “<a href="http://blogs.msdn.com/b/oldnewthing/archive/2012/04/18/10294731.aspx#10294956">the whole file is mapped into the process’ memory only for version info that’s certainly only a few kilobytes to be read?</a>” Why not map only the parts that are needed? “<a href="http://blogs.msdn.com/b/oldnewthing/archive/2012/04/18/10294731.aspx#10294961">I don’t understand the necessity to map the whole file except that it was easier to write that code without thinking too much</a>.”
 That was exactly the reason. But not because it was to avoid thinking. It was to make things more secure.
 Back in the old days, the <code>Get­File­Version­Info</code> function did exactly what acq suggested: It parsed the executable file format manually looking for the file version information. (In other words, the original authors did it the hard way.) And it was the source of security vulnerabilities because malformed executables would cause the parser to “behave erratically”.
 This is a common problem: Parsing is hard, and parsing bugs are so common that that there’s <a href="http://blogs.msdn.com/b/sdl/archive/2007/09/20/fuzz-testing-at-microsoft-and-the-triage-process.aspx"> an entire category of software testing focused on throwing malformed data at parsers to try to trip them up</a>. The general solution for this sort of thing is to establish one “standard parser” and make everybody use that one rather than rolling their own. That way, the security efforts can be focused on making that one standard parser resilient to malformed data. Otherwise, you have <a href="http://technet.microsoft.com/en-us/magazine/2008.05.windowsconfidential.aspx"> a whole bunch of parsers all over the place</a>, and a bad guy can just shop around looking for the buggiest one.
 And it so happens that there is already a standard parser for resources. It’s known as the loader.
 The function <code>Get­File­Version­Info</code> therefore got out of the file parsing business (it wasn’t profitable anyway) and subcontracted the work to the loader.</p>
<p> <b>Pre-emptive xpclient rant</b>: “Removing the icon extractor for 16-bit DLLs was a mistake of the highest order, <a href="http://blogs.msdn.com/b/oldnewthing/archive/2012/07/17/10330362.aspx#10330756"> even worse than Component Based Servicing</a>.” </p>


</body>
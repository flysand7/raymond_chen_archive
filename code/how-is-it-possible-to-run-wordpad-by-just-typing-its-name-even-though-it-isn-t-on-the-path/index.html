<body style=max-width:80ch;margin:auto>
<h1 class="entry-title" style="margin-bottom:15px;">How is it possible to run Wordpad by just typing its name even though it isn't on the PATH?</h1>  <!-- .entry-meta -->

<p>In a comment completely unrelated to the topic, Chris Capel asks <a href="http://blogs.msdn.com/oldnewthing/archive/2008/09/19/8957959.aspx#8958938"> how Wordpad manages to run when you type its name into the Run dialog even though the command prompt can’t find it</a>? In other words, the Run dialog manages to find Wordpad even though it’s not on the <code>PATH</code>.
 Chris was unable to find anywhere I discussed this issue earlier, but it’s there, just <a href="http://blogs.msdn.com/oldnewthing/archive/2004/09/01/223936.aspx"> with Internet Explorer as the application instead of Wordpad</a>.
 It’s through the magic of <code>App Paths</code>.
 <code>App Paths</code> was introduced in Windows 95 to address the <i>path pollution</i> problem. Prior to the introduction of <code>App Paths</code>, typing the name of a program without a fully-qualified path resulted in a search along the path, and if it wasn’t found, then that was the end of that. File not found. As a result, it became common practice for programs, as part of their installation, to edit the user’s <code>AUTOEXEC.BAT</code> and add the application’s installation directory to the path.
 This had a few problems.
 First of all, editing <code>AUTOEXEC.BAT</code> is decidedlly nontrivial since batch files can have control flow logic like <code>IF</code> and <code>CALL</code> and <code>GOTO</code>. Finding the right <code>SET PATH=...</code> or <code>PATH ...</code> command is an exercise in code coverage analysis, especially since MS-DOS 6 added multi-config support to <code>CONFIG.SYS</code>, so the value of the <code>CONFIG</code> environment variable is determined at runtime. If you wanted to avoid hanging your setup program, you would have to <a href="http://blogs.msdn.com/b/ericlippert/archive/2011/02/24/never-say-never-part-two.aspx"> solve the Halting Problem</a>. (You can’t just stick at <code>PATH ...</code> at the beginning because it might get wiped out by a later <code>PATH</code> command, and you can’t just stick it at the end, because control might never reach last line of the batch file.)
 And of course, very few uninstall programs would take the time to undo the edits the installer performed, and even if they tried, there’s no guarantee that the undo would be successful, since the user (or another installer!) may have edited the <code>AUTOEXEC.BAT</code> file in the meantime.
 Even if you postulate the existence of the <i><code>AUTOEXEC.BAT</code> editing fairy</i> who magically edits your <code>AUTOEXEC.BAT</code> for you, you still run into the <code>PATH</code> length limit. The maximum length of a command line was 128 characters in MS-DOS, and if each program added itself to the <code>PATH</code>, it wouldn’t be long before the <code>PATH</code> reached its maximum length.
 <b>Pre-emptive Yuhong Bao irrelevant detail that has no effect on the story</b>: Windows 95 increased the maximum command line length, but the program being launched needed to know where to look for the “long command line”. And that didn’t help existing installers which were written against the old 128-character limit. Give them an <code>AUTOEXEC.BAT</code> with a line longer than 128 characters and you had a good chance that you’d hit a buffer overflow bug.
 On top of the difficulty of adding more directories to the <code>PATH</code>, there was the recognition that this was another case of <a href="http://blogs.msdn.com/oldnewthing/archive/2008/12/11/9193695.aspx"> using a global setting to solve a local problem</a>. It seemed wasteful to add a directory to the path just so you could find <i>one file</i>. Each additional directory on the path slowed down path sarching operations, even the ones unrelated to locating that one program.
 Enter <code>App Paths</code>. The idea here is that instead of adding your application directory to the path, you just create <a href="http://msdn.microsoft.com/ee872121.aspx"> an entry under the <code>App Paths</code> key</a> saying, “If somebody is looking to execute <code>contoso.exe</code>, I put it over here.” Instead of adding an entire directory to the path, you just add a single file, and it’s used only for application execution purposes, so it doesn’t slow down other path search operations like loading DLLs.
 (Note that <a href="http://msdn.microsoft.com/en-us/ms997545.aspx"> the old documentation on App Paths</a> has been superseded by the new documentation linked above.)
 Now that there was a place to store information associated with a particular application, you may as well use it for other stuff as well. A secondary source of path pollution came from applications which added not only the application directory to the path, but also a helper directory where the application kept its DLLs. To address this, an additional <code>Path</code> value specified which directories your application wanted to be added to the path before it was executed. Over time, additional attributes were added to the <code>App Paths</code> key, such as <a href="http://blogs.msdn.com/b/oldnewthing/archive/2011/06/30/10181645.aspx"> the <code>UseUrl</code> value</a> we saw some time ago.
 When you type the name of a program into the Run dialog (with no path), the <code>Shell­Execute</code> function checks if the name corresponds to an application registered under <code>App Paths</code>. If so, then it uses the registration information to launch the application. Hooray, applications can be run by just typing their name without requiring them to modify the global path.
 Note that this extra lookup is performed only by the <code>Sh­ellExecute</code> family of functions, so if you use <code>Create­Process</code> or <code>Search­Path</code>, you’ll still get <code>ERROR_FILE_NOT_FOUND</code>.
 Now, the intent was that the registered full path to the application is the same as the registered short name, just with a full path in front. For example, <code>wordpad.exe</code> registers the full path of <code>%ProgramFiles%\Windows NT\Accessories\WORDPAD.EXE</code>. But there’s no check that the two file names match. The Pbrush folks took advantage of this by registering an application path entry for <code>pbrush.exe</code> with a full path of <code>%SystemRoot%\System32\mspaint.exe</code>: That way, when somebody types <code>pbrush</code> into the Run dialog, they get redirected to <code>mspaint.exe</code>.</p>
<p> Sneaky. </p>


</body>
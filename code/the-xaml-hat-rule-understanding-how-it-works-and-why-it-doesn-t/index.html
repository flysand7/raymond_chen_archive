<body style=max-width:80ch;margin:auto>
<h1 class="entry-title" style="margin-bottom:15px;">The XAML hat rule: Understanding how it works and why it doesn’t</h1>  <!-- .entry-meta -->

<p>In <a href="https://docs.microsoft.com/en-us/windows/uwp/xaml-platform/x-bind-markup-extension"> the documentation for the <code>{x:Bind}</code> markup extension</a>, it says</p>
<blockquote class="q"><p>If the data source is a Dictionary or Map, then a property path can specify items in the collection by their string name. For example <b>&lt;TextBlock Text=”{x:Bind Players[‘John Smith’]}” /&gt;</b> will look for an item in the dictionary named “John Smith”. The name needs to be enclosed in quotes, and either single or double quotes can be used. <u>Hat (^) can be used to escape quotes in strings.</u> Its usually easiest to use alternate quotes from those used for the XAML attribute.</p></blockquote>
<p>The use of the hat to escape quotes is also mentioned in <a href="https://docs.microsoft.com/en-us/windows/uwp/data-binding/function-bindings"> the documentation for functions in <code>x:Bind</code></a>, which says that an acceptable function argument is a</p>
<blockquote class="q"><p>Constant string enclosed in quotes — quotes are needed to designate it as a string. <u>Hat (^) can be used to escape quotes in strings.</u></p></blockquote>
<p>Okay, we get the idea. The hat can be used to escape quotes in strings.</p>
<p>Let’s try it. Let’s say I want to bind to the result of a function call whose parameter is a three-character string: <code>a"b</code>.</p>
<pre>&lt;TextBlock Text="{x:Bind Foo("a^"b")}" /&gt;
&lt;TextBlock Text="{x:Bind Foo(^"a^"b^")}" /&gt;
</pre>
<p>These don’t work.</p>
<p>The first thing to understand is that XAML is still XML, so the markup is always parsed first by an XML parser. The XAML hat rule is applied <i>after</i> XML parsing has taken place. Therefore, the above two attempts don’t work because the result is not legal XML.</p>
<p>Let’s try again, but escaping the quotation marks from XML parsing by using the <code>&amp;quot;</code> entity.</p>
<pre>&lt;TextBlock Text="{x:Bind Foo(^&amp;quot;a^&amp;quot;b^&amp;quot;)}" /&gt;
</pre>
<p>This at least gets past the XML parser, but the XAML parser still doesn’t like it. After the XML parsing, the XAML parser sees the string</p>
<pre>{x:Bind Foo(^"a^"b^")}
</pre>
<p>The deal is that the hat is for escaping the quotation mark <i>inside</i> strings, not for escaping the quotation marks that <i>delimit</i> the string.</p>
<p>Let’s try that again.</p>
<pre>&lt;TextBlock Text="{x:Bind Foo(&amp;quot;a^&amp;quot;b&amp;quot;)}" /&gt;
</pre>
<p>After XML parsing, the string that gets passed to the XAML parser is</p>
<pre>{x:Bind Foo("a^"b")}
</pre>
<p>Now we’re using the hat in the way the hat rule intended. The hat is escaping the embedded quotation mark. You can use it to escape a double-quote embedded inside a double-quote-delimited string. or to escape a single-quote embedded inside a single-quote-delimited string.</p>
<p>Too bad it still doesn’t work. It passes the XAML parser, but you get a compiler error when it tries to compile the code generated by the XAML compiler. The specific code generation and resulting error depends on which language you’re using.</p>
<pre>// C++/WinRT code generation
            ::winrt::hstring p0 = L"a"b";

error C2001: newline in constant

// C++/CX code generation
        ::Platform::String^ p0 = "a"b";

error C2001: newline in constant
error C3688: invalid literal suffix 'b';
             literal operator or literal operator template
             'operator ""b' not found
error C2143: syntax error: missing ';' before 'Platform::String'

// C# code generation
                global::System.String p0 = "a"b";

error CS1002: ; expected
error CS1002: ; expected
error CS1010: Newline in constant
error CS1002: ; expected

' VB code generation
                Dim p0 As Global.System.String = "a"b"

error BC30648: String constants must end with a double quote.
(and a ton of cascade errors)
</pre>
<p>The hat gets the XAML parser to understand your intention: Putting a double-quote inside a string. But then the XAML code generator drops the ball and fails to escape the embedded quote when emitting it.</p>
<p>There are workarounds for this, some good and some bad.</p>
<p>Since VB and the C-derived languages disagree on how the embedded quotation mark should be escaped, you cannot write language-independent markup to work around this. A bad workaround is to write language-specific markup, which kind of breaks the principle that XAML is language-independent. It also means that if the XAML compiler ever fixed the code generation bug, their bug fix would break your code.</p>
<pre>&lt;!-- C++/WinRT, C++/CX, C# use a backslash to protect the quote --&gt;
&lt;TextBlock Text="{x:Bind Foo(&amp;quot;a\\^&amp;quot;b&amp;quot;)}"/&gt;

&lt;!-- VB doubles the quote --&gt;
&lt;TextBlock Text="{x:Bind Foo(&amp;quot;a^&amp;quot;^&amp;quot;b&amp;quot;)}"/&gt;
</pre>
<p>A better workaround is to move the troublesome string to a property that can be defined by the implementation, and the implementation can produce the embedded quotation mark in a language-dependent way.</p>
<pre>&lt;!-- add a property called AQuoteB whose value is a"b --&gt;
&lt;TextBlock Text="{x:Bind Foo(AQuoteB)}"/&gt;
</pre>
<p>All is not completely lost. At least the hat rule works for single-quotes:</p>
<pre>&lt;TextBlock Text="{x:Bind Foo('a^'b')}"/&gt;
</pre>
<p>I asked the XAML compiler team if they could fix the code generation bug, but they explained that they couldn’t because it would be a breaking change. Specifically, it would break anybody who used the bad workaround above.</p>
<p>The result of all this is that the XAML hat rule is useful only for single-quotes, not for double-quotes. The XAML hat rule lets you get a quotation mark <i>into</i> the XAML parser, but unfortunately, double-quotes can’t get back <i>out</i>.</p>


</body>
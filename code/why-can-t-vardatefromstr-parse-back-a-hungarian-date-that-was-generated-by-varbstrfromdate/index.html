<body style=max-width:80ch;margin:auto>
<h1 class="entry-title" style="margin-bottom:15px;">Why can’t VarDateFromStr parse back a Hungarian date that was generated by VarBstrFromDate?</h1>  <!-- .entry-meta -->

<p>A customer liaison reported a problem with date parsing. </p>
<p>Ugh, date parsing. </p>
<blockquote class="q">
<p>The customer is receiving date information from a scanner that they want to parse. They are using the <code>COle­Date­Time::Parse­Date­Time</code> method. The customer reports that clients in Hungary (locale 1038) are unable to parse dates. The call to <code>COle­Date­Time::Parse­Date­Time</code> fails with <code>false</code>. That method internally uses <code>Var­Date­From­Str</code>, and calling <code>Var­Date­From­Str</code> directly fails with the error <code>DISP_E_TYPE­MISMATCH</code>. </p>
<p>This problem is observed only for Hungarian. </p>
</blockquote>
<p>The customer included a demonstration program that calls methods on <code>COle­Date­Time</code>, but I’ve stripped away the wrapper below, so we can focus on the problem better. </p>
<pre>
LCID hungarian = MAKELANGID(LANG_HUNGARIAN, SUBLANG_HUNGARIAN_HUNGARY);
DATE date = ...; // something
BSTR str;
hr = VarBstrFromDate(date, hungarian, VAR_DATEVALUEONLY, &amp;str);
// The call to VarBstrFromDate succeeds and returns something like
// "2010. 12. 05". Now let's try to parse it back.

hr = VarDateFromStr(str, hungarian, VAR_DATEVALUEONLY, &amp;date);
// The attempt to parse back to a date fails with DISP_E_TYPEMISMATCH.
</pre>
<p>The customer noted that this change in behavior was relatively recent. </p>
<p>The reason is that the localization team in Windows 10 made a change to the date formats for Hungarian. In earlier versions of Windows, the call to <code>Var­Bstr­From­Date</code> produced <code>"2010.12.05"</code>. Notice the difference? </p>
<p>The date separator changed from a period to a period <i>followed by a space</i>. </p>
<p>This highlights that <a href="https://blogs.msdn.microsoft.com/shawnste/2005/04/05/culture-data-shouldnt-be-considered-stable-except-for-invariant/">culture data is not stable</a>. Any code that generates Hungarian-formatted dates will produce different results on Windows 10 compared to earlier versions of Windows. </p>
<p>Of course, one should also note that the date formatting preferences can also be customized by the user at any time, so the statement is even stronger: Any code that generates locale-sensitive formatted dates may produce different results at any time, even within a single run of the program. </p>
<p>So if your goal is to format the date as a string, with the intention of parsing it back, then you don’t want to use anything that is locale-sensitive. Instead, use a locale-insensitive format, such as ISO 8601. </p>
<p>The customer said that they were getting the information from a scanner, but it wasn’t clear where the scanner was getting it from. </p>
<p>If this is a timestamp generated by the scanner itself, then they should try to configure the scanner to generate timestamps in a locale-insensitive format. </p>
<p>If the timestamp is coming from the document being scanned, then you need to work out who is generating the document. If the document was generated by the same program that is trying to parse the result back (which the sample code seems to be suggesting), then you should fix the program that generates the document so it uses a locale-insensitive format. For human readability, you could have it generate a locale-sensitive version of the date next to the locale-invariant version. On the other hand, if the document was generated by an external source, then you may want to implement a custom parser that handles the date format that the external source uses. </p>
<p>And if you don’t know what date format the external source is using, then you’re kind of stuck. After all, a date of the form <code>12-05-2010</code> is ambiguous. It might be generated by somebody whose locale settings specify a date format of <code>MM-DD-YYYY</code>, or somebody whose locale settings specify a date format of <code>DD-MM-YYYY</code>. </p>
<p>Okay, so we’ve addressed the customer’s problem of not being able to round-trip a date-to-string-to-date conversion. But why specifically does changing the date separator from “period” to “period and space” cause <code>Var­Date­From­Str</code> to be unable to parse back a string that it generated itself? </p>
<p>The string <code>2010. 12. 05.</code> parses back like this: </p>
<ul>
<li><code>"2010"</code> is a year, no problem there.</li>
<li><code>". "</code> is a period followed by a space, no problem there.</li>
<li><code>"12"</code> is a month, no problem there.</li>
<li><code>". "</code> is a period followed by a space, no problem there.</li>
<li><code>"05"</code> is a day, no problem there.</li>
<li><code>"."</code> is a period <i>not</i> followed by a space,     which does not match the date separator, so this parse is rejected.</li>
<li>Next, a special-case rule for <code>"."</code> kicks in     and says, “Okay, well, if normal parsing rules failed,     but I see a period after a complete date,     then treat it as a time separator.”
<li>
<li>And then parsing fails, because a time separator is not allowed     due to the     <code>VAR_DATE­VALUE­ONLY</code> flag.</li>
</li></li></ul>
<p>There is also some special-case code for Hungarian trailing period, but that code path is no longer being hit, probably because of the change from a one-character date separator to a two-character date separator. </p>
<p>It turns out that the date parsing code has a ton of special-case rules for various languages. (I’m looking at you, Polish, with your genitive month forms.) </p>
<p>Now it looks like it needs a ton plus one. </p>


</body>
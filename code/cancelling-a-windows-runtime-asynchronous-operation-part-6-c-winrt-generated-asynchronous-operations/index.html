<body style=max-width:80ch;margin:auto>
<h1 class="entry-title" style="margin-bottom:15px;">Cancelling a Windows Runtime asynchronous operation, part 6: C++/WinRT-generated asynchronous operations</h1>  <!-- .entry-meta -->

<p>Last time, we learned that <a href="/code/cancelling-a-windows-runtime-asynchronous-operation-part-5-c-winrt"> C++/WinRT defers to the underlying asynchronous operation to report the cancellation in whatever way it sees fit</a>. Today, we’ll look at the case that the asynchronous operation was generated by the C++/WinRT library.</p>
<p>When you invoke the <code>Cancel()</code> on a C++/WinRT asynchronous operation, this is the code that runs:</p>
<pre>struct promise_base : ...
{
    ...

    void Cancel() noexcept
    {
        winrt::delegate&lt;&gt; cancel;
        {
            slim_lock_guard const guard(m_lock);
            if (m_status == AsyncStatus::Started)
            {
                <span style="color: blue;">m_status = AsyncStatus::Canceled;</span>
                cancel = std::move(m_cancel);
            }
        }
        if (cancel)
        {
            cancel();
        }
    }
};
</pre>
<p>The promise transitions into the <code>Canceled</code>, and if the coroutine had registered a cancellation callback, it is invoked.</p>
<p>Whenever the coroutine associated with the promise performs a <code>co_await</code>, the <code>await_transform</code> kicks in (sorry, I haven’t explained this yet, but trust me), and that’s where the C++/WinRT library gets a chance to abandon the operation:</p>
<pre>template &lt;typename Expression&gt;
Expression&amp;&amp; await_transform(Expression&amp;&amp; expression)
{
    <span style="color: blue;">if (Status() == AsyncStatus::Canceled)
    {
        throw winrt::hresult_canceled();
    }</span>
    return std::forward&lt;Expression&gt;(expression);
}
</pre>
<p>The thrown <code>hresult_canceled</code> exception is captured into the operation for later rethrowing.</p>
<p>The C++/WinRT library also checks for cancellation when the coroutine runs to completion:</p>
<pre>struct promise_type final : ...
{
    ...

    void return_void()
    {
        ...
        if (this-&gt;m_status == AsyncStatus::Started)
        {
            this-&gt;m_status = AsyncStatus::Completed;
        }
        else
        {
            WINRT_ASSERT(this-&gt;m_status == AsyncStatus::Canceled);
            <span style="color: blue;">this-&gt;m_exception = make_exception_ptr(winrt::hresult_canceled());</span>
        }
        ...
    }
};
</pre>
<p>If the operation has been cancelled, then we manufacture a fake <code>hresult_canceled</code> exception and save it in the <code>m_exception</code>.</p>
<p>So we see that whether the operation’s cancellation is detected by <code>await_transform</code> or by <code>return_void</code> (or <code>return_value</code> for coroutines that produce a value), we end up with an <code>hresult_canceled</code> exception stashed in the operation.</p>
<p>And it is this exception that comes back out when somebody asks for the result of the asynchronous activity:</p>
<pre>struct promise_type final : ...
{
    ...

    void GetResults()
    {
        ...
        if (this-&gt;m_status == AsyncStatus::Completed)
        {
            return;
        }
        <span style="color: blue;">this-&gt;rethrow_if_failed();</span>
        ...
    }

    void rethrow_if_failed() const
    {
        if (m_status == AsyncStatus::Error || m_status == AsyncStatus::Canceled)
        {
            std::rethrow_exception(m_exception);
        }
    }
};
</pre>
<p>If the operation was canceled, then we reach <code>rethrow_<wbr/>if_<wbr/>failed</code> which rethrows the captured exception, which we saw earlier is going to be an <code>hresult_<wbr/>canceled</code>.</p>
<p>But C++/WinRT is not the only source of <code>IAsync­Action</code> and <code>IAsync­Operation</code> objects. Next time, we’ll look at another major source: WRL.</p>


</body>
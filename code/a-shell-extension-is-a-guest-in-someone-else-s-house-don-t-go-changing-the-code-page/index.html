<body style=max-width:80ch;margin:auto>
<h1 class="entry-title" style="margin-bottom:15px;">A shell extension is a guest in someone else's house; don't go changing the code page</h1>  <!-- .entry-meta -->

<p>A customer reported a problem with their shell extension:</p>
<blockquote class="q"><p> We want to format a floating point number according to the user’s default locale. We do this by calling <code>snprintf</code> to convert the value from floating point to text with a period (U+002E) as the decimal separator, then using <code>Get­Number­Format</code> to apply the user’s preferred <a href="http://blogs.msdn.com/oldnewthing/archive/2006/04/17/577483.aspx"> grouping character</a>, decimal separator, etc. We found, however, that if the user is running in (say) German, we find that sometimes (but not always) the <code>snprintf</code> function follows the German locale and uses a comma (U+002C) as the decimal separator with no thousands separator. This format prevents the <code>Get­Number­Format</code> function from working, since it requires the decimal separator to be U+002E. What is the recommended way of formatting a floating point number according to the user’s locale? </p></blockquote>
<p> <a href="http://msdn.microsoft.com/bb688127.aspx#ene"> The recommended way of formatting a floating point number according to the user’s locale</a> is indeed to use a function like <code>snprintf</code> to convert it to text with U+002E as the decimal separator (and other criteria), then use <code>Get­Number­Format</code> to apply the user’s locale preferences.
 The <code>snprintf</code> function follows the C/C++ runtime locale to determine how the floating point number should be converted, and the default C runtime locale is the so-called <code>"C"</code> locale which indeed uses U+002E as the decimal separator. Since you’re getting U+002C as the decimal separator, somebody must have called <code>set­locale</code> to change the locale from <code>"C"</code> to a German locale, most likely by passing <code>""</code> as the locale, which means “follow the locale of the environment.”</p>
<blockquote class="q"><p> Our shell extension is running in Explorer. Under what conditions will Explorer call <code>set­locale(LC_NUMERIC, "")</code>? What should we do if the locale is not <code>"C"</code>? </p></blockquote>
<p> As it happens, Explorer never calls <code>set­locale</code>. It leaves the locale set to the default value of <code>"C"</code>. Therefore, the call to <code>snprintf</code> should have generated a string with U+002E as the decimal separator. Determining who was calling <code>set­locale</code> was tricky since the problem was intermittent, but after a lot of work, we found the culprit: some other shell extension loaded before the customer’s shell extension and <a href="http://blogs.msdn.com/oldnewthing/archive/2009/12/02/9931183.aspx"> decided to change the carpet</a> by calling <code>set­locale(LC_ALL, "")</code> in its <code>DLL_PROCESS_ATTACH</code>, presumably so that its calls to <code>snprintf</code> would follow the environment locale. What made catching the miscreant more difficult was that the rogue shell extension didn’t restore the locale when it was unloaded (not that that would have been the correct thing to do either), so by the time the bad locale was detected, the culprit was long gone!
 That other DLL <a href="http://blogs.msdn.com/oldnewthing/archive/2008/12/11/9193695.aspx"> used a global setting to solve a local problem</a>. Given the problem “How do I get my calls to <code>snprintf</code> to use the German locale settings?” they decided to change <i>all</i> calls to <code>snprintf</code> to use the German locale settings, even the calls that didn’t originate from the DLL itself. What if the program hosting the shell extension had done a <code>set­locale(LC_ALL, "French")</code>? Tough noogies; the rogue DLL just screwed up the host program, which wants to use French locale settings but is now being forced to use German ones. The program probably won’t notice that somebody <a href="https://www.youtube.com/watch?v=6HGKJHpQkfI"> secretly replaced its coffee with Folgers Crystals</a>. It’ll be a client who notices that the results are not formatted correctly. The developers of the host program, of course, won’t be able to reproduce the problem in their labs, since they don’t have the rogue shell extension, and the problem will be classified as “unsolved.”</p>
<p> What both the rogue shell extension and the original customer’s shell extension should be using is the <code>_l</code> variety of string formatting functions (in this case <code>_snprintf_l</code>, although <code>_snprintf_s_l</code> is probably better). The <code>_l</code> variety lets you pass an explicit locale which will be used to format that particular string. (You create one of these <code>_locale_t</code> objects by calling <code>_create_locale</code> with the same parameters you would have passed to <code>set­locale</code>.) Using the <code>_l</code> technique solves two problems: </p>
<ol>
<li>It lets you apply a local solution to a local problem.     The locale you specify applies only to the specific call;     the process’s default locale remains unchanged. </li>
<li>It allows you to ensure that you get the locale you want     even if the host process has set a different locale. </li>
</ol>
<p> If either the customer’s DLL or the rogue DLL had followed this principle of not using a global setting to solve a local problem, the conflict would not have arisen. </p>


</body>
<body style=max-width:80ch;margin:auto>
<h1 class="entry-title" style="margin-bottom:15px;">What is COM marshaling and how do I use it?</h1>  <!-- .entry-meta -->

<p>COM has this concept called “marshaling”, with one L. Basically, marshaling is the mechanism by which an object that is accessible to one apartment can be made accessible to another apartment. </p>
<p><b>Incomplete backgrounder on apartments</b>: In COM, an apartment is a collection of threads that are treated as equivalent from a COM standpoint. The details of apartments aren’t important for today’s discussion, so let’s assume that all the apartments in question are single-threaded apartments (STA). Single-threaded apartments, as you might guess from their name, are apartments that consist of a single thread. In this world, the concepts of thread and apartment line up one-to-one, which makes discussion easier. </p>
<p><b>Incomplete backgrounder on threading models</b>: Each COM object declares how it deals with threads. The most common cases are <i>apartment model objects</i>,¹ which can be used only on the thread that they were created on, and <i>free-threaded objects</i>, which can be used from any thread. Free-threaded objects are easier to use, but apartment model objects are much, much easier to write, since you don’t have any of that troublesome multi-threading to deal with. </p>
<p>Okay, back to marshaling. </p>
<p>Since the rules for apartment model objects is that they can be accessed only from the thread on which they were created, you need to do some extra work if you want to access them from another thread: You need to <a href="http://blogs.msdn.com/b/oldnewthing/archive/2014/10/16/10565024.aspx">hire a lackey</a>. COM calls this lackey a “proxy”. When you invoke a method on the proxy object, the call is routed back to the originating apartment, the method executes on its original apartment, and then the results are routed back to original caller. (And if any of the parameters to the method are themselves objects, then COM needs to create proxies for those objects, too!) Marshaling is a mechanism for creating proxies.² </p>
<p><b>What if I need to marshal an object to another thread (same process or different process), and I already have access to an object in the destination thread?</b> </p>
<p>The easy way to do this is to take advantage of the parenthetical remark up above: If you already have an interface pointer to an object in another apartment, you can define a marshalable interface that accepts an interface pointer. For example, if you need to pass a widget to another object, you probably already have a method on that other object called <code>IMumble::Colorize­Widget</code> that takes a widget and some other parameters. Just call the method from your originating apartment. The implementation of <code>IMumble::Colorize­Widget</code> will receive a pointer to the proxy, and it can use the proxy to access the original widget. It can event retain that pointer (with an appropriate <code>Add­Ref</code>, of course) to communicate with the original widget even after the method returns. </p>
<p>Of course, this creates a chicken-and-egg problem: In order to get my object to another apartment, I need access to an object on that apartment. In other words, once you have one object operating across apartments, you can use it to get more objects to operate across apartments. But how do you marshal the <i>first</i> object? </p>
<p><b>What if I need to marshal an object from one thread to another thread in the same process, and I don’t have a friendly object on the other thread yet?</b> </p>
<p>You can use <a href="http://msdn.microsoft.com/en-us/library/dn269839%28v=vs.85%29.aspx">the <code>Ro­Get­Agile­Reference</code> function</a>. You give it an interface accessible to the current apartment, and the <code>Ro­Get­Agile­Reference</code> function returns you an <code>IAgile­Reference</code> interface pointer that figures out how to create proxies so you don’t have to. What makes the agile reference special is that it is free-threaded: You can share the pointer freely among apartments.³ To gain access to the original interface pointer, call <code>IAgile­Reference::Resolve</code>. Note, of course, that the pointer that comes out of <code>IAgile­Reference::Resolve</code> is valid only in the apartment in which you called <code>IAgile­Reference::Resolve</code>. </p>
<p>In the case of passing an object to a newly-created thread, you would do something like this: </p>
<ul>
<li>Calling thread calls     <code>Ro­Get­Agile­Reference</code>     and gets an agile reference. 
<li>Calling thread creates the background thread and passes it     the agile reference pointer, transferring to the background thread     the obligation to release the agile reference.     (If the calling thread could not create the background thread,     then it needs to release the agile reference itself     since it was unable to transfer the obligation.) 
<li>The background thread calls     <code>Co­Initialize[Ex]</code>. 
<li>The background thread takes the agile reference and calls     <code>IAgile­Reference::Resolve</code> to recover     the original object. 
<li>The background thread releases the agile reference, since it     doesn’t need it any more. </li></li></li></li></li></ul>
<p><b>What if I need to marshal an object from one process to another?</b> </p>
<p>Again, the easy way is to pass the object as a parameter to a method on an object you already have in the destination process. </p>
<p><b>But what if those mechanisms aren’t available to me?</b> </p>
<p>The <code>Ro­Get­Agile­Reference</code> function was introduced in Windows 8.1, so it may not be available to you. And maybe you don’t have an object in the destination process that you can use as a foothold. We’ll <a href="http://blogs.msdn.com/b/oldnewthing/archive/2015/10/21/10649190.aspx">look at the mechanism that operates under the covers</a> (and answer some more questions) over the next couple of days. </p>
<p>¹ This unfortunate reuse of the word <i>apartment</i> has been the source of significant confusion. A better name would have been something like <i>fixed-threaded objects</i>. </p>
<p>² Of course, this entire discussion assumes that the interface in question is marshalable. Otherwise, you get <a href="http://blogs.msdn.com/b/oldnewthing/archive/2004/12/13/281910.aspx">the mysterious <code>E_NO­INTERFACE</code></a>. </p>
<p>³ Note that I didn’t say that you can share the pointer freely among <i>threads</i>. The threads you share the pointer with must still belong to apartments. For single-threaded apartments, that means calling <code>Co­Initialize</code> or <code>Co­Initialize­Ex</code> with the <code>COINIT_APARTMENT­THREADED</code> flag. For multi-threaded apartments, this means calling <code>Co­Initialize­Ex</code> with the <code>COINIT_MULTI­THREADED</code> flag somewhere in the process.⁴ </p>
<p>⁴ Preferably, you called <code>Co­Initialize­Ex</code> with the <code>COINIT_MULTI­THREADED</code> flag on the thread itself. It is technically legal to call it from some other thread, but then <a href="http://blogs.msdn.com/b/oldnewthing/archive/2013/04/19/10412399.aspx">you’re using the implicit MTA</a>, and that has its own problems. </p>


</body>
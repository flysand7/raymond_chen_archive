<body style=max-width:80ch;margin:auto>
<h1 class="entry-title" style="margin-bottom:15px;">A process shutdown puzzle: Answers</h1>  <!-- .entry-meta -->

<p>Last week, I posed <a href="http://blogs.msdn.com/oldnewthing/archive/2009/01/29/9382123.aspx"> a process shutdown puzzle</a> in honor of National Puzzle Day. Let’s see how we did.</p>
<p> Part One asked us to explain why the <code>ThreadFunction</code> thread no longer exists. That’s easy. One of the things that happen inside <code>ExitProcess</code> is that all threads (other than the one calling <code>ExitProcess</code>) are forcibly terminated in the nastiest way possible. This happens before the <code>DLL_PROCESS_DETACH</code> notification is sent. Therefore, the code in <code>StopWorkerThread</code> that waits for the thread completion event waits forever because the <code>ThreadFunction</code> is no longer running. There is nobody around to see the shutdown event and respond by setting the completion event. </p>
<p> Okay, that was the easy part. Part Two asked us to criticize the replacement solution which replaced the completion event with a call to <code>FreeLibraryAndExitThread</code> and changed the <code>StopWorkerThread</code> function to wait for the thread handle to become signaled. This solution is also flawed. </p>
<p> Consider the case that the DLL is receiving its <code>DLL_PROCESS_DETACH</code> notification because the DLL is being unloaded by a call to <code>FreeLibrary</code>, rather than due to process termination. In that case, <code>StopWorkerThread</code> sets the shutdown event, and the <code>ThreadFunction</code> proceeds to clean up and call <code>FreeLibraryAndExitThread</code>. But one of the steps in thread shutdown is sending <code>DLL_THREAD_DETACH</code> notifications, which will not happen until the <code>DLL_PROCESS_DETACH</code> notifications are complete. The <code>WaitForSingleObject</code> waits indefinitely because it won’t complete until the thread exits, but the thread won’t exit until <code>StopWorkerThread</code> returns. Deadlock. </p>
<p> Finally, Part Three asks us to explain why the code doesn’t cause a problem in practice even though the code is flawed. The call to <code>FreeLibraryAndExitThread</code> implies that the code follows the “Worker thread retains its own reference on the DLL” model. After all, that’s why the last thing the thread does is free the library. But if that’s the case, then a call to <code>FreeLibrary</code> coming from the application won’t actually unload the DLL, because the DLL reference count is still nonzero: There is one reference still being held by the worker thread. Therefore, the DLL will never actually unload outside of process termination. All the flaws in the dynamic unload case are masked by the fact that the code never executes. </p>
<p> Led astray: Some of us mentioned that waiting on <code>ThreadHandle</code> returned immediately because the handle to a thread is automatically closed when the thread exits. This is wrong. Handles do not self-close. You have to call <code>CloseHandle</code> to close them. This is “obvious” if you apply the “imagine if the world actually worked this way” rule: Suppose thread handles were invalidated (and eligible for re-use) when a thread exited. Then how could you use a thread handle <i>at all</i>? Any time you use a thread handle, there would be an unavoidable race condition where the thread might have exited just before you used the handle. And it would be impossible to call <code>GetExitCodeThread</code> at all! (Since it only does anything interesting if you pass the handle to a thread that has exited.) </p>
<p> A handle to a thread remains valid until you close it. If the thread has exited, then a wait on the thread handle completes, but the handle is still valid <i>because if it went invalid, programming would become impossible</i>. </p>


</body>
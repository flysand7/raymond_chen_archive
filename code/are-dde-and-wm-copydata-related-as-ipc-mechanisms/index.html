<body style=max-width:80ch;margin:auto>
<h1 class="entry-title" style="margin-bottom:15px;">Are DDE and WM_COPYDATA related as IPC mechanisms?</h1>  <!-- .entry-meta -->

<p>A customer liaison asked whether DDE and the <code>WM_COPY­DATA</code> message were related as IPC mechanisms. Specifically, are they dependent on each other, or are they independent? </p>
<p>The two communications mechanisms are independent. I mean, sure, they are related in the sense that they both use window messages, but there is no cross-dependency between them. You can use one without the other, and neither depends on the other. </p>
<p>In practice,  you are likely to see one or the other, but not both. Very old programs will use DDE, because <a href="https://blogs.msdn.microsoft.com/oldnewthing/20140509-00/?p=1033">DDE was invented first</a>. Newer programs will use <code>WM_COPY­DATA</code> and ignore DDE because <a href="https://blogs.msdn.microsoft.com/oldnewthing/20070226-00/?p=27863">you are free to stop using DDE</a>. </p>
<p>The customer liaison explained that the customer has a very old suite of applications which they are trying to migrate off their Windows Server 2003¹ systems to Windows Server 2008 R2, but the programs are getting into a hung state after an extended period of use. Looking at the memory dumps (filled with many ancient components, some provided from a third party, for which they have no symbols), reveals that two of the processes appear to be stuck sending a <code>WM_COPY­DATA</code> message. The customer claims that their programs communicate with DDE, not <code>WM_COPY­DATA</code>, which led to the customer liaison asking if DDE and <code>WM_COPY­DATA</code> were somehow interdependent. </p>
<p>The two are not interdependent. They are two different ways of performing inter-process communication. Fortunately, <code>WM_COPY­DATA</code> is easier to debug than DDE because <code>WM_COPY­DATA</code> is a synchronous message. If a <code>WM_COPY­DATA</code> is stuck, you can extract the window that is the target of the message, get the thread responsible for that window, and then study that thread to see why it is not responding. </p>
<p>My guess is that the customer has existing code that has taken a lock (let’s call it Lock A), and then did something that processes inbound sent messages, say entering a message loop or sending a cross-thread message. While the thread is pumping messages or waiting for the cross-thread <code>Send­Message</code> to complete, another thread sends a <code>WM_COPY­DATA</code> message, and now the window procedure is being re-entered. The <code>WM_COPY­DATA</code> message tries to take a different lock (let’s call it Lock B), and blocks. Meanwhile, the owner of Lock B wants to take Lock A, and we now have a deadlock. Reason: Pumping messages (or sending messages between threads) while holding a lock creates a lock inversion opportunity. Inspection of the stuck stack would reveal whether any window procedure re-entrancy is active. </p>
<p>This is a timing bug that could be the sort of thing exposed by a change in OS. </p>
<p><b>Bonus trivia</b>: A colleague tells me that the <code>WM_COPY­DATA</code> message was originally added in order to support the 32-bit version of MS Mail on the initial builds of Windows NT. Obviously, other people found other uses for the message since then. </p>
<p>¹ That is not a typo. They are running on a 13-year-old operating system which exited extended support over a year ago. </p>


</body>
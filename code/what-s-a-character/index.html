<body style=max-width:80ch;margin:auto>
<h1 class="entry-title" style="margin-bottom:15px;">What('s) a character!</h1>  <!-- .entry-meta -->

<p>Norman Diamond seems to have made a side career of harping on this topic <a href="http://blogs.msdn.com/larryosterman/archive/2006/01/12/512115.aspx#512320"> on</a> <a href="http://blogs.msdn.com/junfeng/archive/2006/02/20/535875.aspx#536564"> a</a> <a href="http://blogs.msdn.com/chrsmith/archive/2006/05/08/What-would-you-like-to-see-from-Visual-Studio-and-Indigo.aspx#597659"> fairly</a> <a href="http://blogs.msdn.com/oldnewthing/archive/2006/10/17/834921.aspx#841924"> regular</a> <a href="http://blogs.msdn.com/oldnewthing/archive/2006/12/13/1275990.aspx#1280280"> basis</a>, although he never comes out and says that this is what he’s complaining about. He just assumes everybody knows. (This usually leads to confusion, as you can see from the follow-ups.)
 Back in the ANSI days, terminology was simpler. Windows operated on <code>CHAR</code>s, which are one byte in size. Buffer sizes were documented as specified in bytes, even for textual information. For example, here’s a snippet from the 16-bit documentation for the <code>GetWindowTextLength</code> function:</p>
<blockquote class="q"><p> The return value specifies the text length, in bytes, not including any null terminating character, if the function is successful. Otherwise, it is zero.  </p></blockquote>
<p> The use of the term <i>byte</i> throughout permitted the term <i>character</i> to be used for other purposes, and in 16-bit Windows, the term was repurposed to represent “one or bytes which together represent one (what I will call) linguistic character.” For single-byte character sets, a linguistic character was the same as a byte, but for multi-byte character sets, a linguistic character could be one or two bytes.
 Documentation for functions that operated on linguistic characters said <i>characters</i>, and functions that operated on <code>CHAR</code>s, said <i>bytes</i>, and everybody knew what the story was. (Mind you, even in this nostalgic era, documentation would occasionally mess up and say <i>character</i> when they really meant <i>byte</i>, but the convention was adhered to with some degree of consistentcy.)
 With the introduction of Unicode, things got ugly.
 All documentation that previously used <i>byte</i> to describe the size of textual data had to be changed to read “the size of the buffer in bytes if calling the ANSI version of the function or in <code>WCHAR</code>s if calling the Unicode version of the function.” A few years ago the Platform SDK team accepted my suggestion to adopt the less cumbersome “the size of the buffer in <code>TCHAR</code>s.” Newer documentation from the core topics of the Platform SDK tends to use this alternate formulation.
 Unfortunately, most documentation writers (and 99% of software developers, who provide the raw materials for the documentation writers) aren’t familiar with the definition of <i>character</i> that was set down back in 1983, and they tend to use the term to mean <i>storage character</i>, which is a term I invented just now to mean “a unit of storage sufficient to hold a single <code>TCHAR</code>.” (The Platform SDK uses what I consider to be the fantastically awkward term <a href="http://msdn.microsoft.com/library/en-us/intl/unicode_90hf.asp"> <i>normal character widths</i></a>.) For example, the <code>lstrlen</code> function returns the length of the string in storage characters, not linguistic characters. And any function that accepts a sized output buffer obviously specifies the size in storage characters because the alternative is nonsense: How could you pass a buffer and say “Please fill this buffer with data. Its size is five linguistic characters”? You don’t know what is going into the buffer, and a linguistic character is variable-sized, so how can you say how many linguistic characters will fit? <a href="http://blogs.msdn.com/michkap"> Michael Kaplan</a> enjoys making rather outrageous strings which result in equally outrageous sort keys. I remember one entry a while ago where he <a href="http://blogs.msdn.com/michkap/archive/2006/02/17/533929.aspx"> piled over a dozen accent marks over a single “a”</a>. That “a” plus the combining diacritics all equal one giant linguistic character. (There is a less extreme example <a href="http://blogs.msdn.com/michkap/archive/2006/06/25/646769.aspx"> here</a>, wherein he uses an “e” plus two combining diacritics to form one linguistic character.) If you wanted your buffer to really be able to hold five of these extreme linguistic characters, you certainly would need it to be bigger than <code>WCHAR buffer[5]</code>.</p>
<p> As a result, my recommendation to you, dear reader, is to enter every page of documentation with a bias towards <i>storage character</i> whenever you see the word <i>character</i>. Only if the function operates on the textual data linguistically should you even consider the possibility that the author actually meant <i>linguistic character</i>. The only functions I can think of off-hand that operate on linguistic characters are <code>CharNext</code> and <code>CharPrev</code>, <a href="http://blogs.msdn.com/michkap/archive/2005/01/30/363420.aspx"> and even then they don’t quite get it right</a>, although they at least try. </p>


</body>
<body style=max-width:80ch;margin:auto>
<h1 class="entry-title" style="margin-bottom:15px;">Multithreaded UI code may be just as hard as multithreaded non-UI code, but the consequences are different</h1>  <!-- .entry-meta -->

<p>Commenter Tim Smith claims that <a href="http://blogs.msdn.com/oldnewthing/archive/2008/04/24/8420242.aspx#8424138"> the problems with multithreaded UI code are not significantly more than plain multithreaded code</a>. While that may be true on a theoretical level, the situations are quite different in practice.
 Regardless of whether your multithreaded code does UI or not, you have to deal with race conditions, synchronization, cache coherency, priority inversion, all that mulitthreaded stuff.
 The difference is that multithreaded problems with non-UI code are often rare, relying on race conditions and other timing issues. As a result, you can often get away with a multithreaded bug, because it may shows up in practice only rarely, if ever. (On the other hand, when it does show up, it’s often impossible to diagnose.)
 If you mess up multithreaded UI code, the most common effect is a hang. The nice thing about this is that it’s easier to diagnose because everything has stopped and you can try to figure out who is waiting for what. On the other hand, the problems also occur with much more frequency.</p>
<p> So it’s true that the problems are the same, but the way they manifest themselves are very different. </p>


</body>
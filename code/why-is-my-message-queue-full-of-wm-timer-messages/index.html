<body style=max-width:80ch;margin:auto>
<h1 class="entry-title" style="margin-bottom:15px;">Why is my message queue full of WM_TIMER messages?</h1>  <!-- .entry-meta -->

<p>Dmitry wondered <a href="http://blogs.msdn.com/b/oldnewthing/archive/2013/05/23/10420741.aspx#10420954">how it’s possible for a lot of auto-generated messages to pile up in the message queue</a>. I remarked, “That’s a good question, and I didn’t provide all the information necessary to answer it. Answering it will take more than two sentences, so I will toss it onto the topic queue.” </p>
<p>One of my colleagues wrote to me and said, “Hey, could you bump up the priority of that topic? I happen to have a bug where COM calls are failing because the message queue is full. I wrote some diagnostic code to drain the message queue to see what was in it, and it was full of unprocessed <code>WM_TIMER</code> messages. There were 53 timers running at 16ms each, and the UI thread stopped processing messages for 9 seconds.” </p>
<p>Back when <a href="http://blogs.msdn.com/b/oldnewthing/archive/2013/06/05/10423678.aspx">I explained how asynchronous input worked</a>, I didn’t talk about where auto-generated messages came from. </p>
<p>If a request for a message is about to say, “Nope, no matching messages,” the window manager makes one last check: “Is there an auto-generated message that could satisfy this request?” If so, then it generates the message, and hey look, there’s a message! </p>
<p>The catch is that auto-generated messages are grouped together. For example, if you ask for any kind of mouse message, and there is an auto-generated <code>WM_MOUSE­MOVE</code> available, then the window manager will generate a <code>WM_MOUSE­MOVE</code> and then check if that matches the filter you provided. The auto-generation is done this way so that message ordering is preserved within a group. You wouldn’t want a mouse-up to be generated before the corresponding mouse-down. </p>
<p>The message groups can be see in functions like <code>Get­Queue­Status</code> and the <code>PM_QS_*</code> flags to <code>Peek­Message</code>. </p>
<p>Okay, now we’re getting closer to seeing how auto-generated messages can pile up: If you are filtering for a message, and there is an auto-generated message from the same group, but which doesn’t match your filter, then the window manager will auto-generate the message, and then go back and re-run the “Find a message” code, which sees the auto-generated message but says, “Nope, I’m not interested in that message.” </p>
<p>Another piece of the puzzle is understanding the timer group. There are two messages in the timer group. One is your friend and mine, <code>WM_TIMER</code>. The other is an undocumented internal message known as <code>WM_SYS­TIMER</code>. This is an alternate universe of timers used by the system to manage system things, like the animated concentric circles in the <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms645601(v=vs.85).aspx#_win32_Mouse_Sonar">Mouse Sonar</a> feature, deciding when to time out the system tooltips (like the one that appears when you hover over the × button), driving autorepeat when you click on the scroll bar, and blinking the caret in an edit control. </p>
<p>The final piece of the puzzle is the COM modal message loop. This is the message loop used by COM when you call a method on an STA that needs to be marshaled. COM notifies the destination thread that it needs to run some code, and then it enters a modal message loop waiting for the destination thread to reply, “Okay, I’m done. Here’s the answer.” </p>
<p>The COM message loop is a complicated beast, most likely the result of over twenty years of evolution rather than having been designed that way from the beginning. One of the things that it does is peek <code>WM_SYS­TIMER</code> messages. Another thing that it does is dispatch timer messages, provided you passed the <code>COWAIT_DISPATCH_WINDOW_MESSAGES</code> flag. </p>
<p>Okay, here comes the wild ride. </p>
<p>COM wants to process <code>WM_SYS­TIMER</code> messages, but not <code>WM_TIMER</code> messages. It therefore does a <code>Peek­Message(&amp;msg, nullptr, WM_SYS­TIMER, WM_SYS­TIMER, PM_REMOVE)</code>. If there is a <code>WM_SYS­TIMER</code> message due, then the window manager generates the <code>WM_SYS­TIMER</code> message on the fly, puts it in the queue, and the <code>Peek­Message</code> function returns it. That’s the good case. </p>
<p>Another good case is that there is neither a <code>WM_SYS­TIMER</code> message nor a <code>WM_TIMER</code> message due. In that case, the window manager generates nothing, and the <code>Peek­Message</code> function returns “Sorry, I didn’t find anything.” </p>
<p>The bad case is where there is no <code>WM_SYS­TIMER</code> message due, <i>but there is a <code>WM_TIMER</code> message due</i>. In that case, the window manager generates the <code>WM_TIMER</code> message on the fly and puts it in the queue. But the <code>Peek­Message</code> function ignores that message because it’s interested only in <code>WM_SYS­TIMER</code> messages. </p>
<p>Result: A <code>WM_TIMER</code> message got generated and dumped into the queue. </p>
<p>Every time a <code>WM_TIMER</code> comes due, another <code>WM_TIMER</code> message gets generated and added to the queue. Eventually, your queue fills up with <code>WM_TIMER</code> messages. </p>
<p>My colleague replied, “Thanks for the explanation. Of course, it’s COM, the Bermuda triangle of Win32!” </p>


</body>
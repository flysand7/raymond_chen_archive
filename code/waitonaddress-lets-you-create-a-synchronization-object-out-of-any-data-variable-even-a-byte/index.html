<body style=max-width:80ch;margin:auto>
<h1 class="entry-title" style="margin-bottom:15px;">WaitOnAddress lets you create a synchronization object out of any data variable, even a byte</h1>  <!-- .entry-meta -->

<p>The <code>Wait­On­Address</code> function is a funny little guy. It lets you create a synchronization object out of 1, 2, 4, or 8 bytes of memory. And you even control the contents of the memory, so the synchronization object costs you nothing! </p>
<p>Basically, the <code>Wait­On­Address</code> function waits for the contents of a block of memory to change. You give it a memory buffer and an “undesirable value”, and the function waits until the buffer’s contents are something different from the undesirable value. (Of course, if the memory buffer already contains something different from the undesirable value, then the function returns immediately.) </p>
<p>You can accomplish the same thing with a spinloop, but <code>Wait­On­Address</code> puts the thread into a wait state so that it doesn’t burn CPU while waiting. </p>
<p>Wow, this sounds amazing. But like they say, there’s no such thing as a free lunch. For one thing, you have to give <code>Wait­On­Address</code> a little help when you actually change the value. After you update the value atomically, you need to call either <code>Wake­By­Address­Single</code> if you want to wake up one waiting thread, or <code>Wake­By­Address­All</code> if you want to wake up all waiting threads. </p>
<p>Note that everything must stay within a single process. You cannot wait on an address in one process and wake it in another. (Not that it would make much sense anyway, seeing as processes have separate address spaces.) </p>
<p>Another wrinkle is that the <code>Wait­On­Address</code> function might return spuriously; <i>i.e.</i>, it may return even if the address being watched still contains the undesirable value. </p>
<p>Those who are familiar with condition variables are well aware of the phenomenon of the spurious wake.¹ Spurious wakes are unavoidable because the thread may be woken due to the variable’s value changing, but before the thread gets a chance to run, the value changes the back to the undesirable value. Therefore, when <code>Wait­On­Address</code> returns, you must check whether the value still has the undesirable value, and if so, you probably want to go back and wait again. </p>
<p>(The spurious wake also explains why you need to update the value atomically: If you use a non-atomic update, then another thread waiting on the address may experience a spurious wake at exactly the moment you are updating the value, and if you use a non-atomic update, that thread will see a torn value when it goes to check whether the wait was spurious.) </p>
<p>Here are some pros and cons of <code>Wait­On­Address</code> compared to, say, an event. </p>
<p>Pro: <code>Wait­On­Address</code> doesn’t need to be initialized or destroyed. You don’t have to worry about leaking memory because you forgot to destroy the synchronization object because there is nothing to destroy! </p>
<p>Pro: Like critical sections, <code>Wait­On­Address</code> does most of its work in user mode, so if you’re lucky, you can avoid kernel transitions. (Though in practice, I don’t think this buys you much, because most of the time, you probably expect <code>Wait­On­Address</code> to actually wait, which means that you’re paying for a kernel transition anyway.) </p>
<p>Con: Since there is no synchronization object, you cannot ask the threadpool to notify you when a <code>Wait­On­Address</code> is ready. More generally, you cannot perform a simultaneous wait on an address and some other synchronization object. This means for example that you can’t ask <code>Msg­Wait­For­Multiple­Objects</code> to wait for a message or on an address. </p>
<p>Con: As noted earlier, you cannot wait on an address in one process and wake it in another. If you need to synchronize between processes, then you cannot use <code>Wait­On­Address</code>. </p>
<p>Con: Internally, all of the addresses being waited on are kept in a hash table, which means that the theoretical complexity is linear in the number of pending <code>Wait­On­Address</code> calls, albeit with a low constant. This is probably not going to be a serious problem in practice because (1) it’s a lock-free hash table, and (2) you won’t have a huge number of pending <code>Wait­On­Address</code> calls, since it’s bounded by the number of threads in your process. </p>
<p>Next time, by way of demonstration, we’ll try implementing some existing synchronization concepts in terms of <code>Wait­On­Address</code>. </p>
<p>¹ Those who worked with Windows 95 device drivers may also observe a similarity between <code>Wait­On­Address</code> and Windows 95’s <code>Block­On­ID</code>, which had very similar semantics, including the phenomenon of spurious wakes. </p>


</body>
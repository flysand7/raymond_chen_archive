<body style=max-width:80ch;margin:auto>
<h1 class="entry-title" style="margin-bottom:15px;">On generating sentinel pointer values in Windows</h1>  <!-- .entry-meta -->

<p>Suppose you have a need for sentinel pointer values. Let’s say that your function operates on pointers to <code>Widget</code> objects, but you need a few special values that convey special meaning, like “There is no widget” or “Please use a default widget” or “Inherit the widget from the parent object” or “All the widgets.” </p>
<p>Well, many languages give you a sentinel pointer value up front, typically called <code>null</code> or <code>Nothing</code> or <code>nullptr</code> or something emptyish like that. If you need only one sentinel value, then that’s a pretty simple choice. </p>
<p>On the other hand, this emptyish sentinel value is a common thing that could be generat3ed by mistake. Some languages use it as the default value for pointers. And the emptyish value might come out of an earlier failed operation, like an allocation. So you might want to avoid using the emptyish value as a sentinel because it is too easy to pass by mistake. </p>
<p>If you need a small number of sentinel values, you could just allocate a few objects for the sole purpose of providing an address. Some classes in the C++ standard library do this. For example, <code>std::map</code> might allocate a sentinel value to represent <code>end()</code>. (That sentinel value serves other purposes, too.) </p>
<p>Another idea is to create a bunch of addresses for your own use and carve your sentinel values out of them. You can <code>Virtual­Alloc(MEM_RESERVE)</code> some address space, and nothing will go into that address space unless you put it there. If you reserve the address space and intentionally put nothing in it, then all the addresses in that reserved region are potentially usable as sentinels. </p>
<p>Windows itself does this for you: As part of setting up the process address space, the kernel reserves the bottom 64<a href="https://blogs.msdn.microsoft.com/oldnewthing/20090611-00/?p=17933">KB</a> of address space, so no valid objects will be allocated there. That gives you 65536 sentinel values, although one of them matches <code>nullptr</code>, so it’s 65535 <i>new</i> sentinel values. This is the technique used by the <code>MAKE­INT­RESOURCE</code> and <code>MAKE­INT­ATOM</code> macros to allow an integer to be smuggled inside a string pointer. </p>
<p>Prior to Windows 8, applications could unreserve the bottom 64KB of address space and allocate actual memory there, which created the opportunity for mass confusion. Windows 8 put a stop to that. </p>
<p>If your widget object has alignment requirements (and if it consists of anything other than raw bytes, it probably does), you can use any pointer value that does not conform to those requirements. For example, if widgets must be 4-byte aligned, then any pointer value which is not divisible by four can be used as a sentinel, since it will never match the address of a valid widget. </p>
<p>If your widget object has no alignment requirements, you could always invent one by using a declaration appropriate to your toolset, such as <code>__declspec(align(2))</code> or <code>__attribute__(aligned(2))</code> or whatever. </p>
<p>Even if your alignment requirements are only word-alignment, that gives you two billion possible 32-bit sentinel values, which is quite a lot. You can use the encoding <var>f</var>(<var>n</var>) = <var>n</var> × 2 + 1 to create a sentinel and its inverse <var>g</var>(<var>n</var>) = (<var>n</var> − 1) / 2 to convert a sentinel back to its magic number. </p>
<p>(And if you’re using 64-bit pointers, then the number of possible sentinel values is staggering.) </p>
<p><b>Exercise</b>: Critique the following suggestion: “You can pick any value greater than <code>0x80000000</code> to use as a sentinel value.” </p>


</body>
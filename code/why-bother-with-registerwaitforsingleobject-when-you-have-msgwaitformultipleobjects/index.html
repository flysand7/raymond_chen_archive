<body style=max-width:80ch;margin:auto>
<h1 class="entry-title" style="margin-bottom:15px;">Why bother with RegisterWaitForSingleObject when you have MsgWaitForMultipleObjects?</h1>  <!-- .entry-meta -->

<p>Commenter kokorozashi wonders <a href="http://blogs.msdn.com/oldnewthing/archive/2006/02/22/536920.aspx#536958"> why you should bother with <code>RegisterWaitForSingleObject</code> when you have <code>MsgWaitForMultipleObjects</code> already</a>. If you want to pump messages and wait for a kernel object, then you can change all calls to <code>PeekMessage</code>, <code>GetMessage</code>, and <code>WaitMessage</code> to replacement functions that use <code>MsgWaitForMultipleObjects</code>. Isn’t that enough? Why waste an entire thread just to wait for that object?</p>
<p> If you’re so clever that you can modify every call to <code>PeekMessage</code>, <code>GetMessage</code>, and <code>WaitMessage</code>, then more power to you. But in order to do this, you’ll have to restrict the functions you call, because all sorts of functions contain their own message loops. Do you call <code>MessageBox</code>? Or <code>DialogBox</code>? Those functions contain a modal loop. (After all, they don’t return until the user dismisses the dialog box; <i>somebody</i> has to be pumping messages because you’re not.) Indeed, you can’t even call <code>DefWindowProc</code> since that function goes into a modal loop if the user, say, grabs the caption bar and drags the window around: That drag loop happens inside <code>DefWindowProc</code>. </p>
<p> If your thread has any sort of visible UI, this sort of extreme control of all message loops is unreasonable. You have no practical choice but to have the wait happen on some other thread and either respond to the signalled object on that thread or post a notification back to the UI thread to do the work. </p>
<p> The advantage of <code>RegisterWaitForSingleObject</code> over creating your own thread for waiting is that the thread pool functions will combine multiple registered waits together on a single thread (by the power of <code>WaitForMultipleObjects</code>), so instead of costing a whole thread, it costs something closer to (but not exactly) 1/64 of a thread. </p>


</body>
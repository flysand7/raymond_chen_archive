<body style=max-width:80ch;margin:auto>
<h1 class="entry-title" style="margin-bottom:15px;">There's more to switching stacks than just loading a new stack pointer</h1>  <!-- .entry-meta -->

<p>Sometimes people <a href="http://groups.google.com/groups?selm=uxyOHzIDHHA.4024@TK2MSFTNGP04.phx.gbl"> think they can switch stacks</a> by just <a href="http://groups.google.com/groups?selm=euDyW3IDHHA.4396@TK2MSFTNGP02.phx.gbl"> loading a new value into the <code>ESP</code> register</a>. This may seem to work but in fact it doesn’t, because there is more to switching stacks than just loading a new value into <code>ESP</code>.
 On the x86, the exception chain is threaded through the stack, and the exception dispatch code verifies that the exception chain is “sane” before dispatching an exception. If you summarily yank <code>ESP</code> into a location outside the stack the operating system assigned to the thread, then the exception chain will appear to be corrupted, and once the exception dispatch code notices this, it will declare your program to be unrecoverably corrupted. It can’t even raise an exception to indicate that this has happened, even if it wanted to, because it doesn’t even know where the exception handlers are!
 There are other parts of the system that rely on the stack pointer remaining inside the correct stack. For example, the code that expands the stack on demand needs to know where the stack is and how big it can get. (And the ia64 architecture has <i>two</i> stack pointers.) If a part of the system needs to do work with those values and it notices that the real stack pointer is “in la-la land”, it will start taking drastic measures (typically by terminating the program).</p>
<p> If you want to switch stacks, use a fiber. Fibers provide a way to capture the state of a computation, which includes the instruction pointer and the stack. </p>


</body>
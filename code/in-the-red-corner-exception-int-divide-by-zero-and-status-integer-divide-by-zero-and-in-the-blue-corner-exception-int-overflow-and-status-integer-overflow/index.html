<body style=max-width:80ch;margin:auto>
<h1 class="entry-title" style="margin-bottom:15px;">In the red corner, EXCEPTION_INT_DIVIDE_BY_ZERO and STATUS_INTEGER_DIVIDE_BY_ZERO; and in the blue corner, EXCEPTION_INT_OVERFLOW and STATUS_INTEGER_OVERFLOW</h1>  <!-- .entry-meta -->

<p>The exception code <code>EXCEPTION_INT_DIVIDE_BY_ZERO</code> (and its doppelgänger <code>STATUS_INTEGER_DIVIDE_BY_ZERO</code>) is raised, naturally enough, when the denominator of an integer division is zero.
 The x86 and x64 processors also raise this exception when <a href="http://web.archive.org/web/20111128085612/http://my.opera.com/taviso/blog/show.dml/639454"> you divide <code>INT_MIN</code> by <code>-1</code></a>, or more generally, when the result of a division does not fit in the destination. The division instructions for those processors take a 2<var>N</var>-bit dividend and an <var>N</var>-bit divisor, and they produce <var>N</var>-bit quotient and remainder. Values of <var>N</var> can be 8, 16, and 32; the 64-bit processors also support 64. And the division can be signed or unsigned. Therefore, you can get this exception if you try to divide, say, 2³² by 1, using a 64-bit dividend and 32-bit divisor. The quotient is 2³², which does not fit in a 32-bit divisor.
 The Windows 95 kernel does not attempt to distinguish between division overflow and division by zero. It just converts the processor exception to <code>EXCEPTION_INT_DIVIDE_BY_ZERO</code> and calls it a day.
 The Windows NT kernel realizes that the underlying processor exception is ambiguous and tries to figure out why the division operation failed. If the divisor is zero, then the exception is reported as <code>EXCEPTION_INT_DIVIDE_BY_ZERO</code>. If the divisor is nonzero, then the exception is reported as <code>EXCEPTION_INT_OVERFLOW</code>.
 Another place that <code>EXCEPTION_INT_OVERFLOW</code> can arise from a processor exception is if an application issues the <code>INTO</code> instruction and the overflow flag is set.</p>
<p> <b>Puzzle</b>: The <code>DIV</code> and <code>IDIV</code> instructions support a divisor in memory. What happens if the memory becomes inaccessible after the processor raises the exception but before the kernel can read the value in order to check whether it is zero? What other things could go wrong? </p>


</body>
<body style=max-width:80ch;margin:auto>
<h1 class="entry-title" style="margin-bottom:15px;">Setting up private COM contexts to allow yourself to unload cleanly</h1>  <!-- .entry-meta -->

<p><a href="/none/yo-dawg-i-hear-you-like-com-apartments-so-i-put-a-com-apartment-in-your-com-apartment-so-you-can-com-apartment-while-you-com-apartment"> Last time</a>, we saw how you could use the <code>CLSID_</code><code>Context­Switcher</code> object to create a private COM context and register your object factory in that context. This allows you to disconnect all proxies to objects in that context, which is handy when circumstances such as service shutdown require you to unload a DLL prior to process termination, even though there may be outstanding references to its objects. Disconnecting the proxies forcibly releases those references, allowing you to unload.</p>
<p>This trick was originally intended for Windows NT services, but you can use it any other time you are required to unload your DLL while the host process continues to run. For example, your DLL may be a plug-in in another process, and that other process’s plug-in model requires you to unload.¹ However, your plug-in displayed some UI, and a screen reader or other assistive technology tool may have an active <code>IAccessible</code> reference to one of your UI objects. Your plug-in created that UI, showed it to the user, and destroyed it, but while it was visible, an assistive technology tool managed to get an <code>IAccessible</code> for it, and the reference remains outstanding even though the UI is no longer visible. (Assistive technology tools do a lot of caching, so the <code>IAccessible</code> is just sitting in a cache somewhere, just in case your dialog reappears.)</p>
<p>To solve this problem, you can do what the Windows NT service does: Create a private <code>CLSID_</code><code>Context­Switcher</code> in which all of your COM objects reside, and as part of your DLL’s “prepare to be unloaded” steps, you can enter the context one last time in order to call <code>Co­Disconnect­Context</code> to disconnect all the proxies.</p>
<p>Disconnecting the proxies should cause all your objects to run down, and now you can destroy the empty context, and allow your DLL to be unloaded.</p>
<p>Creating those proxies to objects in the context is trickier using this pattern because that job is now on you. With Windows NT services, they register a COM object factory, and COM will use the factory to create objects. The people requesting the creation of the object are not in the context, so the natural COM infrastructure will create the proxy automatically.</p>
<p>In our scenario, however, we aren’t registering a COM factory. Our UI object received a <code>WM_</code><code>GET­OBJECT</code> message, and it needs to produce an <code>IAccessible</code> immediately.</p>
<p>So you enter the context, create the object, but now you have to figure out how to <i>take the object with you</i> when you exit the context (transforming it from a direct reference to a proxy), so you can return it to the caller.</p>
<p>I discussed some options <a href="https://devblogs.microsoft.com/oldnewthing/20151020-00/?p=91321"> some time ago</a>. One is to use <code>Ro­Get­Agile­Reference</code> to obtain an agile reference to your <code>IAccessible</code>. You can move this agile reference freely between contexts and apartments, so you can take that out of the context, then convert it back to an <code>IAccessible</code> to return to your caller.</p>
<p>Another option is to <a href="https://devblogs.microsoft.com/oldnewthing/20151021-00/?p=91311"> marshal the interface into a stream</a> and take the stream with you out of the context, then reconstitute the interface from the stream once you’re safely outside.</p>
<p>(I suspect the first way is implemented in terms of the second way.)</p>
<p>All this time, I’ve been talking about getting into and out of this context, but never actually showing how to do it. Next time, we’ll look at the mechanics.</p>
<p>¹ The plug-in’s model may not actually <i>require</i> you to unload. After all, you can force yourself to linger by doing a bonus <code>Load­Library</code> on yourself. But you want to go along with it, just to be a good citizen. Or perhaps you want to unload so that you can update the DLL. This is handy during development, since you can go to the host process, tell it to unload the extension, then rebuild and redeploy the extension, then ask the host process to reload the extension.</p>


</body>
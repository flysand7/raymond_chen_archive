<body style=max-width:80ch;margin:auto>
<h1 class="entry-title" style="margin-bottom:15px;">AppInit_DLLs should be renamed Deadlock_Or_Crash_Randomly_DLLs</h1>  <!-- .entry-meta -->

<p>I have no idea why the window manager team added <a href="http://support.microsoft.com/kb/197571"> this feature</a> to Windows NT. It basically says, “Hi, use this key to violate all the rules known to mankind about what can legitimately be done in a <code>DllMain</code> function. Oh, and be <a href="http://www.avira.com/en/threats/section/fulldetails/id_vir/3265/tr_drop.stration.677.html"> an attractive malware attack vector</a>, too.”
 I’ve debugged a few crashes that were traced back to the <code>AppInit_DLLs</code> key. What makes them particularly fun is that the offending DLL is usually not on the stack. Rather, the fact that a foreign DLL is being loaded inside <code>USER32</code>‘s initialization code means that you’re violating the rule against calling <code>LoadLibrary</code> inside a <code>DllMain</code> function. The result of this madness is that DLLs get initialized out of order, and typically manifests itself in some DLL crashing trying to use an object (often a critical section) that it is supposed to have initialized in its <code>DLL_PROCESS_ATTACH</code> handler. It crashed because the loader got tricked into initializing DLLs out of order. The dependent DLL received its <code>DLL_PROCESS_ATTACH</code> before the prerequisite DLL.
 I end up looking at these failures because the victim DLL is often a DLL that my group is responsible for.</p>
<p> The window manager folks came to the same conclusion about <code>AppInit_DLLs</code>, and it doesn’t work any more in Windows Vista by default. (<a href="http://blogs.msdn.com/nickkramer/archive/2006/04/18/577962.aspx">Nick Kramer describes how to re-enable it</a>.) </p>


</body>
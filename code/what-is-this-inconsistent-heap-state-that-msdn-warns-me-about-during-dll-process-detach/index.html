<body style=max-width:80ch;margin:auto>
<h1 class="entry-title" style="margin-bottom:15px;">What is this inconsistent heap state that MSDN warns me about during DLL_PROCESS_DETACH?</h1>  <!-- .entry-meta -->

<p>In the MSDN documentation for the <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms682583(v=vs.85).aspx"><code>Dll­Main</code> entry point</a>, MSDN notes: </p>
<blockquote class="q"><p>When handling <b>DLL_PROCESS_DETACH</b>, a DLL should free resources such as heap memory only if the DLL is being unloaded dynamically (the <i>lpReserved</i>¹ parameter is <b>NULL</b>). If the process is terminating (the <i>lpvReserved</i> parameter is non-<b>NULL</b>), all threads in the process except the current thread either have exited already or have been explicitly terminated by a call to the <b>Exit­Process</b> function, which might leave some process resources such as heaps in an inconsistent state. In this case, it is not safe for the DLL to clean up the resources. Instead, the DLL should allow the operating system to reclaim the memory. </p></blockquote>
<p>A customer wanted to know, “What is this inconsistent heap state that MSDN is talking about here?” </p>
<p>The information is actually right there in the sentence. “… <u>explicitly terminated by a call to the <b>Exit­Process</b> function</u>, which might leave some process resources such as heaps in an inconsistent state.” </p>
<p>When you see text that says “X might lead to Y,” then when you ask “What could lead to Y?” you might consider that it is X. </p>
<blockquote class="q" style="width: 20em;float: right"><p><b>Background reading</b>: <a href="http://blogs.msdn.com/b/oldnewthing/archive/2007/05/03/2383346.aspx">Quick overview of how processes exit on Windows XP</a>, plus bonus electrification of <a href="http://blogs.msdn.com/b/oldnewthing/archive/2010/01/22/9951750.aspx">critical sections</a> and <a href="http://blogs.msdn.com/b/oldnewthing/archive/2011/10/07/10221348.aspx">slim reader/writer locks</a>. </p></blockquote>
<p>Okay, I’ll give the customer the benefit of the doubt and assume that the question was more along the lines of “Why would termination by a call to the <b>Exit­Process</b> function lead to an inconsistent state?” </p>
<p>Remember why <code>Terminate­Thread</code> is a horrible idea: It terminates the thread in the middle of whatever it is doing, not giving it a chance to restore consistency or otherwise provide for an orderly end to operations. The thread may have been in the middle of updating a data structure, which usually involves <a href="http://blogs.msdn.com/b/oldnewthing/archive/2009/11/13/9921676.aspx">perturbing an invariant, then re-establishing it</a>. If it was terminated before it could re-establish the invariant, you now have an inconsistent data structure. </p>
<p>That’s the sort of inconsistency the paragraph is talking about. If one of the threads terminated by <code>Exit­Process</code> was executing heap code at the moment it was terminated, then the heap may be inconsistent because the thread never got a chance to re-establish consistency. (The heap <a href="http://blogs.msdn.com/b/oldnewthing/archive/2012/01/06/10253727.aspx">tries to detect that this has happened</a> but all that does is transform one failure mode into another. The failure is still there.) </p>
<p>Of course, the heap isn’t the only resource that suffers from this problem. Any resource that is available to more than one thread is susceptible to this. It’s just that the heap is a very popular shared resource, so it gets an extra mention in the documentation. </p>
<p>¹ Typo. Should be <i>lpvReserved</i>. </p>


</body>
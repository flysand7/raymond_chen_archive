<body style=max-width:80ch;margin:auto>
<h1 class="entry-title" style="margin-bottom:15px;">It's fine to use fibers, but everybody has to be on board with the plan</h1>  <!-- .entry-meta -->

<p>We saw fibers a long time ago when I looked at how you can <a href="http://blogs.msdn.com/oldnewthing/archive/2004/12/31/344799.aspx"> use fibers as a form of coroutines to simplify the writing of enumerators</a>. A fiber is a handy tool, but it’s a tool with very sharp edges.
 Since <a href="http://blogs.msdn.com/oldnewthing/archive/2010/02/25/9969014.aspx"> fibers are promiscuous with threads</a>, you have to be careful when running code that cares about what thread it is running on, because that code may discover that its thread changed out from under it.
 For example, critical sections and mutexes remember which thread owns them. If you enter a critical section on a fiber, and then you unschedule the fiber, then reschedule it onto a different thread, and then you leave the critical section, your critical section will end up corrupted because you broke the rule that says that a critical section must be exited on the same thread that entered it.
 Actually, you were already in bad shape once you unscheduled the fiber while it owned a resource: An unscheduled fiber cannot release the resource. Unscheduling a fiber is like <a href="http://blogs.msdn.com/oldnewthing/archive/2003/12/09/55988.aspx"> suspending a thread</a>: Anybody who later waits for that fiber to do anything will be waiting for an awful long time, because the fiber isn’t running at all. The difference, though, is that the fiber is unscheduled at controlled points in its execution, so you at least have a chance at suspending it at a safe time if you understand what the fiber is doing.
 For example, suppose you enter a critical section on a fiber, and then unschedule the fiber. Some time later, a thread (either running as a plain thread or a thread which is hosting a fiber) tries to enter the critical section. One of two things can happen:</p>
<ol>
<li>The thread happens to be the same one     that was hosting the fiber that entered the critical section.     Since a thread is permitted to re-enter a critical section     it had previously acquired,     the attempt to enter the critical section succeeds.     You now have two chunks of code both running inside the     critical section,     which is exactly what your critical section was supposed     to prevent.     Havoc ensues. </li>
<li>The thread happens to be different from the one that was     hosting the fiber that entered the critical section.     That thread therefore blocks waiting for the critical     section to be released.     But in order for that to happen, you have to reschedule the     owning fiber on its original thread so it can exit its     protected region of code and release the critical section. </li>
</ol>
<p> More generally, if you use an object which has thread affinity on a fiber, you are pretty much committed to keeping that fiber on that thread until the affinity is broken.
 This affinity can be subtle, because most code was not written with fibers in mind. Any code which calls <code>TlsGetValue</code> has thread affinity, because thread local storage is a per-thread value, not a per-fiber value. (This also applies to moral equivalents to <code>TlsGetValue</code>, like code which calls <code>GetCurrentThreadId</code> and uses it as a lookup key in a table.) You need to use <code>FlsGetValue</code> to get values which follow fibers around. But on the other hand, if the code is not running on a fiber, then you can’t call <code>FlsGetValue</code> since there is no fiber to retrieve the value from. This dichotomy means that it’s very hard if not impossible to write code that is both thread-safe and fiber-aware if it needs to store data externally on a per-thread/fiber basis. Even if you manage to detect whether you are running on a thread or a fiber and call the appropriate function, if somebody calls <code>ConvertThreadToFiber</code> or <code>ConvertFiberToThread</code>, then the correct location for storing your data changed behind your back.
 If you are calling into code that you do not yourself control, then in the absence of documentation to the contrary, you don’t really have enough information to know whether the function is safe to call on a fiber. For example, C runtime functions like <code>strcmp</code> have thread affinity (even though there’s nothing obviously threadlike about comparing strings) because they rely on the current thread’s locale.
 Bottom line: (similar to the bottom line from <a href="http://blogs.msdn.com/oldnewthing/archive/2004/12/31/344799.aspx"> last time</a>): You have to understand the code that runs on your fiber, or you may end up accidentally stabbing yourself in the eyeball.</p>
<p> <b>Bonus chatter</b>: Structured exception handling is fiber-safe since it is stack-based rather than thread-based. Note, however, that when you call <code>ConvertThreadToFiber</code>, any active structured exception handling frames on the thread become part of the fiber. </p>


</body>